Question,Answer 1,Answer 2,Answer 3,Answer 4,Answer 5,Explanation,Author
"The runtime for the following code fragment is ?(f(n)). What is f(n)?for (int i=0; i<n; i++) for (int j=0; j<i/10; j++) for (int k=1; k<n; k=2*k) System.out.println(i);
","nlogn
","n^2
","n^2(logn)
","n^3
","None of the above
",,"wd371 (wd371)
"
"Given the binary search algorithm, as taught in the lecture, and an array with the followingnumbers (from first to last index):5, 9, 11, 99, 110, 111, 200, 300, 500, 1000, 1001.How many iterations does the algorithm need to find the element 5?
","1 iteration
","2 iterations
","3 iterations
","4 iterations
",,,"wd371 (wd371)
"
"An algorithm has time complexity . Using the Definition of Big-Oh as given in the 2019 Week 1a Lecture (slide 14), fix B = 4.Assuming, what is the lowest possible value of b for which the definition holds?
","b = 12
","b = -4
","b = 6
","b = 9
","b = 0
","Solve for the roots of |T(N)|=4N^2. The roots are, N=6, N=9 for the equation T(N)=4N^2. Roots to -T(N)=4N^2 can be safely ignored.So the choice is b=9. You can quickly verify by substituting N=8 that b=6 does not satisfy the definition. b=12 satisfies the definition but is not the lowest possible value of b satisfying the definitionThe slightly harder version of this question can be found here:https://peerwise.cs.auckland.ac.nz/course/main.php?cmd=answerQuestion&id=4248139
",
"Which one of the following sorting algorithms is the quickest for an almost sorted array?
","Selection sort
","Insertion sort
","Bubble sort
","Merge sort
","Quick
",,"aa2955 (aa2955)
"
"Given the tree: a / \ b c / \ / \ e f g hWhat is the in order traversal?
","ebfagch
","abefcgh
","efbghca
","abcefgh
",,"For the in order traversal we start from the root node then go from top -> bottom and left -> right and see if we can reach the bottom part of the current node.
",
"Consider we have created an Adjacency Matrix M for some directed graph.a) What would we be able to determine from the matrix created by multiplying M by itself?b) What would we be able to determine if we did this again?
","a) The resulting matrix would show all vertices that are either 1 or 2 edges apartb) The resulting matrix would show all vertices that are either 1,2 or 3 edges apart
","a) The resulting matrix would show all vertices that are 2 edges apartb) The resulting matrix would show all vertices that are 3 edges apart
","a) The resulting matrix would show all vertices that are either 1 or 2 edges apartb) The resulting matrix would show all vertices that are either 1,2 or 4 edges apart
","a) The resulting matrix would show all vertices that are 2 edges apartb) The resulting matrix would show all vertices that are 4 edges apart
",,"See slide 11 of lecture 17 - graphs 1
",
"What is the time complexity of Dijkstra's Algorithm without a min-priority queue?
","O(V2)
","O(log V)
","O(V log V)
","O(E + V log V)
","O(V + E log V)
","shortest_path -> slide 21
",
"In a linked list what is the time complexity to insert(x) and remove(y) if you were given the reference to the previous element:
","insert(x):remove(y):
","insert(x): remove(y):
","insert(x): remove(y):
","insert(x): remove(y):
",,"2019 Week3b slide 10
",
"Santa has had one too many beers while flying the sleigh back to the North Pole when the police pull him over. The police ask for hisEASA Part-FCL commercial pilot license (CPL) and he realises that he left it in one of 60 remaining gift boxes. The gift box he needs to find is labelled ""Santa Claus"" with ""North Pole"" on. Each location ""e.g Africa"" is put into its own pile, there are 12 remaining piles in total. Each pile is ordered by name ""e.g Mrs Claus"", there are 5 gift boxes in each pile. Using a binary search, what is the worst-case complexity?
","6*(5/2)
","12*5
","log2(12) * log2(5)
","log2(12) + log2(5)
","log2(12) - log2(5)
","Binary search is log2(n) complexity, log(12) + log(5) for final.
",
"Is the below tree AVL? 5 3 7 2 6 81 9
","Yes
","No
","planation: Because the left side of the tree has a height difference of 2. Week8b
","gs: Trees
",,,"mdsb20 (mdsb20)
"
"What is the time complexity for completing 'n' searches in a balanced binary search tree?
","nlogn
","n^2
","logn
","n
",,"the time complexity for a single search in a balanced binary search tree is logn thus completing n searches results in a complexity of nlogn
","aar73 (aar73)
"
"What is the time complexity for completing 'n' searches in a balanced binary search tree?
","nlogn
","n^2
","logn
","n
",,"the time complexity for a single search in a balanced binary search tree is logn thus completing n searches results in a complexity of nlogn
","aar73 (aar73)
"
"Which is the correct post-order traversal of the tree? a / \ b c / \ \ d e f
","a b d e c f
","d e b f c a
","a b c d e f
","d e b a c f
",,"See Week 7b - Trees1
",
"Which data structure is described by:the value at each node is = the values at its two children.
","Max heap
","AVL Tree
","Min heap
","Binary tree
","Skip List
","Definition given in Week 5b Slide 4.
",
"What's average time complexity of performing a search in a hash table?
","
","
","
","
",,"Searching in a hash table is on average O(1), as we only have to compute the hash for the value we are searching for & look at the corresponding value in the hash table.
",
"The asymptotic memory usage of dense and sparse graphs where v is the number of vertices and e is the number of edges is:
","Dense: Sparse:
","Dense: Sparse:
","Dense:Sparse:
","Dense : Sparse:
",,"2019 Week9b slide 17
",
"An algorithm has a time complexity of?(n^3), when n = 2 it takes 2 seconds to complete how long does it take to complete when n = 4
","4
","8
","16
","32
","64
","2^3 = 8, 8/4 = 24^3 = 64, 64/4 = 16
",
"I am using the hash function H(x) = x % 7 to add functions to an open hash table. This hash table is indexed 0 to 6, with each bucket having a max length of 3.If a bucket ""overflows"", ie it is full and another element is added, this element is added to an overflow bucket.How many elements are inserted into the overflow bucket after the following elements are inserted?Elements inserted left to right (ie 29 is first insert 69 is last insert) : 29, 64, 63, 16, 48, 74, 143, 39, 80, 281, 4, 69.
","0
","1
","2
","3
","4
","29 % 7 = 125 % 7 = 464 % 7 = 163 % 7 = 016 % 7 = 248 % 7 = 674 % 7 = 4143 % 7 = 339 % 7 = 4 ---- ""4 bucket full""80 % 7 = 3281 % 7 = 1 ---- ""1"" bucket full4 % 7 = 4 ---- put into overflow7071 % 7 = 1 ---- put into overflow69 % 7 = 62 elements were added to the overflow
",
"Given a load factor of 0.3 what is the average number of steps for a Closed Hash table with linear probing to find an item.
","1.12 steps
","1.17steps
","1.21 steps
","1.25 steps
","1.3 steps
","Answer is 1.21 steps, see slide 31 of week10b-hashtablesall.pptx
",
"You have been approached by a company to recommend a fast and efficient sorting algorithm to use in Java. They often deal with large inputs of numerical data, and have limited storage. Which sorting algorithm is most suitable?
","Bubble Sort
","Quick Sort
","Insertion Sort
","Selection Sort
","Merge Sort
","Bubble Sort, Selection Sort and Insertion Sort are bounded by O(n^2), which is unacceptable for this situation. Both Quick Sort and Merge Sort have good runtimes (nlog(n)). However, the main reason why Quick Sort is preferred is that no extra space is used (sorting is done in place), compared to Merge Sort which can be memory consuming.
",
"What is the time complexity of the following algorithm : 0.00001n4 + 100n2 + 19nlogn + (10n2* 5n3 ) ?
","O(n2)
","O(n5)
","O(n4)
","O(nlogn)
","O(n7)
","The biggest function will dominate since we have(10n2 * 5n3 ) this equates to 50n5 which dominates the others.
","hacker_man (jm2787)
"
"What is the time complexity of the following algorithm : 0.00001n4 + 100n2 + 19nlogn + (10n2* 5n3 ) ?
","O(n2)
","O(n5)
","O(n4)
","O(nlogn)
","O(n7)
","The biggest function will dominate since we have(10n2 * 5n3 ) this equates to 50n5 which dominates the others.
","hacker_man (jm2787)
"
"Which one of the following statements regarding sorting is incorrect?
","An insertion sort is stable.
","The best, average and worst case time complexity for a selection sort are all the same.
","A heap sort is stable.
","The best, average and worst case time complexity for Shell's sort are all the same.
","The worst case time complexity of a bubble sort is
","a) is correct, as an insertion sort is indeed stable.b) is correct, as the best, average and worst time complexity for a selection sort are all .c) is incorrect, asa heap sort is not stable.d) is correct, as the best, average and worst time complexity for Shell's sort are all .e) is correct, as the worst case time complexity of a bubble sort is indeed .
",
"Given the functionsf(x) = 0.1 n5g(x) = 50 nlognh(x) = 0.5 2nhint ( O = at least , ? = at most, O = exactly (both O and? apply))Which of the following is true ?
","f is ?(g), g is O(f), h is O(g)
","f is O(g), g is ?(h), and h is O(g)
","f is O(g), g is O(f), h is ?(f)
","All of the above
","None of the above
","A - Wrong as f is much larger than g inf is ?(g), the larger function dominates n5dominates nlogn, for the same reason g is O(f) is wrongB - f is atleast g, because f dominates g we can say that f will be atleast g, g is at most h as h dominates g , and h is atleast g for the same reason making this correctC - f is exactly g is wrong since f dominates g, g is atmost h and h is atleast g however are correct
",
"Build an AVL Tree with the following values:15, 20, 24, 10, 13, 7, 30, 36, 25Which value does the root node point to?
","20
","24
","13
","15
","7
","See Week 8b-Trees3, slide 38 for implementation
",
"A Closed Hash w/Linear Probing takes 11/2 average steps and the array is size 10.How many items are in the array?
","7
","8
","9
","10
",,"Week10b-HashtablesAll Slide 31 for the formula of average number of steps to get a load factor of 0.9 and since the array is of size 10. 10*0.9 = 9 items.
",
"Given an integer array of randomly ordered 0's and 1's what is the worst case time complexity to sort them so that all the 0's come before the 1's. Use the most efficient sorting algorithm given the conditions of the array.
","O(N)
","O(N*LOG(N))
","O(N2)
","O(N2+N)
","O(N+LOG(N))
","The answer is A: O(N).Use the partition algorithm from quick sort. This works by choosing the first element as your pivot and then sorting every other element in relation to that pivot. As this only requires you to iterate through the array once it has complexity O(N).
",
"The list of numbers below create a balanced AVL Tree. Which of the following lists of numbers is printed out if you traverse the balanced AVL Tree using the post order method.4, 6.7, 2, 1, 1.5, 3, 5, 7, 6, 7.5
","3, 6, 7.5, 1, 2, 5, 7, 1.5, 6.7, 4
","1, 3, 2, 1.5, 6, 5, 7.5, 7, 6.7, 4
","4, 1.5, 1, 2, 3, 6.7, 5, 6, 7, 7.5
","1, 1.5, 2, 3, 4, 5, 6, 6.7, 7, 7.5
",,"The sorted list gives1, 1.5, 2, 3, 4, 5, 6, 6.7, 7, 7.5 and when a balanced tree is created using this list the root node is 4 and travesing this tree post order gives b as post order process the nodes in the left subtree then right subtree befor processng the current node.
",
"When using an array list what is the average time complexity for the function find(o) for an unsorted array
","1
","n
","n2
","log n
",,"B is correct here. If a list is unsorted then the list may have to be searched in it's entirity before the element is found
",
"When looking at the complexity of doing a bubble sort, what is the best and worst case
","Best: O(n log n)Worst:O(n log n)
","Best: O(n log n)Worst: O(n2)
","Best: O(n2)Worst O(n3)
","Best: O(n)Worst: O(n log n)
",,"The corrrect answer is A. The time complexity of a merge sort is always O(n log n)
",
"Consider an AVL tree where the following have been inserted (in the given order):10, 2, 21, 55, 69, 9, 79, 10After removing 55, what would the output of the In Order traversal of the tree be ?
","10, 2, 9, 21, 10, 69, 79
","2, 9, 10, 10, 21, 69, 79
","2, 9, 10, 21, 10, 69, 79
","9, 2, 10, 79, 69, 21, 10
","None of the above
","The balanced AVL tree looks like this: 10 / \ 2 21 \ / \ 9 10 69 \ 79In Order traversal works by going through all left nodes, then root and finally right nodes, thus the answer is2, 9, 10, 10, 21, 69, 79.
",
"Which of the following rules for big O is FALSE?
","If f(n) = O(n) and g(n) = O(n2), then the time complexity of f(n) + g(n) = O(n2)
","The time complexity of 100f(n) = O(f(n))
","If f(n) = O(g(n)), and g(n) = O(h(n)), then f(n) = O(h(n))
","If g1(n) = O(f1(n)) and g2(n) = O(f2(n)), then g1(n)f1(n) = O(g2(n)f2(n))
","None of the above
","A: The rule is sums, bigger function always dominates.B: The rule is scaling, constants do not matter in time complexity.C: The rule is transitivity,if A = B, and B = C, then also A = C.D: The rule is products, however the answer should beg1(n)g2(n) = O(f1(n)f2(n)) instead.
",
"Big Bank has many customers (about 20,000) but its customers typically only send payments to several people.Which type of graph representation would you use?
","Adjacency matrix
","Adjacency list
","planation: Adjacency list if you have few edges e between vertices and lots of vertices v
","gs: Graphs
",,,"wolfson1 (cr547)
"
"Given the tree: 16 / \ 9 19 / \ / \ 2 10 17 24 /1The nodes looked at are in the order:1, 2, 10, 9, 17, 24, 19, 16What kind of traversal does this describe?
","Pre-order Traversal
","Level Order Traversal
","In-order Traversal
","Post-Order Traversal
",,"Pre-order traversal: 16, 9, 2, 1, 10, 19, 17, 24Level-order Traversal: 16, 9, 19, 2, 10, 17, 24, 1In-order Traversal: 1, 2, 9, 10, 16, 17, 19, 24Post-order Traversal: 1, 2, 10, 9, 17, 24, 19, 16
",
"What is ""big O"" of heapify?
","O(n^2)
","O(n)
","O(logn)
","O(nlogn)
",,"Lecture 5b Slide 9
",
"Alice is organising a dinner party between a few close friends at her workplace. She is trying to figure out the seating plan and working on sending the invites. Most of the invitees know each other, so the number of friendships is larger than the number of invitees. Alice thinks a graph would help her figure out the seating plan where all the invitees are vertices and friendships of each person are edges.Alice also wants to store names along with employee ID numbers, which are 5 digit numbers, in order to send out email invites for the party.Which data structures are most suitable for each of these uses?
","Adjacency list for the seating plan, skip list for the invites.
","Adjacency matrix for the seating plan, linked list for the invites.
","Adjacency matrix for the seating plan, open hash table for the invites.
","Adjacency list for the seating plan, closed hash table for the invites.
","Adjacency list for the seating plan, open hash table for the invites.
","An adjacency matrix is the most suitable data structure for the seating plan, as the matrix will be dense (many edges compared to vertices). See 2019 Lecture 17 on Graphs, slide 17.An open hash table is the most suitable data structure for the invites, as it stores both the data and a key, which in this case is the employee ID number. See 2019 Week10b slides.
",
"Define the load of a hash table.
","The �load� of a hash table is how heavy it is.
","The �load� of a hash table is how many elements(�keys�) it contains.
","The �load� of a hash table is the maximum number of values (�keys�) you intend to adddivided by number of buckets in the array.
","The �load� of a hash table is the maximum number of values (�keys�) you intend to addplus the number of buckets in the array.
",,"Week 10b Slide 30
",
"What is the time complexity of this algorithm: 5n3+ 100n2+ 0.1n3.5 + 1000n?
","O(n3)
","O(n2)
","O(n3.5)
","O(1000n)
",,"The bigger function dominates during addition as of the week2b slides.
",
"What are the features of asymptotic complexity?
","Describes rate of growth of a function based of the data set size n.
","Considers large data sets size n.
","Approximates complexity by taking the largest n term.
","All of the above.
",,"Asymptotic behaviour is the limiting behaviour of the execution time of an algorithm, when the size of the data set goes to infinity (large n). Usually denoted in big-O Notation that is calculated by considering the largest n term.
",
"Big Theta Complexity Equation:
","
","
","
","gs: Complexity
",,,"eb2006 (eb2006)
"
"Which Array List operation has the same best, average and worst case runtime complexity?
","get(i)
","add(o)
","remove(i)
","insert(o, i)
",,"get(i): best, average and worst case O(1)add(o): best and worst case O(1) and average case (n)remove(i): best case O(1), average and worst case O(n)inset(o, i):best case O(1), average and worst case O(n)
",
"What is the worst case run time when trying to find an element in an AVL tree that consists of m * 2n elements ?
","T(m) + T(n)
","T(log n) + T(m)
","T(log m) + T(n)
","T(log m) + T(log n)
","T(log (mn))
","T(log n), where n is the number of elements, is the time taken to search an AVL tree. Given that the number of elements ism * 2n, the complexity becomesT(log (m * 2n)) =T(log m) + T(log (2n)) =T(log m) + T(n log(2)) =T(log m) +T(n).
",
"Which of the following best describes the run time of this algorithm:for(int i = 0; i<N; i++){ int j = -1; while(j<i){ System.out.println(""Good luck in your exams""); j++; } for(k=0; k<T; k++){ System.out.println(""You'll smash them!""); }}
","T(N2+ NT)
","T(N2 log(N))
","T(N2 + T2)
","T((NT)2)
","T(NT)
","The outer for loop will loop N times. Within this, the while loop will run up to N times, and the for loop will run T times.So the complexity isT(N(N+T)) =T(N2 + NT).
",
"Consider a closed hashtable H with linear probing. Suppose we want to store up to 900 items in H, and we want theaverageamount of steps to find any item to be less than 2.By considering the loadL, what is the smallest (whole) number of buckets H can have?
","1200
","1250
","1300
","1350
","1400
","First we calculate the loadL by using the formula for closed hashmaps with linear probing; average number of steps = 0.5 * (1 + 1/(1 - L)). Since we want the average number of steps to be less than 2, we pick 2 equal to average number of steps to give 1 + 1(1 -L) = 4, orL = 2/3. Therefore sinceL is equal to the total intended items over the amount of buckets B, 900 = 2/3 *B. If B is any smaller than this thenL must be greater and we do not have the desired step efficiency, so we want the smallest integer bigger than or equal to theB this formula gives us. Luckily, from this we getB = 1350, so this is our answer.Source of idea: Week10b-Hashtable Slide 31
",
"There are many methods to consider when designing an algorithm. Please select the option that is not a proper design technique.
","Brute Force
","Static Programming
","Divide and Conquer
","Greedy Algorithms
",,"DynamicProgramming is an actual design technique but Static Programming is not, hence it is the correct answer to this question.
","tu241 (tu241)
"
"There are many methods to consider when designing an algorithm. Please select the option that is not a proper design technique.
","Brute Force
","Static Programming
","Divide and Conquer
","Greedy Algorithms
",,"DynamicProgramming is an actual design technique but Static Programming is not, hence it is the correct answer to this question.
","tu241 (tu241)
"
"What is the complexity of the following algorithm?for(int i=0;i<n;i++) for (int j=0;j<i;j++) return i+j; }}
","
","
","
","
",,"The operation print i+j is done 1+2+3+....+n times so total cost is: So the algorithm is
",
"Of the following sorting algorithms, which one has equivalent Best, Worst and Average time complexitiesandis not unstable?(For example, Selection Sort has a Best, Worst and Average time complexity of n^2. It is also stable, and thus would be a correct answer if it were there.)
","Quick Sort.
","Merge Sort.
","Bubble Sort.
","Insertion Sort.
","None of the above.
","(Information obtained from 2019 Lecture 7a, slide 5)Algorithm time complexities in order: Best, Average, Worst.Quick: nlogn , nlogn , n^2 (Quick Sort is the only unstable algorithm here so can be instantly ruled out, the rest are stable.)Merge: nlogn , nlogn, nlognBubble: n , n^2 , n^2Insertion: n , n^2 , n^2From these options, Merge Sort is the correct answer as it is the only stable algorithm with all 3 cases having the same time complexity (namely nlogn).
",
"Of the following processes, which data structure (Singly Linked Lists or Arrays) can complete the following tasks described faster:Task 1: Getting to the 1000th item in the data structure.Task 2: Inserting a new item at the front of the data structure.Task 2: Removing an item from the middle of the data structure.Example: An answer of [LL : A : LL] would imply that the Linked List performed task 1 fastest, the Array performed task 2 fastest, and the Linked List performed task 3 fastest.(Not the correct answer).
","[A : A : LL]
","[LL : LL : LL]
","[LL : A : A]
","[A : LL : LL]
","[A : A : A]
","(Week 3b 2019, slide 13)Task 1: Arrays are faster since we can get to item 1000 in 1 step, whereas in a Linked List we must pass through 999 nodes to reach the 1000th node.Task 2: Lists are faster since it takes very few steps to update nodes, whereas in an Array we must shift every element after the insertion point to the right.Task 3: Lists are faster for similar reasons to Task 3, but shifting left instead of right.This implies the answer [A : LL : LL].
",
"Calculate given that . (Hint: Use the fact that [x^p= x mod p] when p is prime).
","a = 1.
","a = 3.
","a = 5.
","a = 7.
","a = 11.
","Using Fermat's Little Theorem (2019 week 11b, slide 12), we have that[x^p = x mod p] when p is prime. Noticing that 51 = 3 * 17, we let p = 17 (which is prime), and x = 7.Thus we obtain that 7^17= 7 mod 17.From which wee see that 7^51 = (7^17)^3 and so 7^51 = 7^3 mod 17 = 3 mod 13, and we are finished.
",
"What isDijkstra's algorithm?
","A sorting algorithm
","A shortest path algorithm
","A hashing algorithm
","An encryption algorithm
","A search algorithm
","(Purposefully not chosen a topic to not give answer away)
","andrewwardle (atw38)
"
"What isDijkstra's algorithm?
","A sorting algorithm
","A shortest path algorithm
","A hashing algorithm
","An encryption algorithm
","A search algorithm
","(Purposefully not chosen a topic to not give answer away)
","andrewwardle (atw38)
"
"What would the result be when an in-order traversal is applied to the following tree? 15 / \ / \ / \ 9 13/ \ / \6 3 4 2
","15, 9, 6, 3, 13, 4, 2
","6, 9, 3, 15, 4, 13, 2
","15, 9, 13, 6, 3, 4, 2
","6, 3, 9, 4, 2, 13, 15
",,"A = Pre-order traversalB = In-order traversalC = Level order traversalD = Post-order traversal
",
"What is the worst case run time of insertion sort?
","?(N)
","?(N2)
","?(N!)
","?(logN)
",,"Source: 2019 Week 4a, Slide 16
",
"What other 2 algorithms does Hybrid sort ( timsort ) utilise in its implementation?
","Merge sort and insertion sort
","Insertion sort and Bubble sort
","Quicksort and Bitonic sort
","None of the above
",,"Timsort utilises insertion sort until a given treshold, where merge sort starts being faster and more efficient.
",
"Given the following hash table, using linear probing, where the hash function being used is ...0 1 2 3 4 5 6 7 8 9-------------------------------|5 |35| | | | | |42| | |-------------------------------...what would the state of the hash table be after inserting 32, 27 and then 6?
","0 1 2 3 4 5 6 7 8 9-------------------------------|5 |35|27|6 | | | |42| |32|-------------------------------
","0 1 2 3 4 5 6 7 8 9-------------------------------|5 |6 |27| | | | |32| | |-------------------------------
","0 1 2 3 4 5 6 7 8 9-------------------------------|5 |35|6 |27| | | |42|32| |-------------------------------
","0 1 2 3 4 5 6 7 8 9-------------------------------|5 |35|27|6 | | | |42|32| |-------------------------------
",,"Option A has been created simply by inserting 32 in the wrong position. Option B has been created by, when a collision occurs, replacing the value at the index computed by the hash function with the new value. Option C has been created by inserting 6 and 27 in the wrong order.
",
"Consider the following problem:Given an array of integers, find the maximum product of two integers in the array. For example, consider the array [ -10, -3, 5, 6 , -2 ]. The maximum product is formed by either the (-10, 3) or (5, 6) pair.What is the complexity of the most efficient algorithm that solves this problem?
","1
","n
","n(log(n))
","log(n)
","n2
","The answer is n.The most efficient algorithm traverses once through the array in order to find the 2 largest and 2 smallest (also smaller than 0) elements and compares the products.
",
"Which of the following would NOT be a solution to a hash collision when inserting into a hash table?
","Insert the element in the next available position in the hash table, found by searching linearly.
","Recalculate the hash of the element being inserted.
","Insert the element in thenext available position in the hash table, found by searching exponentially (i.e. by skipping increasing numbers of elements: 0, 1, 2, 4, 8, etc.).
","Instead of storing single elements at each position in the table, store lists of the elements that hashed to that position.
",,"B is not a valid approach because the hash of the element will not change when calculated again.
",
"Consider an unordered complete binary tree containing all letters from A to G. Knowing that a preorder traversal of the tree results in the sequence [ B, G, C, D, A, E, F ] and a postorder traversal results in the sequence [C, D, G, E, F, A, B ], what results from an inorder traversal?
","E, A, B, C, D, F, G
","A, B, C, D, E, F, G
","C, G, D, B, E, A, F
","C, B, D, G, A, E, F
","D, A, E, G, F, B, C
","We traverse by visiting the left subtree first, then the root, then the right subtree for each node of the tree, thus the inorder traversal is C, G, D, B, E, A, F.
",
"Which of the following COULD be a reason for choosing to use a skip list over a linked list?
","It needs to be possible to insert items whilst updating as few pointers as possible.
","There is limited space available in memory.
","Duplicate items need to be able to be stored.
","Inserting items so that they are already in sorted position once inserted needs to be as fast as possible.
",,"A. This is reversed - a skip list would require updating more pointers to insert an item than a (singly or doubly) linked list would.B. This is also reversed - skip lists use more memory than linked lists.C. This would not be a reason to use a skip list - skip lists likely disallow duplicate items, since they sort based on value, but even if they allowed them skip lists wouldn't offer an advantage here.D. Skip lists insert items in an already-sorted position in the list cheaply, which would be an expensive operation requiring many node and pointer accesses with a linked list.
",
"What is the maximum height of a perfectly balanced search tree of size n (2019 Lecture 8a slide 28)
","log(n)
","n
","n/2
","2/n
","n/2n
","The answer is log(n) because the number of nodes in a row is equal to 2x where x is the number of the row. Therefore the answer is log(n) as this is the inverse of 2x
",
"Consider a balanced AVL Tree as below: 5 / \ 3 6 \ 7This AVL Tree will attempt to balance itself whenever it become unbalanced using a rotation algorithm.If we insert the number 9 to the tree and then perform a post order traversal printing the values in the tree.What is the output?
","3 5 6 7 9
","3 6 9 7 5
","5 3 7 6 9
","3 5 9 7 6
",,"B is correct as the tree would look as below: 5 / \ 3 7 / \ 6 9A post order traversal on this tree produces the answer B.A is an in order traversal, C is a pre order traversal and D is a post order traversal on a different tree.
",
"Which of the following input arrays makes insertion sort in descending order perform the largest number of operations?
","(9, 8, 7, 6, 5, 4, 3)
","(6, 5, 3, 4, 8, 9, 7)
","(7, 6, 5, 9, 8, 3, 4)
","(3, 4, 5, 6, 7, 8, 9)
",,"A perfectly disordered arrayis the worst case since every round requires maximum comparisons & shifts. Since the array is being sorted in descending order, the array that would result in the most comparisons and shifts would be an array in ascending order.
",
"What is the maximum possible number of elements in a binary tree of depth 7?
","52
","255
","2047
","128
","127
","The number of nodes possible in a binary tree of depth d is 2d+1- 1(Week 7b, slide 11).27+1- 1 = 256 - 1 = 255
",
"How many different insertion sequences of the key values, using the hash function h(k)=k mod 10, will result in the closed hash table with linear probing given below?
","10
","20
","30
","40
","50
","The first key which is not at the index computed by hash function is 42. It means index 2 and 3 were already occupied and therefore, key 42 is placed at index 4.The keys 72 and 33 are present at index 2 and 3 respectively. As these keys are at their correct position, their order of insertion does not matter. These 2 keys can be inserted in 2! = 2 ways. Therefore, the sequence will be any order of (72, 33) followed by 42.The next key which is not at the index computed by hash function is 31. It means indexes 1 to 5 were already occupied and key 31 is placed at index 6. Therefore, it is the last key to be inserted into hash table.The keys 61 and 25 are each present at their correct position computed by the hash function. Therefore, they can be inserted at any place in the sequence before 31. The sequence excluding 31 has so far 3 elements (72, 33, 42), which create 4 positions for 61 (2 in-between and 2 corners). Now we have 4 elements in the sequence excluding 31, and so there 5 positions for 25 (3 in-between and 2 corners).Total number of ways is: 2*4*5 =40.
",
"What is the method forSelection Sort?
","?Find the smallest item in the list and swap it with the first. Repeat this with rest of unsorted list.
","In repeated passes, swap adjacent items until list is fully sorted.
","Recursively split the array into equal sections and combine as sorted.
","Choose an element as a pivot and put elements less than the pivot to the left and greater than to the right, repeat recursively to these sublists.
",,"A) Selection SortB) Bubble SortC) Merge SortD) Quick Sort
",
"An algorithm takes 1s for n = 200, 1000s for n = 2000 and 8000s for n = 4000.Which asymptotic complexity does it likely have?
","?(n2)
","?(n log n)
","?(n3)
","?(2n)
",,"n: 200 ? (x 10) ? 2000 ? (x 2) ? 4000Time: 1 ? (x1000) ? 1000 ? (x8) ? 8000n ? Timex10 ? x1000x2 ? x8Time = n3? ?(n3)
",
"Which one of the List has the quickest average run time for insert() if n >= 1000;
","Array List
","Singly Linked List
","Doubly Linked List
","Skip List
","All of them have the same time complexity of insert().
","The correct answer is C because the average run time for insert() for each List is:Array List =?(n)Singly Linked List =?(n)Doubly Linked List = ?(1)Skip List =?(log n)When n >= 100?(1) <?(log n) <?(n)
",
"Which of the following statements about sorting algorthms is false?
","Merge sort is always quicker (in terms of time complexity) than bubble sort.
","Merge sort can be slower than insertion sort in certain scenarios.
","Merge sort, selection sort and quick sort are all examples of divide and conqueralgorithms.
","Merge sort always has time complexity of O(n log n).
",,"Selection sort is not a divide and conquer algorthm, it is an in-place sorting algorithm.A is correct as merge sort is always O(n log n) as in D, whilst bubble sort is always O(n2).B is correct as when the list is already sorted insertion sort has a time complexity of O(n).
",
"When inserting a value into aBinary SearchTree, what is the worst case and average case time complexity?
","Worst case: O(n2)Average case: O(log n)
","Worst case: O(n2)Average case: O(n)
","Worst case: O(n)Average case: O(log n)
","Worst case: O(n log n)Average case: O(log n)
",,"To insert a value the algorithm must first search through the tree, a search is worst case O(n), average case O(log n). See D&A-Revision2.pptx pg. 35
",
"You have been hired by the Housing Opportunities of Northern Delaware Association to create a system which allows them to keep track of which addresses they currently have available. They have spent many decades supporting the people of the area in finding the perfect home, but have recently began to fall behind newer tech-based companies, and are determined to catch up and ensure they provide the highest quality service they can.The system is required to have the following qualities:- It must be quick to search for a given address, to find whether or not it is currently stored in the system, and to access its details. Speed is more important than space used, to ensure users are not left waiting for too long while the system runs.- It should be easy to add new addresses to the system as they become available, and to remove them once they are taken off the market.- The data does not need to be sorted, as employees personally work with each customer to recommend different homes, and so will be searching for entries directly.- You have only a rough estimate of how many addresses will need to be stored at a given time, and the number tends to vary by a large margin throughout the year due to seasonal buyers.Which data structure should you implement in the new system?
","A Linked List
","A Closed Hash Table
","An Open Hash Table
","An AVL Tree
","A Heap
","A Hash Table is the optimal data structure for the system. Linked Lists and Tree structures require you to search through a potentially large number of nodes to find a specific address, while hashing allows you to jump either straight to the required data or at least very close to it.Unlike a Closed Hash Table, Open Hash Tables are able to grow out linked lists as more data is added instead of simply filling up. Open Hashing also requires a much lower average number of steps to find any given piece of data.
",
"A �stack� data structure operates in a last in last out fashion.
","True
","False
","planation: A stack has only two operations (push and pop). Push adds an element to the stack, placing it at the top. Pop removes the top element. As such a stack operates as first in last out.
","gs: ADTs
",,,"jdl42 (jdl42)
"
"How many cases are there when we are removing a node from a binary search tree?
","2
","3
","4
","5
","6
","There are 3 cases:One node is a leafOne node has one childOne node has two children
",
"Which of the following data structures has a worst case space complexity of O(n log n)?
","AVL Tree
","Singly-Linked List
","Doubly-Linked List
","Skip List
","Hash Table
","Skip List - every other data structure has a O(n) space complexity. However, the skip list has a greater size because each new node added does not add a constant number of pointers, but rather an increasing number (think of the number of lanes and how it increases when more elements are added: more lanes = more pointers).
",
"Exponential time complexity is slower than factorial time complexity
","True
","False
","planation:
","gs: Search, Complexity
",,,"cm2259 (cm2259)
"
"Dijkstra algorithm is a example of which of the following type of algorithm
","dynamic programming
","backtracking
","divide and conquer
","greedy
","brute force
","The answer is D because greedy algorithms make the optimal choices at each step in other to find the overall optimal way of solving the problem
",
"Which rotation operations would need to be performed to balance this AVL Tree? F / \ A M / \ H X / \ G J
","Left Left
","Left Right
","Right Right
","Right Left
",,"See week8b lectures 2019.A right rotation about M then a left rotation about F will result in a balanced tree.
",
"You have just finished your A-levels and are on a gap yaaa in Switzerland skiing,You have a map that showsyou the ski lifts to travel between slopes, seen aboveIn some cases, using multiple ski lifts is quicker than using the direct line.Using Dijkstras algorithm, calculate the length of the shortest route to each slope from the base camp.
","A=5B=21C=15D=7E=45
","A=5B=10C=15D=7E=13
","A=21B=6C=12D=19E=10
","A=5B=27C=15D=7E=13
",,"The quickest routes are as followsA = Direct from base campB = Base camp -> A -> BC = Direct from base campD = Direct from base campE = A->B->E
",
"Pre-Order traversal on the following tree will give which output? 9 / \ 6 15 / \ \ 1 8 21 / \ 7 25
","9, 7, 6, 1, 8, 21, 25, 15
","9, 6, 1, 8, 7, 15, 21, 25
","1, 6, 7, 8, 9, 15, 21 ,25
","1, 7, 8, 6, 25, 21, 15, 9
","9, 6, 1, 8, 7, 25, 21, 15
","See the lecture slides from week 7b pre-order traversal. This take the element from the left as you traverse the tree which gives option B
",
"Which one of the following options is an advantage of using an AVL Tree rather than a Binary Search Tree?
","It is always faster for insertion than a regular binary search tree
","It has a better worst-case complexity for search than a regular binary search tree
","You can remove from an AVL tree but not from a binary search tree
","Pre-order traversal is possible with an AVL tree, but not with a binary search tree
",,"A) It is not always faster for insertion, and in fact is often slower because of the rebalancing performed after the initial insertion.B) The correct answer: balancing gives it O(log n) worst case as opposed to a binary tree's O(n) worst complexity.C) You can remove from both tree types with the correct algorithm.D) Pre-order traversal is possible with any type of tree data structure, not just AVL trees.
",
"The greater the load factor of a hash table, the lower the number of steps required to search the table for a value.
","True
","False
","planation: Load factor is the proportion of buckets that are occupied: load factor = number of values stored / hash table capacity. Thus a low load factor (close to 0) means that many buckets in the table are empty, and a high load factor (close to 1) means that many buckets in the table are occupied.As a result, it requires fewer steps on average to search for a value in a hash table with alow load factor as the array contains lots of empty space that will never need to be searched.See Week10b slides 31-32 on hash table efficiency.
","gs: Hashtables
",,,"tb799 (tb799)
"
"Which of the following data structures has the slowest average time complexity for inserting an item?
","Array
","Stack
","Skip List
","Queue
","Hash Table
","A Skip List has an average time complexity ofT(log(n) for insertion making it the slowest compared toT(n) for an Array andT(1) for the Hash Table, Stack and Queue.
",
"What is the average and worst case search time for a given element in a skip list?
","Worst Case: O(n)Average Case: O(n(log n))
","Worst Case: O(1)Average Case: O(log n)
","Worst Case: O(n)Average Case: O(n^2)
","Worst Case: O(n)Average Case: O(log n)
","Worst Case: O(log n)Average Case: O(n)
","See skip list run time slide in lecture 3b.Land log(n) -1 skips approximatly n/2 nodes for average case of O(log n)and for worst case the skip list is unable to skip any elements meaning it is a linear search og O(n)
",
"I am using the hash function H(x) = x % 7 to add functions to an open hash table. This hash table itself is indexed 0 to 6 and stores pointers to the head elements of singly linked lists which store the values added to the hash table.After the following elements are inserted (in the order they are written), how many values are stored in the linked lists that are pointed to by index 0 and index 6 respectively? (Please note that the head pointer does NOT count as a value stored)Values to add to the hash table: 49, 22, 36, 135, 48, 73, 209, 105, 1042, 591, 5, 256.
","3 and 1 respectively
","0 and 3 respectively
","1 and 1 respectively
","2 and 3 respectively
","5 and 3 respectively
","49 % 7 = 022 % 7 = 136 % 7 = 1135 % 7 = 248 % 7 = 673 % 7 = 3209 % 7 = 6105 % 7 = 01042 % 7 = 6591 % 7 = 35 % 7 = 5256 % 7 = 4Hence 2 items are stored at index 0 and 3 items are stored at index 6
",
"Take the following pseudocode for sorting books by height on a shelf:void sort(shelf of N books){ for i = 1 to N { find the smallest book between slots i and N swap this smallest book with book i; }}Which type of sort has occurred?
","Insertion sort
","Merge sort
","Bubble sort
","Selection sort
","Quicksort
","This is a selection sort algorithm which repeatedly finds the smallest book and puts it at the start of the shelf.
",
"If the balance factor of a tree node equals to 2, when rebalancing an AVL tree, which of the following pseudo-code holds true?
","rightRotate(node)
","leftRotate(node)
","node.left = leftRotate(node.left)rightRotate(node)
","node.right = rightRotate(node.right)leftRotate(node)
",,"SeeGeeks for Geeks - Tree Insertion
",
"The load factor for a hash table is:
","The capacity divided by the number of collisions
","The number of collisions divided by the capacity
","The capacity divided by the number of occupied locations
","The number of occupied locations divided by the capacity
","None of the above
","The load factor is defined as:load factor = n/k,where n is the number of locations occupied in the hash table and k is the number of bucketsThe load factor should be less than 1
",
"Which two sorting algorithms have a best (O), average (?), and worst-case (O) time complexity of n(log(n))?
","Heap Sort & Bubble Sort
","Merge Sort & Quick Sort
","Merge Sort & Heap Sort
","Quick Sort & Merge Sort
","Merge Sort & Bubble Sort
","Bubble Sort has a best-case time complexity ofO(n), an average-case of?(n^2) and a worst-case ofO(n^2) so it cannot be A or E.Quick Sort has a worst-case time complexity ofO(n^2) so it cannot be B or D.This leaves C with Merge and Heap Sort which do have a time complexity of n(log(n)) for each of best, average and worst cases.Full table of time complexities can be found in the slides of lecture week7A 2019.
",
"You have been hired by a surgery to create a system that can hold patient records. The surgery is extremely busy, so retrieving records must be as fast as possible. The surgery has stated that the previous system allowed them to sort records, but this feature was no longer required. As many patients join and leave, insertion and deletion must both be very fast.
","Hash Table (Open Hashing)
","Binary Search Tree
","Hash Table (Closed Hashing)
","AVL Tree
","Doubly Linked List
","Evidently, due to the need for extremely fast lookup times, a hash table is required with its O(1) complexity. This works well as the data will not need to be sorted. The open hashing table should be chosen, as deletion is much easier when compared to the closed hashing table, while still maintaining fast insertion.
",
"Analyse the sorting algorithm belowvoid sort(int arr[]){ int n = arr.length; for (int i = 0; i < n-1; i++) { int min_idx = i; for (int j = i+1; j < n; j++) if (arr[j] < arr[min_idx]) min_idx = j; int temp = arr[min_idx]; arr[min_idx] = arr[i]; arr[i] = temp;}State the name of the algorithm, the worst complexity, average complexity and best complexity
","Bubble sort, n^2, n^2, n^2
","Bubble sort,n^2, n^2, n
","Selection sort, n^2, n^2, n^2
","Merge sort,n*log(n),n*log(n),n*log(n)
","Selection sort, n^2, n^2, n
","C is the right answer because the algorithm is a selection sort and the worst, average and best complexity of selection sort is n^2
",
"Emma likes to organise her book collection alphabetically. When she goes away to Uni, her mother buys a few books for her every month.However, she doesn't stick to Emma's system and just slides the books wherever it's more convenient. She doesn't rearrange the existing books.When Emma comes home on vacation, she wants to sort her books back into alphabetical order.What's the fastest algorithm that Emma could use?
","Heap sort
","Merge sort
","Insertion sort
","Quick sort
","Shell sort
","Insertion sort is fastest for nearly sorted data.Heap sort, merge sort and quick sort don't adapt to nearly sorted data.
",
"A shell sort where h=1 is equivalent to which other sort?
","Merge sort
","Insertion sort
","Selection sort
","Bubble sort
","Heap sort
","Insertion sort is effectively a special case of the shell sort, with h=1
",
"What is the complexity of insertion sort on an already sorted array?
","O(log n)
","O(n)
","O( )
","O(2n)
",,"The algorithm simply traverses the array in one pass and does not need to make any swaps
",
"Which of the following is not a function of a stack?
","push(Object i)
","Object pop()
","removeElement(int index)
","Object peek()
",,"Stacks are a FIFO data structure, meaning only elements on the top of the stack may be removed at any time.
",
"Consider the following binary tree:What would be the outcome of printing each node via in-order traversal?
","D B E G H C F A
","D B G E H A C F
","A B C D E F G H
","D G H E B F C A
","G H D E F B C A
","In-order traversal considers the left node, current node, and right node, in that order, traversing recursively.
",
"Is it possible to search for any word in the english language in constant time complexity ?
","Yes
","No
","planation: This can be done through the use of a TrieAn example of a Trie is bellow:Any word can be found in constant complexity, more specifically in H steps, where H is the length of the longest word/string
","gs: Search, Trees, Complexity
",,,"cm2259 (cm2259)
"
"If you perform a bubble sort on the list:62, 90, 14, 43, 54, 94, 18, 74, 3, 49How many swaps will have been carried out after the 5th pass?
","23
","20
","27
","31
","28
","62, 14, 43, 54, 90, 18, 74, 3, 49, 94 - 7 swaps in 1stpass14, 43, 54, 62, 18, 74, 3, 49, 90, 94 - 7 swaps in 2nd pass14, 43, 54, 18, 62, 3, 49, 74, 90, 94 - 3 swaps in 3rdpass14, 43, 18, 54, 3, 49, 62, 74, 90, 94 - 3 swaps in 4th pass14, 18,43, 3, 49, 54, 62, 74, 90, 94 - 3 swaps in 5thpass7 + 7 + 3 + 3 +3 = 23 swaps
",
"Given the hash function of % 11 into an open hashing table, which item will take the most comparisons to find if the following items are added using the given hashing function?11, 17, 32, 132, 4, 9, 100, 34, 25, 98, 165, 77, 40.
","11
","77
","40
","25
","165
","In an open hashing table when a value is found it is stored in a data structure such as a list or an array. This means that duplicates are stored later in the list/array and more comparisons are needed to find the item as you will need to compare the searched for value against every item before it as you can not know if it is actually stored otherwise. In this case 0 is the most popular value at 4 values and so the last item to be added will require the most comparisons (which is 77).
",
"What conditions need to be met for a binary tree to be perfectly balanced
","for every node, the number of nodes in its left and right subtree differs by one.
","for every node, the number of nodes in its left and right subtree are equal.
","The height of the right nodes is equal to the height of the left nodes
","all levels of the tree have to be filled
",,"A is the correct answer becuase some list can't create trees with the same number of nodes on each subtree for example lists of even length, but these lists can still create a balanced tree.
",
"Which binary tree traversal is similar to expression evaluation?
","Pre-order
","In-order
","Post-order
","Level-order
",,"Expression evaluation evaluates the left subtree, then the right subtree, then applies the operator in the current node to those results. (2019 Week7b-Trees1, slide 36)The post-order traversal traverses the left subtree, then the right subtree, then the current node.(2019 Week7b-Trees1, slide 24)
",
"Which two sorting algorithms have a best case time complexity of O(n)
","selection sort and bubble sort
","merge sort and heap sort
","quick sort and insertion sort
","insertion sort and bubble sort
","merge sort and quick sort
","Selection Sort = O(n^2)Bubble Sort = O(n)Insertion Sort = O(n) Heap Sort = O(n log(n)) Quick Sort = O(n log(n)) Merge Sort = O(n log(n))
",
"Consider you are implementing a hash table with 200 possible buckets, and intend to add a maximum of 150 keys to the table.The hash table is closed and uses linear probing.What is the average number of steps taken to insert/find an item in this hash table?
","~1.05
","~2.5
","~2.16
","~3.00
","~1.21
","1) Calculate the load factor, L by the number of keys divided by the number of buckets -> 150/200 = 0.752) Average steps = 0.5 * ( 1 - 1 / (1-L) ) = 0.5 * ( 1 - 1 / ( 0.25) ) = 2.5
",
"The result of each pass of a sorting algorithm is shown below:Initial list: 3 4 2 1 7 5 8 61st pass: 2 1 3 4 7 5 8 62nd pass: 1 2 3 4 7 5 8 63rd pass: 1 2 3 4 5 6 7 84th pass: 1 2 3 4 5 6 7 8Which sorting algorithm was used?
","Insertion sort
","Bubble sort
","Quick sort
","Selection sort
","Merge sort
","It just is, 3 was used as a pivot in the 1st pass, 2 and 4 used in 2nd pass, 7 used in 3rd pass, 5 used in 4th pass, and then the algorithm knows the sort is complete.
",
"Which data structure can be implemented to enable both adding at the beginning and removing at the end to have O(1) complexity?
","Ring Buffer
","Rectangle Buffer
","Box Buffer
","Elliptical Buffer
","Square Buffer
","Ring Buffer, also known as Circular Buffer,is a data structure that uses a single, fixed-size buffer as if it were connected end-to-endThe circular buffer is well-suited as a FIFO buffer
",
"What would be the path of a pre-order search on the following tree? 5 / \ 3 7 / \ \ 2 6 9 / \ \ \ 1 4 8 10
","5, 3, 2, 1, 4, 6, 8, 7, 9, 10.
","1, 2, 4, 3, 6, 8, 5, 7, 9, 10.
","1, 4, 2, 8, 6, 3, 10, 9, 7, 5.
","5, 3, 7, 2, 6, 9, 1, 4, 8, 10.
",,"Pre-order follows Root,Left,Right. This means you add the root node first then go left then right. So you follow the tree down to the left adding each root node then you move back up until a right path is available then you move to the right path and repeat till complete.B is Inorder. (Left, Root, Right).C is Post-order. (Left, Right, Root).D is Level-Order. (Depth first left to right).
",
"Which data structure has nodes, leaves and branches?
","Tree
","Array
","Linked List
","Doubly Linked List
","Heap
","Linked lists contain nodes but not the other two, a tree contains all three
",
"Which data structure is a degenerate binary tree most similar to?
","Array
","ArrayList
","Heap
","Linked List
","Hash Table
","A degenerate tree is a binary tree in which each parent node has at most one child node each. This creates a tree with a height of n instead of log(n), and the tree behaves like a linked list.
",
"Searching a linked list starts from which position?
","Tail
","Any point
","Head
","73rd point
",,"It is impossible to access nodes of a linked list without going through the first
",
"Which sort doesn't have a best time complexity ofO(n log(n)).
","Quick Sort
","Heap Sort
","Merge Sort
","Bubble Sort
",,"Bubble Sort has a complexity of O(n)
",
"(529 - x) is divisible by 29, x>0. What is the smallest possible value of x?
","28
","5
","0
","6
","24
","Fermats little theorem, if p is prime, ap=a mod p
","joetucker (jt2039)
"
"(529 - x) is divisible by 29, x>0. What is the smallest possible value of x?
","28
","5
","0
","6
","24
","Fermats little theorem, if p is prime, ap=a mod p
","joetucker (jt2039)
"
"Given the following tree, what would be the result of a post-order traversal?
","3, 2, 1, 5, 4, 6
","1, 2, 3, 5, 4, 6
","1, 2, 4, 6, 5, 3
","6, 4, 1, 5, 2, 3
",,"Post-order traversal visits the left-hand child node, then the right-hand child node, before visiting the parent node.
",
"This abstract data structure uses nodes to contains its elements, has a pointer that indicates its head, or leading, element (and potentially one to indicate its tail element) and each of its nodes contains a reference to both the node ahead of it and behind it. What is it?
","Stack
","Linked List
","Doubly Linked List
","Array
","Heap
","It is a doubly linked list - seeWeek3b-TFLinkedlistsedit on Moodle.
",
"Jimmy owns a large selection of vinyl records. He has just inherited more records from his recently deceased mother.His mother had the exact amount of records that Jimmy has, doubling Jimmy's collection.Jimmy has decided that now is a good time to finally sort his collection by arranging the records in alphabetical order, whilst adding the new ones.Jimmy has some preferences when it comes to sorting the collection:- He doesn't have any more space for sorting. He has enough storage for all of the records, no more, no less.- With a large number of items to sort, he wants this done as fast as possible.
","Heap sort
","Bubble sort
","Insertion sort
","Quick sort
","Merge sort
","Heap sort:- More storage is required for sorting.Bubble sort:- Not great for larger quantities of data.- Not good for real life situations.Insertion sort:- Tends to not be as good for larger quantities of data.Merge sort:- Requires more space for sorting.Quick sort is best because it doesn't require any more space, and is the fastest algorithm that deals with large quantities well.
",
"Which of the following are the correct balance factors for the following tree? 6 / \ 3 10 / \ 2 4 \ 5And is it balanced?
","-2 / \ 1 0 / \0 1 \ 0And the tree is balanced.
","-1 / \ 1 0 / \0 1 \ 0And the tree is balanced.
","-2 / \ 1 0 / \0 1 \ 0And the tree is not balanced.
","-2 / \ 2 0 / \ 0 1 \ 0And the tree is not balanced
",,"The balance factor is the maximum length of the chain from the right node minus the maximum length of the chain from the left node.For example the root node 6 has the longest right chain as just 10 but the longest left chain of 3, 4, and 5. Meaning its balance factor is -2.Secondly a tree is only balanced when no balance factor is greater than 1 or less than -1. So as this tree has the balance factor of -2 for its root node it is not balanced.
",
"What sorting algorithm is for the code belowfor (i = 1; i < n; i++){key = arr[i];j = i - 1;while (j >= 0 && arr[j] > key){arr[j + 1] = arr[j];j = j - 1;}arr[j + 1] = key;}}
","Insertion sort
","Bubblesort
","Heap sort
","Quicksort
",,"2019 Lecture 20
",
"What is the runtime for this section of code?for(int i=1; i<n; i*=2) for(int j=0; j<10; j++) System.out.println(""any pickles?"");
","?(n)
","?(log(n))
","?(n^2)
","?(nlog(n))
",,"In the first for loop we are multiplying i by two each time giving us a runtime of ?(log(n)), this would be the same if we started with a large i and halved it each time.We can ignore the second for loop as it relies on a constant.
",
"If 617 � x is divisible by 17.What is the value of x?
","7
","6
","16
","5
","17
","Application of Fermat's Little Theorem (not expressed in the notation of modular arithmetic).17 | 617 � 6Expessed in the notation of modular arithmetic:617= 6 ( mod17 )
",
"Which of the following statements regarding complexity isnot correct?
","The upper bound g(n) = ?(f(n)) if and only if there are constraints c > 0 and n0 > 0 so that for all n > n0, g(n)= cf(n)
","The algorithm:k = n;while (k > 1){ sum++; k = k/2;}Has complexity O(log(n))
","When computing the complexity of multi-input algorithms, we only need to consider the size of the largest input
","The algorithm:for ( int i = 0; i < n; i++ ) for ( int j = 2; j < n*n; j++ ) sum++;Has complexity O(n3)
","A function with complexity O(log(n)) has a slower rate of growth than a function with complexity O(sqrt(n))
","C is not correct - We must consider both input sizes in multi-input algorithms
",
"Which statement regarding trees is irrelevant?
","A tree with a node which has a balancing factor of magnitude greater than 2, is invalid
","Red-Black and AVL trees are both types of binary search trees.
","A binary search tree must have 1 less than a power of 2 nodes to be valid.
","In the worst case, a tree's search is of complexity O(log n).
",,"If all the nodes are linked, as a linked list, then searching must be linear.Red-Black trees are not binary search trees.The other 2 responses do not specify that they are balanced tress, so balance factors are irrelvant to validity.The other 2 responses do not specify that they are balanced tress, so the number of nodes are irrelvant to validity.
",
"What traversal method should be used to print the elements of a binary search tree in ascending order?
","In-order traversal
","Post-order traversal
","Pre-order traversal
","Level order traversal
",,"In a binary search tree, for any given node, values in its left subtree must be less than the value of the node and values in the right subtree must have values greater than or equal the node (Week8a 2019, Slide 4).Therefore to print the values in order, we must use in order traversal (Week8a 2019, Slide 6)
",
"The time complexity to insert an element at the end of an array is O(1)Where 'n' is the length if the array
","Yes
","No
","planation: To add an element to the end of an array a new array of size n+1 needs to be allocatedThis new array needs to have n elements coppied to it from the original arrayLastly the new element is inserted into the last position of the new arrayThe time complexity is therefore O(n)
","gs: Complexity
",,,"cm2259 (cm2259)
"
"Where should the value ""8"" be inserted into the following binary tree? 9 / \ 3 11 / \ / \1 5 10 13 / \ / \ A B C D
","Position A
","Position B
","Position C
","Position D
",,"8 < 9, so it will be on the left sub-tree of the root. Then 8 > 3, so it will be on the right branch of that node. Finally 8 > 5 so it is the right child of 5.
",
"In a Doubly-Linked List, each time we want to insert or delete a new node we need to update three sets of references but in what order ?We do not want to store any pointer beforehand, nor lose any part of the linked list.
","1) Current node's next pointer2) New node's next and previous pointer3) Following node's previous pointer
","1)New node's next and previous pointer2) Following node's previous pointer3)Current node's next pointer
","1) Following node's previous pointer2) New node's next and previous pointer3) Current node's next pointer
","1) Following node's previous pointer2) Current node's next pointer3)New node's next and previous pointer
",,"""2019_TFLinkedlistsedit"" page 12My question aimed to keep in mind that if you change a pointer value to another, the address previously stored can be lost.
",
"Consider the functions f(n) = log(n), g(n) = 10*log(n), h(n) = 100*log2(n), y(n) = n. Which of the following statements is true?
","f =O(g), h =O(y)
","f =?(g), h =?(y)
","f = O(g), h = O(y)
","None of the above.
",,"Week2b - Powerpoint, slides 5 & 12.
",
"The following algorithm has time complexity O(f(n))int count = 0;for(int i = 0; i<n; i++){ for(int j = 0; j<(10*n); j++){ count++; } }for(int k = 0; k<n; k++){ count++; }return count;what is f(n)?
","10n2+n
","n2+n
","10n2+n+2
","n2
","n2+2
","n2 grows faster than n, so in big-O notation the time complexity 'n' from the second loop is overshadowed by the 'n^2' from the first loop, as is the complexity for initializing count and returning count. The scalar 10 is irrelevant by definition of big-O .
",
"Which of the following is the output of Pre-order traversal when applied to the tree:
","23, 24, 30, 33, 36, 37, 40, 52, 53, 57
","24, 23, 40, 33, 30, 36, 37, 53, 52, 57
","23, 30, 37, 36, 33, 52, 57, 53, 40, 24
","24, 23, 40, 33, 53, 30, 36, 52, 57, 37
",,"Depth First Traversals:(a) Inorder (Left, Root, Right) : 4 2 5 1 3(b) Preorder (Root, Left, Right) : 1 2 4 5 3(c) Postorder (Left, Right, Root) : 4 5 2 3 1
",
"In a complete binary tree, the number of nodes in a tree of depth n equals
","
","
","
","
",,"2019 Week7bslide 11
",
"Is the following tree an AVL Tree
","Yes
","No
","planation: NoAn AVL tree is a self-balancing binary search tree. The balance factor of each node is defined byand
","gs: Trees
",,,"fola (fo264)
"
"Below we see an unbalanced tree. 5 / \ 1 6 \ 4 / 3The tree is balanced with the Right Left case, what is the output if we traverse the newly balanced tree using in order traversal?
","5, 3, 1, 4, 6
","1, 3, 4, 5, 6
","1, 3, 5, 4, 6
","1, 4, 3, 6, 5
","6, 5, 4, 3, 1
","The balanced tree should look like this: 5 / \ 3 6 / \1 4So the order printed is 1, 3, 4, 5, 6Explanation for post order traversal is described on slide 22 Week7b-Trees1File 2019
",
"Let the time taken to execute a heap sort be T(n) (where n is the number of elements to be sorted).Which of the following is true?
","T is O(n2),Tis ?(2n), and T is O(2n)
","T is ?(n), T is O(n), and T isO(nlog(n))
","T is O(log(n)), T is O(n), and T is O(2n)
","T is O(1), T is ?(n), and T is O(n)
","None of the above
","T is?(n1.25) (approx)O is a lower bound for complexity, O an upper bound and? an exact boundHence:A is wrong asO(n2) is too high +?(2n) !=?(n1.25)B is wrong as?(n)!= ?(n1.25) +O(n) is too lowC is right as both theO are less than n1.25 and the O is above itD is wrong for the same reasons as BComplexity - 2019 Week2b Powerpoint [Slide 5]
",
"Which of these adaptations would not allow the longest path to be found using Djikstra's algorithm?
","Multiplying the weights by -1.
","Taking the maximum weight away from each of the weights.
","Taking each weight away from the maximum costs
","Reciprocating each weight.
",,"If a graph has an edge with negative or zero weight, this would cause issues.
",
"What tree traversal is generates the output: 75, 63, 83, 34, 65, 91, 23, 38, 90, 94 from the following tree:
","Post-order traversal
","Level-order traversal
","Post-order traversal
","In-order traversal
",,"Depth First Traversals:(a) Inorder (Left, Root, Right) : 4 2 5 1 3(b) Preorder (Root, Left, Right) : 1 2 4 5 3(c) Postorder (Left, Right, Root) : 4 5 2 3 1
",
"Which one of the following is NOT a cryptographic tool?
","Collision-Resistance
","Pre-image Resistance
","2nd Pre-image Resistance
","3rd Pre-image Resistance
",,"3rd Pre-image is not considered, and is irrelevant.
",
"Calculate the value of Dijkstra(A) from A to D
","7
","6
","5
","4
",,"Using Dijkstra's algorithm, the shortest possible route, the correct route is: A->B->C->D which takes 5 units.
",
"Which sorting algorithm best fits this description:StableBest case: (n2)Average case: (n2)Worst case: (n2)
","Quick Sort
","Pigeonhole Sort
","Bubble Sort
","gs: Sorting
",,,"fola (fo264)
"
"An algorithm of complexity ?(2^n) takes 2 seconds to run at n=4. How long will it take to run at n=10?
","5 seconds
","128 seconds
","256 seconds
","1024 seconds
","32 seconds
","(2^4)/2 = 8. (2^10)/8 = 128
",
"What is the worst case time complexity of a heap sort (2019 week 7a slide 5)
","O(n)
","O(n*log(n))
","O(n*log^2(n))
","O(n^2)
","O(n^2 * log(n))
","O(n*log(n)) Is the both the best and worst case time complexity of a heap sort
",
"Which statement is always true for a height-balanced binary tree?
","The difference of depth between any two leaves is 1 or 0.
","For each node, the number of inner nodes on the left sub-tree and the number of inner nodes on the right sub-tree only differ by 1 or 0.
","There will be k-1 leaves if the height of the tree is k.
","There will be k-1 or k leaves if the height of the tree is k.
",,"Having a height-balanced tree does not imply that it is weight balanced and so (B) is not always correct. C and D can be false or true depending on the tree so can be discarded.
",
"Whichisn'tan advantage of B-tree usage for databases?
","B-trees use a hierarchical index to minimise the number of reads.
","B-trees keep their index balanced with a recursive algorithm.
","Leaf and non-leaf nodes are the same size
","B-trees keep keys in sorted order, allowing for faster, sequential traversing.
",,"Leaf and non-leaf nodes are varying sizes, this complicates data storage within the database.
",
"What is the time complexity of the following function:int f(int n){ int count = 0; for(int i = 0; i<=n; i++){ for(int j = i; j>0; i++){ j/=2; count++; } } return count;}
","n
","nlogn
","2n
","n2
","logn
","Note that in the second for loop we increase i as well so i increases every execution.We need roughly n executions of the inner loop for i to reach n, then the loops stop.So overall time complexity of the function is n.
",
"Consider an Open Hash Table with 7 buckets and hash function h(x) = 3x % 7. What would the table look like after inserting the following elements: 8,3,15,22,9 in that order?
","null, null, 3->null, 8->null, 15->null, 22->null, 9->null
","null, null, 9->null, 24->45->66->null, null, null, 27->null
","null, null, 9->null, 24->null, 45->null, 66->null, 27->null
","null, null, 3->null, 8->15->22->null, null, null, 9->null
",,"The elements8,3,15,22,9 correspond to the outputs of the hash function 3,2,3,3,6 respectively. Meaning that 3 is inserted into bucket 2, 9 is inserted into bucket 6 and 8,15 and 22 are inserted into the linked list at bucket 3.Notes: Week10b - Hashtablesall slides 23-26.
",
"Below we see an unbalanced tree. 5 / \ 1 6 \ 4 / 3What is the correct case for balancing and what is the output if we traverse the tree using post order traversal?
","Right Left caseOutput of 1, 3, 4, 5, 6
","Left Left caseOutput of 1, 3, 4, 5, 6
","Right Left caseOutput of 1, 4, 3, 6, 5
","Left Right caseOutput of 5, 3, 1, 4, 6
","Left Right caseOutput of 2, 4, 3, 6, 5
","The balanced tree should look like this: 5 / \ 3 6 / \1 4This is done by doing a right rotation about the node '4': 5 / \ 1 6 \ 3 \ 4Then rotating about left about node '1' to get the balanced tree. Making it the case of Right Left.Explanation for post order traversal is described on slide 24 Week7b-Trees1File 2019
",
"If an algorithm of order O( sqrt(n) ) takes 4 seconds to run at n = 50, what is the expected time for n = 200?
","2 seconds
","4 seconds
","8 seconds
","16 seconds
","64 seconds
","for O( sqrt(n) ):increasing n by a factor of 4 increases time by a factor of 2
",
"Which array function has a worst case time complexity which is higher than its average case?Key:o = objecti = index
","get(i)
","add(o)
","insert(o, i)
","remove(i)
","find(o) for unsorted array
",,
"What information is updated when you insert a node into a singly linked list?
","The next pointer of the previous nodeThe previous pointer of the new nodeThe next pointer of the new node
","The next pointer of the previous nodeThe element of the previous nodeThe next pointer of the new node
","The next pointer of the previous nodeThe next pointer of the new node
","The next pointer of the previous nodeThe previous pointer of the new nodeThe next pointer of the new nodeThe previous pointer of the next node
",,"singly linked list nodes do not have previous pointers
",
"What is meant by a sorting algorithm being 'stable'?
","The sort always takes the same amount of time for the same amount of data
","The sort has time complexity of O(n)
","The sort takes the initial order of the data into account when sorting.
","The sort uses the minimum amount of swaps possible
",,"In a stable algorithm, the initial order of the data is taken into account and data of equal values are kept in the same order.
",
"The following tree is a balanced AVL binary tree. True or False? 98 / \ 12 101 / \ \ 9 31 102 / \3 10
","True
","False
","planation: The tree satisfies all requirements of a balanced AVL binary tree. See lecture slides 2019 Week8b - Trees3.
","gs: Trees
",,,"zn254 (zn254)
"
"Does this array represent a valid min heap?[3, 10, 6, 17, 43, 50, 8]
","Yes
","No
","planation: Week5b, slide 4
","gs: Sorting
",,,"rp696 (rp696)
"
"Consider a closed hash table where h(x) = x% 8 where the index is 0 through 7. When inserting the following data, which value occupies the place indexed 4?27, 145, 87, 45, 23, 56, 79, 135
","45
","27
","56
","145
","135
","Inserting each number in order gives that 23 takes slot 2, followed by 145 in slot 1. Using the remainder when these are divided by 8.Next 87 takes slot 7, 45 takes slot 5. Then 23 would also be in 7 so we traverse the list to the next space which we find at 2. 56 occupies 0, then 79 would also take 7 but we traverse putting it in place 4 so is the required term
",
"What is the result of using a breadth first traversal on this graph, printing every node visited?
","A, C, D, B, E
","E,D,B,C,A
","A,B,D,E,C
","A,B,C,D,E
","None of the above
","2019 Lecture 17- Graphs 1.
",
"Which of the following statements is true?
","Merge sort is always faster than insertion sort.
","Worst and average case time complexity for quick sort is n2.
","Best, average and worst case time complexity for selection sort is n2.
","Worst case time complexity for merge sort is n2.
",,"Insertion is faster that merge sort if the data is sorted.Only worst case of quick sort is n2 . The average is nlogn.Merge sort always has nlogn time complexity.
",
"A closed hash function h(x) = x%13 has slots 0 through to 12. When the elements (2, 55, 4, 26, 11, 14, 37, 30, 43, 40, 44, 6, 23) are inserted into the Hash table, in what slots are 43, 6 and 44 respectively?
","4th, 6th, 5th
","6th, 9th, 8th
","6th, 8th, 4th
","4th,5th,6th
","8th, 12th, 11th
","2%13 = 2. So 2 is in slot 2.55%13 = 3. So 55 is in slot 3.4%13 = 4. So 4 is in slot 4.26%13 = 2. So 26 is in slot 0.11%13 = 2. So 11 is in slot 11.14%13 = 1 .So 14 is in slot 1.37%13 = 11. Slot 11 is already filled. So 37 is in slot 12.30%13= 4. Slot 4 is already filled. So 30 is in slot 5.43%13= 4. Slot 4 is already filled, slot 5 is already filled. So 43 is in slot 6.40%13= 1. Slot 1 is filled. All of the subsequent slots are filled until slot 7. 40 is in slot 7.44%13= 5. Slot 5 is filled. Slots 6 and 7 are filled. So 44 is in slot 8.6%13= 6. Slot 6 is filled. All ofof the subsequent slots are filled until slot 9. 6 is in slot 9.23%13= 10. 23 is in slot 10.
",
"Which binary tree is correct for the sequences below?In-order : B, A, D, C, Epre-order : A, B, C, D, E
","A / \ B C / \D E
","A / \ B C / \ D E
","E / \ B C / \ D A
","A / \ B E / \ D C
","A / \ E C / \ F B
","In-order:a) DBEAC*b) BADCEc) BEDCAd) DBCAEe) EAFCBpre-ordera) ABDEC*b) ABCDEc) EBCDAd) ABDCEe) AECFB
",
"Which of the following sorting algorithms has the same best, average and worst time complexity (no matter what the data is)
","Bubble sort
","Quick sort
","Merge sort
","Insertion sort
",,"Bubble sort and Insertion sort:Average and worst case time complexity: n^2Best case time complexity: nMerge sort:Best, average and worst case time complexity: nlognQuick sort:Worst case time complexity: n^2Average and best case time complexity: nlogn
",
"This AVL Tree is unbalanced, which case is it in? 10 / \ / \ 5 15 / \ / \ 1 7 / / 6
","L - L
","L - R
","R - R
","R - L
",,"The root node is unbalanced to the left. The balance of the root nodes left child, is biased to the right.
",
"What is the result of ?(n2)+?(n)?
","?(n)
","?(n2)
","?(n2+n)
","?(n3)
",,"the bigger function dominates - Week2b, slide 6
",
"In an internal node of a 2-3 B-tree, the number of keys will indicate the separation of subtrees.For 3 child nodes of an internal node of this 2-3 B-Tree, 2 keys will be used, say X1 and X2.Which of the following statements, is correct?
","The far-left subtree's values will all be less than X2The far-right subtree's values will all be greater than X2
","The far-left subtree's values will all be less than X1The far-right subtree's values will all be less than X2
","The far-left subtree's values will all be greater than X1The far-right subtree's values will all be greater than X2
","The far-left subtree's values will all be greater than X2The far-right subtree's values will all be less than X2
",,"A 2-3 B Tree is a B tree with 2 or 3 children nodes for each internal node.An internal node with 3 child nodes in a B tree has 2 keys.Say these 3 child nodes are called tree 1, tree 2 and tree 3 going from left to right respectively.These keys, say X1 and X2 are created such that:All values in the tree 1 are less than X1.All values in the tree 2 are between X1 and X2.All values in the tree 3 are greater than X2.
",
"Which of the following is the correct post-order traversal of the binary tree shown below? 2 / \ 31 14 / \ / \12 7 25 16
","2, 31, 14, 12, 7, 25, 16
","12, 7, 31, 25, 16, 14, 2
","2, 31, 12, 7, 14, 25, 16
","12, 31, 7, 2, 25, 14, 16
","12, 7, 25, 16, 31, 14, 2
","A - Random generation of the numbersB - Post-order (left, right, root)C - Pre-order (root, left, right)D - In-order (left, root, right)E - Reading values from left to right, starting from the bottom row
",
"Suppose we store 50 elements in an Array List, a Singly Linked List and a Probabilistic Skip List. Which of the following statements is false?
","The Linked List is faster than the Array List at inserting an element at the 20th position in the list.
","The Skip List will have worst case O(n) when getting an element.
","The Linked List is faster than the Array List at getting the 30th element in the list.
","None of the above.
",,"A. Week3b Slide 16B. Week3b Slide 13C. Week3b Slide 13
",
"Consider the following statements about the following functions: , , and .Which one of the following statements is correct?
","is of order at most and is of order at most
","is of order at least and is of order at most
","is of order at most and is of order at most
","is of order exactly
","None of the above are correct
","a) is incorrect, as even though f is of order at most g, it is incorrect to say that f is of order at most k.b) is correct.c) is incorrect, as although h is of order at most f, it is incorrect to say that g is of order at most f.d) is incorrect, as for f to be of order exactly k, f needs to be of order at most k (which it does not satisfy).e) is incorrect.The hierarchy of growth rates can be found on slide 12 of the week 2b powerpoint under lectures on moodle.
",
"Which type of traversal is described by the following steps?1. process the nodes in the left subtree2. process the nodes in the right subtree3. process the current node
","pre-order traversal
","in-order traversal
","post-order traversal
","level order traversal
",,"Week7b - Trees1, slide 24
",
"Consider the following array[53, 165, 202, 129, 32, 85, 98, 177, 195, 71]A Shellsort algorithm is applied. In the first iteration of the array, a '5-sort' is performed.What is the order of the array after this first iteration?
","[53, 98, 71, 129, 32, 85, 165, 202, 195, 177]
","[53, 98, 177, 129, 32, 85, 165, 202, 195, 71]
","[32, 98, 177, 129, 53, 85, 165, 202, 195, 71]
","None of the above
",,"2019. Week5a-Powerpoint slide 4
",
"What is the average Big Theta time complexity for Quicksort?
","
","
","
","
","
","See 2019 lecture 4b slide 7.
",
"What is considered a maximum height of a perfectly balanced search tree?
","n
","n/2
","n2
","log(n)
","log(n2)
","The maximum height is log(n) for a perfectly balanced search tree.See lecture notes - Week8b - Trees3 (1) - Slide 3
",
"With a graph stored as an adjacency matrix, which of these would show you which vertices are exactly two edges apart?
","Multiplying the matrix by its inverse
","Multiplying the matrix by the identity matrix
","Multiplying the matrix by itself
","Multiplying the matrix by itself twice
",,"A - this will give you the identity matrixB - this will give you the same matrix as beforeC - this will give you the vertices that are exactly two edges apart (2019 lecture 17 slide 11)D - this will give you the vertices that are exactly three edges apart
",
"Consider the following algorithm with asymptotic time complexity O(f(n)).for (int i=0; i<20*n; i++) for(int j=0; j<n; j++) System.out.println(""A"");for (int i=1; i<n; i++) System.out.println(""B"");What is f(n)?
","
","
","
","
","None of the above.
","The correct answer is n^2 because the first double for-loop requires n^2 operations (despite the constant of 20 in the first for loop). The second for loop requires n operations. Hence the overall time complexity is n^2.Reference Week2b slide 6.
","fs489 (fs489)
"
"Consider the following algorithm with asymptotic time complexity O(f(n)).for (int i=0; i<20*n; i++) for(int j=0; j<n; j++) System.out.println(""A"");for (int i=1; i<n; i++) System.out.println(""B"");What is f(n)?
","
","
","
","
","None of the above.
","The correct answer is n^2 because the first double for-loop requires n^2 operations (despite the constant of 20 in the first for loop). The second for loop requires n operations. Hence the overall time complexity is n^2.Reference Week2b slide 6.
","fs489 (fs489)
"
"What characteristics of a binary tree would suggest that it is considered min-heap?
","The data in each node, call this node Xi, of the binary tree, is less than or equal to the data in Xi's children.The binary tree should also be considered complete.
","The data in each node, call this node Xi, of the binary tree, is less than or equal to the data in Xi's children.
","The data in each node, call this node Xi, of the binary tree, is less than the data in Xi's children.The binary tree should also be considered complete.
","The data in each node, call this node Xi, of the binary tree, is less than the data in Xi's children.
",,"A minimum-heap binary tree is a complete binary tree such that value at every node is less than or equal to the values at its children.See (CM20254 - Week 5(b) Sorting (2) slide 4) for an example diagram of a min-heap tree.
",
"What makes an XOR or memory-efficient doubly-linked list different from a standard doubly-linked list?
","Only some of the nodes contain 2 pointers reducing memory used.
","Each node has only one pointer using the bitwise exclusive or combination of the previous and next pointers for that node allowing forward and backward traversal.
","Each node uses a single pointer using bitwise OR operation of the previous and next node addresses.
","A stack is maintained for the previously visited nodes on a singly linked list allowing forward and backward traversal.
","None of the above.
","The memory efficient doubly linked list uses bitwise XOR (exclusive or) operation on the previous and next pointers to store both pointers as a single value. Traversal is accomplished by storing the previously visited node (unless on starting node when the previous value is 0) and XOR on this value with the current node pointer gives the next value. This same property of node1 XOR node2 = node3 can be reversed and therefore has the properties of a doubly linked list with reduced memory.
",
"Which of these Linked List operations has a best, average and worst case time complexity of O(1)?
","get(i)
","add(o)
","insert(o, i)
","remove(i)
",,"In order of Best, Worse, Average:get - 1, n, nadd - 1, 1, 1insert - 1, n, nremove - 1, n, nSee slide 10 of Linked List lecture
",
"Let , . What is the complexity in big O notation of ?
","
","
","
","
","
","Please see 2019 week 2b powerpoint slide 6.
",
"What is 16^71 mod 71?16^71 = x mod71.x=?
","16
","71
","15
","7
",,"By Fermat's little theorem:a^p= a mod pwhere a is any integer and p is any primethus 16^71= 16 mod 71
",
"Which of the following is the worst case time complexity of quick sort?
","
","
","
","
",,"The worst case occurs when there is a sublist returned by partitioning routine of n-1. This would happen if the smallest or largest element in the list becomes the pivot. This would lead to recursive calls on lists with sizes one less than the previous list. This would repeat n-1 times until a list of size 1 is reached. Hence, a worst case of O().
",
"Given the following tree, if we were to use post order traversal, what would the output be? Declan / \ Beth Finola / \ / \ Alex Corrie Emma Georgia
","Declan, Beth, Finola, Alex, Corrie, Emma, Georgia
","Declan, Beth, Alex, Corrie, Finola, Emma, Georgia
","Alex, Corrie, Emma, Georgia, Beth, Finola, Declan
","Alex, Beth, Corrie, Declan, Emma, Finola, Georgia
",,"A is given by level order traversalB is given by pre order traversalC is given by post order traversalD is given by in order traversal
",
"In a hash table, what is it called when 2 or more elements would be assigned to the same bucket given their hash function?
","Competition
","Crash
","Collision
","Clash
","smash
","The condition when 2 or more elements are assigned to the same bucket is called a Collision.
",
"An algorithm takes 3 seconds to run with an input n = 10 and it takes 81 seconds to run with an input n = 30. If we run the algorithm with an input of n = 100, how long is it most likely to take?
","30,000s
","300s
","3000s
","300,000s
","None of the above.
","It takes 10 seconds to run with an an input of n = 3. When we increase n by a factor of 3, the time is takes increases by a factor of n^3 ( = 3^3 = 81). Hence this algorithm has time complexity n^3.If we increase n by a factor of 10, then the time it takes should increase by a factor of 10^3 = 1000. Therefore the correct answer is 3 x 1000 = 3000. Answer C).Reference Week2b Powerpoint Slide 15.
",
"What fields are stored in the nodes of a doubly linked list?
","Two link fields and one data field - A pointer to the next node, a pointer to the previous node, and the element in the node.
","One link field and one data field - A pointer to the next node and the element in the node.
","One data field - The element in the node.
","Two link fields - A pointer to the next node and a pointer to the previous node.
","One link field - A pointer to the previous node.
","You can traverse a doubly linked list in both forwards and backwards directions ('next' and 'previous').
",
"Tom Nook wants to send a message to KK Slider using RSA encryption. What is the Public Key made of?p = a prime numberq = a prime numbern = pqe = a small exponent, where 1 < e < (p - 1)(q - 1)
","p, q
","e
","n, e
","pq
",,"The public key is made of n and e
",
"What is the best case time complexity of insertion sort?
","O(1)
","O(n^2)
","O(n^3)
","O(n)
",,"2019 Lecture 4a, slide 17
",
"What is/are the disadvantages of implementing Binary tree using normal arrays?
","difficulty in finding the parent of a node
","difficult to implement
","difficulty in knowing children nodes of a node
","None of the above
",,"read more on implementation of binary tree using arrays
",
"Which of the following has the most desirable runtime?i.e which will be the fastest runtime for large n?
","T(log(n))
","T(n log(n))
","T(n^3)
","T(n)
",,"Time complexity runtime goes as such (not exhaustive):1. Constant: 12. Logarithmic: log(n)3. Square root: sqrt(n)4. Linear: n5. n log(n)6. Quadratic: n^27. Cubic: n^38. Exponential: 2^n(Think about the graphs)
",
"Using selection sort and sorting from lowest to highest, what will the following list look like after 3 iterations?[50,35,79,63,24,90,101,143,256,3]
","[3,24,50,63,35,90,101,143,256,79]
","[3,24,35,63,79,90,101,143,256,50]
","[3,24,35,63,90,101,143,50,256]
","[50,24,79,63,35,90,101,143,256,3]
",,"Read on selection sort
",
"For an array list of size n what are the best, worst and average runtime complexities for each of it's operations?
","
","
","
","
","None of the above.
","The answer is A, see page 15 of the ""D&A-Revision2.pdf"" file on the moodle page.
",
"What is the runtime of a Binary Search Tree Search?
","Average ?(log n)Best?(1)Worst?(n)
","Average ?(n)Best ?(log n)Worst ?(n^2)
","Average ?(log n)Best ?(log n)Worst ?(n^2)
","Average ?(n)Best ?(1)Worst ?(log n)
","Average ?(n^2)Best ?(n)Worst ?(n^3)
","On average, a BST with N values, usually will be a fairly balanced tree. This will mean that with each node traversed, there will be 50% of the list eliminated. Making the average runtime?(log n). In the best case scenario, the first node considered will be the one which is being search for. And in the worst case, the BST will not be balanced, and the algorithm will have to search through all of the nodes before finding the specified one.
",
"Which, if any, of the Binary Trees labelled A-H is a complete binary tree?
","There are no complete binary trees
","All of them
","B, C, D, E and F
","B and C
","Only C
","A complete binary tree is a binary tree where:Every leaf node has the same depthEvery non-leaf node has exactly two childrenThe only binary trees that satisfy both of these conditions are B and C
",
"Which of the followingO(n logn)sorting algorithm is the slowest ?
","Insertion Sort
","Merge sort
","Heap Sort
","None of the above
",,"Read more on heap sort
",
"Processing the following tree in post-order gives which outcome?
","DFGBECA
","ABCDEFG
","BDGEFCA
","DFAGCBE
","DFGEBCA
","Post order traversal is discussed on lecture slides 24-25 of week7bIf you want a slightly hacky way to figure them out, I do it like this:
",
"Which node needs to be rotated in the following AVL tree to become balanced: 25 / \ 20 30 / \ \10 22 40 \ 50
","40
","50
","30
","20
","25
","Since the node with value '30' has an balance factor of -2, we know that this node is the one which requires the rotation.
",
"Kristoff has 9823598273 reindeer. The reindeer are stood in the worst configuration. He must order his reindeer before he and Sven can go on an adventure, which sort should he use to sort them in the least amount of time?
","Quicksort
","Merge sort
","Insertion sort
","Bubble Sort
","Selection sort
","Merge sort has a worst case time complexity ofO(n log(n)) while the others have a worst case time complexity ofO(n^2).
",
"Consider the array: 4, 1, 3, 2, 5.Using Bubble sort, how many passes through the array are required to sort it from lowest to highest?Note: not including a final pass to confirm correct order.
","1
","2
","3
","4
","5
","After the first pass, order will be 1, 3, 2, 4, 5After the second pass, order will be 1, 2, 3, 4, 5
",
"Consider an algorithm with the following time complexity for an input n:What is the asymptotic time complexity of this function?
","
","
","
","
","
","Let f(n) and g(n) be be real functions with f(n) > 0 and g(n) > 0 for n>0.Then f(n) = O(g(n)) if and only if the complexity of f(n) is equal to or less than the complexity of g(n). In other words, if and only if there exist constants c>0 and m>0 such that: |f(n)| <= c|g(n)| for all n>m.a) n is not an upper boundb) Correct answer: n! grows the fastest - faster than an exponential like 7^nc) Big-Omega denotes lower bounds; n^n is not a lower bound since it grows faster than n!See Week2b Powerpoint Slides 12-13 for reference.
",
"Ash decides to organise his Pokemon in a tree. Which tree traversal should he use such that Charizard is first in line and Caterpie is last? Bulbasaur / \ Pikachu Caterpie / \ Charizard Pidgeotto
","Inorder
","Postorder
","Preorder
","Level order
",,"Inorder : Charizard, squirtle, pidgeotto, bulbasaur, caterpiePostorder: Charizard, pidgeotto, pikachu, caterpie, bulbasaurPreorder: Bulbasaur, Pikachu, Charizard, Pidgeotto, CaterpieLevel order: Bulbasaur, Pikachu, Caterpie, Charizard, Pidgeotto
",
"What kind of algorithm is a Merge sort considered to be?
","Divide and Consider algorithm
","Derive and Calculate algorithm
","Divide and Conquer algorithm
","Deny and Conquer algorithm
",,"Apart from the correct answer, the others are not types of algorithms
",
"Does the array below represent a correct max heap?[1,7,13,16,21,28,35,33,29,26,20,14,3]
","Yes, it is a correct max heap array
","No, it is not a correct max heap array
","planation: This array is not a correct represention of a max heap.A max heap array starts with the largest element in the heap (the root).Given an element at index position i: Its children are at index positions 2i+1 and 2i+2 Its parent is at index position floor((i-1)/2)
","gs: Sorting, Trees
",,,"cs2318 (cs2318)
"
"In Hash Tables, a load factor of 0.45 means that your array has 45% more buckets than you need.True or False?
","True
","False
","planation: A load factor of 0.45 means a maximum of 45% of the total number of buckets will be filled, therefore at least55% will be unfilled. So there are 55% more buckets than you need.
","gs: Hashtables
",,,"jap66 (jap66)
"
"What tree traversal is used to output: 666, 8, 1, 96, 6000000from the following tree: 666 / \ 8 6000000 / \ 1 96
","Level Order
","Preorder
","Postorder
","Inorder
",,"level order would be: 666, 8, 6000000, 1, 96In order would be: 1, 8, 96, 666, 6000000postorder would be: 1, 96, 8, 6000000, 666
",
"What is stored in each node of a singly linked list?
","The element in the current node.
","A pointer to the previous node.
","A pointer to the next node, a pointer to the previous node, and the element in the node.
","A pointer to the next node and the element in the current node.
","A pointer to the next node and a pointer to the previous node.
","A singly linked list only travels in one direction, to the 'next' node. There are no pointers to a previous node in a singly linked list.
",
"For the graph with the following path lengths, which are traversable both ways:A<->B 2A<->C 3B<->C 6B<->E 4C<->D 8D<->E 2D<->F 1E<->F 4What is the length of the shortest path between Nodes A and F?
","10
","6
","9
","12
","8
","Either by using Dijkstra's or inspecting the graph by eye we can determine that the shortest path is ABEDF, which has a length of (2+4+2+1)=9
",
"Given the following integer binary search tree, three new elements 12, 8 and 5 are inserted in that order.For each new element which node is each of the new elements a child of?For example, ""4, 49, 2"" would mean that 12 is a child of 4, 8 is a child of 49 and 5 is a child of 2.
","6, 13, 6
","6, 13, 4
","6, 12, 6
","6, 12, 8
","None of the above.
","After first insertion 12 is the child of 6:After second insertion 8 is the child of 12:After third insertion 5 is a child of 6:So the answer is 6, 12, 6
",
"Which of the following about AVL trees is not true?
","This is not a balanced AVL tree:
","The average search complexity of an AVL tree is O(log n).
","It is possible to remove any item from an AVL tree.
","This is not a balanced AVL tree:
","The worst case insert complexity of an AVL tree is O(log n).
","A: True. The left subtree has height 4 while the right has height 2, therefore it is not balanced.B: True. The average complexity of searching, inserting and deleting is O(log n).C: True. It is possible to remove any item of an AVL tree.D: False. The heights of both subtrees of each nodes do not differ by more than 1, therefore it is balanced.E: True. The worst case complexity of searching, inserting and deleting is O(log n).
",
"Which of the following sorting algorithms has the fastest best case time complexity?
","Insertion Sort
","Merge Sort
","Selection Sort
","Shell Sort
","Quick Sort
","If the list is already sorted then time complexity for Insertion sort is only O(n) since algorithm only completes one full pass
",
"What is the reason for AVL Trees rebalancing after insertion/deletion of a node?
","Doesn't change anything
","To decreasse amount of nodes stored
","To keep the time complexity constant
","Allows for quicker tree traversal
",,"A balanced AVL tree will always have time complexity of log(n)If the tree didn't balance then after every comparision the number of nodes eliminated wouldn't necessarily be half
",
"If the post order traversal of a binart tree is DEBFCA. What is the pre order traversal?
","ABFCDE
","ADBFEC
","ABDECF
","ABDCEF
",,"Correct Answer: C
",
"What is the number of swaps needed to swap this list of numbers:8, 22, 7, 9, 31, 5, 13 in ascending order using bubble sort?
","11
","9
","13
","10
","15
","8, 22, 7, 9, 31, 5, 13First run: 8, 7, 9, 22, 5, 13, 31 = 4 swapsSecond run:7, 8, 9, 5, 13, 22, 31 = 3 swapsThird run:7, 8, 5, 9, 13, 22, 31 = 1 swapFourth run: 7, 5, 8, 9, 13, 22, 31 = 1Fifth run:5, 7, 8, 9, 13, 22, 31 = 1 swapTotal = 10 swaps to sort the list of numbers.
",
"Consider the algorithm forinsertioninto a singly-linked list. What is the time complexity for this operation?
","best(1), worst(n), average(n/2)
","best(log(n)), worst(n), average(log(n)/2)
","best(n/2), worst(n), average(n)
","best(1), worst(n), average(n)
",,"Best case is one; the new node is the head.Worst is n; it must go through all nodes before the new node is inserted.Average case is n; similar to the above, except it depends on the value of n and the current nodes in the list.
",
"What is the time complexity of the following algorithm?int m = 0;int i = n;while (i > 0) { m = m + 2i; i = i / 2;}
","O(n log n)
","O(n / 2)
","O(log n)
","O(n)
","None of the above
","Has this time complexity as the value of i is halved each time the while loop is cycled through.
",
"Which of these sorting algorithms is stable
","Selection Sort
","Merge Sort
","Shell Sort
","Quick Sort
","None of the above
","Selection Sort - 2019 Week4a [Slide 10] -https://stackoverflow.com/questions/4601057/why-is-selection-sort-not-stableShell Sort - 2019 Week5a Powerpoint [Slide 8] *Look at notes under slideQuick Sort - 2019D&A-Revision2 [Slide 24] -https://stackoverflow.com/questions/13498213/quicksort-algorithm-stability
",
"Which one of the following sorting algorithms is unstable(elements with same value will remain in the same order after sort)?
","Merge Sort
","Selection Sort
","Bubble Sort
","Insertion Sort
",,"Selection sort is unstable since it works by comparing elements that are not adjacent so an element could surpass another equally valued element
",
"What is the result of pre-order traversal of this tree?
","S U W V Y Z X T
","S T U V W Z Y X
","S T U V Z X Y W
","S T U V Z Y W X
","X Z Y V W T U S
","The algorithm for pre-order traversal is as follows:void preOrder(Node cur){if (cur == null) // if empty, return�return;System.out.print(cur.value + � �); // Process the current node.preOrder(cur.left); // Process nodes in left sub-tree.preOrder(cur.right); // Process nodes in left sub-tree.}
",
"When performing a BST search on N values, on average how many steps are required to find our value?
","?(N + 1)
","?(N3)
","?(log N)
","?(N)
","?(Nlog N)
","Lecture 14 � Trees 2, slide 11
",
"A certain quadratic time algorithm uses 50 elementary operations to process an input of size 20. What is the most likely number of elementary operations it will use if given an input of size 2000?
","50000
","500000
","5000000
","5000
","None of the above
","Because the algorithm is quadratic, if the input increases by x times, the number of operations should increase x2 times. In this case, if the input increases by factor of 100, the number of operations increases by a facot of 1002. Therefore, 50 operations x 1002 = 500000.
",
"Using selection sort and sorting from lowest to highest, what will the following list look like after 3 iterations?[ 900, 321, 400, 60, 702, 9, 572, 18, 104]
","[ 9, 18, 104, 400, 60, 702, 900, 572, 321]
","[ 9, 18, 60, 104, 321, 400, 572, 702, 900]
","[ 9, 18, 60, 400, 702, 900, 572, 321, 104]
","None of the above
",,"In selection sort you look at for the smallest number, and swap this with the first number, you then look at the remain n-1 numbers for the smallest and swap this with the second number.1st iteration: swap 9 and 900 [ 9, 321, 400, 60, 702, 900, 572, 18, 104]2nd iteration: swap 18 and 321[ 9, 18, 400, 60, 702, 900, 572, 321, 104]3rd iteration: swap 60 and 400[ 9, 18, 60, 400, 702, 900, 572, 321, 104]Reference: Lecture 4a PDF
",
"Consider a closed hash table with linear probing.Compute the average number of steps taken to insert an item into a hash table with total number of available buckets being 10,000 and the number of unused buckets being 1,500.
","Average no.of steps � 2
","Average no.of steps � 4
","Average no.of steps � 6
","Average no. of steps � 8
","Average no.of steps � 10
","Max no. of keys to insert = 1,500 - 10,000 = 8,500Load (L) = Max no. of keys to insert / Total buckets in array = 8,500 / 10,000 = 0.85Average no. of steps to insert item = 0.5 * (1 + 1/(1 - L)) = 0.5 * (1 + 1/(1 - 0.85)) = 3.83333.... � 4 steps
",
"A quadratic time algorithm uses 50 elementary operations to process aninput of size 10. What is the most likely number of elementary operations it will use if given an input of size 10,000?
","50,000
","500,000
","5,000,000
","50,000,000
","500,000,000
","The input increases from 10 to 10,000. Thisis now 1000 times the original input size.However, as the algorithm has a quadratic time complexity, this value has to be squared and then multiplied by 50 to get the the number of operations overall.This can be calculated using the formula:((New Input / Old Input) ^ 2) * (Number of Operations for Old Input)So in this case, it will be:((10,000 / 10) ^ 2) * 50 = 50,000,000 operations
",
"Consider graph F. Assume that we use Dijkstra's algorithm to find shortest paths from node START to any other node in F. Which of the following orderings on the nodes of F could be used by Dijkstra's algorithm to compute the shortest paths that start at START?
","START,1,2,3,4,END
","START,END,1,3,2,4
","START,3,2,4,END,1
","START,4,3,2,1,END
","None of the above
","From START, pick the node which is connected to START by lowest value edge. In this case its node 3. Then, looking at all possible edges from START and 3, pick the lowest one again, in this case node 2. Repeat this step again, to see that next node is 4. Following the same principle, the next node should be END, and finally, last node should be 1.
",
"If we have an open hash table with 10 keys inserted and 20 buckets, what is the average number of steps taken to find an element in the table?
","1
","1.25
","1.5
","0.75
","1.75
","Load factor is 10/20 = 1/2. Average numbers of steps to find an element in an open hash table is 1 + L/2 = 1 + 1/4 = 1.25.
",
"What is the worst case time complexity of inserting a node in a doubly linked list?
","O(nlogn)
","O(n)
","O(logn)
","O(1)
",,"The worst case is that you have to insert the node at the end of the list, therefore you have to traverse through the entire list to get to the position desired, making the time complexity O(n). However, if there was a tail reference, the time complexity would then be O(1).
",
"A main property of a Binary search tree is
","every node has 2 or more children
","all nodes in a node's left sub-tree must be less than the node�s value and all nodes in a node's right sub-tree must be greater than the node�s value
","all nodes in a node's left sub-tree must be greater than the node�s value and all nodes in a node's right sub-tree must be less than the node�s value
","Average runtime of BST search/ insertion is ?(N)
",,"A - is binary so every node has 2 children at mostB - correctC - the left sub-tree must be less than the node, the left sub-tree must begreater than the nodeD - the average runtime of BST search/ insertion is ?(log N)
",
"Honda uses the following binary search tree (sorted alphabetically) in order to store their car names: Amaze / \Accord Jazz / Grace / \ Brio InsightIn order to increase naming efficiency, they wish to convert this into an AVL tree, however do not want to re-insert all of the data.Therefore they choose to carry out 'rotations' to get a valid AVL tree.What is the minimun number of each rotation that must be carried out to produce a valid AVL tree?
","1 Right Rotate, 1 Left Rotate
","1 Left Rotate
","2 Left Rotates
","The tree is already a valid AVL tree
","A valid AVL tree cannot be made using this data
","1 Right rotation around Jazz gives: Amaze / \Accord Grace / \ Brio Jazz / Insight1 Left Rotation around Grace gives us: Grace / \ Amaze Jazz / \ /Accord Brio Insight
",
"Consider the list [420, 69, 80085, 21, 666, 1337].If you begin to sort the list so that it will be ordered from lowest to highest value using selection sort, what order will the elements be in after the first two swaps?
","[21, 69, 420, 666, 1337, 80085]
","[80085,1337, 420, 21, 666, 69]
","[21, 69, 80085, 420, 666, 1337]
","[21, 69, 420, 80085, 666, 1337]
","[420, 69, 80085, 21, 666, 1337]
","The list begins as[420, 69, 80085, 21, 666, 1337].The lowest value in the list is 21, so this will swap position with the first element in the list, 420, giving you the list[21, 69, 80085, 420, 666, 1337].The lowest value in the unsorted list is now 69, which is already in position so no swap needs to be performed.The lowest value in the unsorted list is now 420, so this will swap position with the first element in the unsorted list, 80085, giving you the list[21, 69, 420, 80085, 666, 1337].Although this list has not yet been fully sorted, this is how it looks after its first two swaps.
",
"Given a list of unordered, unbounded, integers, and the task of finding the smallest value present in the list, what method provides the lowest average time complexity to complete the task?
","Sort the list and binary search
","Sort the list in descending order and take the last element in the list
","Construct a BST then find the smallest element simply by traversing down the left subtree recursively
","Linear Search
","Ternary Search
","Note that the list contains unbounded integers. Hence an O(n) sort such as counting sort or bucket sort is impossible.A: O(nlogn) time due to sort (and no reason to binary search)B: O(nlogn) time due to sortC: O(nlogn) time to construct the BSTD: O(n) time hence the winnerE: No reason to ternary search
",
"What algorithm is considered a ""stable"" algorithm?
","It never breaks
","It skips over elements that are already sorted
","Always has the same number of comparisons for any list size n.
","Equal terms stay in their relative positions after sorting
","None of the above
","A stable algorithm is one in which two objects appear in the same order in sorted list as they appeared in the unsorted list. For example, Insertion, Merge and Bubble sorts are all stable, while Selection sort is not.
",
"What is the worst case performance for searching an element in a chained hash table?
","O(n^2)
","O(n/2)
","O(log n)
","O(n)
",,"Chained hash table performs the worst when all the elements hash into a single bucket, hence searching becomes O(n), where n is the number of elements in the table.
",
"Imagine a scenario where we need to sort 10,000 structures containing some information. Which sorting algorithm would be the best in this case?
","Quick Sort
","Radix Sort
","Bubble Sort
","Tournament Sort
",,"Quick Sort is the best general case sorting algorithm and is good for medium to large sets of data.
",
"Consider the following graph and it's adjacency matrix M:When an adjacency matrix is multiplied by itself (i.e. M * M = ?) what does the resultant matrix represent?
","The resulting matrix shows the distance between each vertex in the graph.
","The resulting matrix shows which vertices are two edges from each other.
","The resulting matrix is a transposed triangular matrix of the graph's nodes.
","The resulting matrix has no significance to the graph.
","The resulting matrix shows unreachable vertices from other vertices.
","When adjacency matrices are multiplied by themselves they produce a matrix showing which vertices are two edges apart.If this resulting matrix is multiplied by itself then we get all vertices that are three vertices apart and so on.Taken from DA Lecture 17 Graphs 1.
",
"Which of the following statements about AVL trees and binary trees is true?
","The cost of searching a binary search tree is O(log n ) but that of an AVL tree is ?(n)
","The cost of searching an AVL tree is ?(log n) but that of a complete binary tree is ?(n log n)
","The cost of searching an AVL tree is ?(log n) but that of a binary search tree is O(n)
","The cost of searching an AVL tree is ?(n log n) but that of a binary search tree is O(n)
",,"An AVL tree�s time complexity of searching, insertion and deletion is O(logn), but a binary search tree (BST) may be a skewed tree, so in the worst case a BST's searching, insertion and deletion complexity is O(n)
",
"Suppose we have two algorithms A and B.What does it mean if we say that A is asymptotically more efficient than B?
","A will always be better choice for small inputs
","A will always be better choice for large inputs
","B will always be better choice for small inputs
","A will always be better choice for all inputs
",,"In asymptotic analysisthe growth of an algorithm is considered in terms of input size. An algorithm A is said to be asymptotically better than B if A takes a smaller amount of time than B for all input sizes n larger than a value n0 where n0 > 0
",
"Assuming that the runtime complexity of inserting a member in a set ADT is O(n) and removing a member is also O(n) (Set is based on linked list data structure).A multiset is a set that allows members to occur more than once. What would the runtime complexities of inserting and removing members in a multiset be, based on the set implementation defined above?
","Insertion Complexity: O(n)Removal Complexity: O(n)
","Insertion Complexity: O(1)Removal Complexity: O(n)
","Insertion Complexity: O(n)Removal Complexity: O(1)
","Insertion Complexity: O(1)Removal Complexity: O(1)
",,"A multiset is a type of set that allows members to occur more than once. In a multiset inserting members is more efficient because we do not have to traverse the members looking for duplicates, hence insertion becomes an O(1) operation. Removing a member remains an O(n) process because we have to search for the member of the set to be removed.
",
"The following is a linked list:AvocadoCorianderTomatoLimeChiliit is sorted into alphabetical order for the first letter :AvocadoCorianderChiliLimeTomatoWhat can be said about the sorting algorithm?
","It is an unstable algorithm.
","It can be an Insertion Sort algorithm.
","It has a runtime complexity of exactly order n^1.25.
","It can be a Heap Sort algorithm.
",,"A.The algorithm is stable since Coriander stays in the same position.B. It could be an insertion sort since these are stable and can be used on linked lists.C. This is true of Shell Sorts. These are unstable.D. Heap Sorts are unstable and cannot be used on linked lists.
",
"Given a graph in adjacency list form, using what combination of data structure and algorithm can we efficiently find the shortest distance between two nodes.
","AVL Tree and Depth First Search
","Boolean Array and Depth First Search
","Boolean Array and Dijkstra's Algorithm
","Min Heap and Dijkstra's Algorithm
","Priority Queue and Binary Search
","An efficient O(ElogV) time implementation of Dijkstra's pathfinding algorithm will use a min heap to store all nodes currently in the queue to be processed, and break upon reaching the destination node.
",
"In shellsort, an array is sequentially h-sorted for decreasing values of h, with the final sort always using an h value of 1 (eg an array could be sorted for h values of 8,4,2,1).What sorting algorithm does shellsort use when h = 1?
","Selection Sort
","Insertion Sort
","Bubble Sort
","Bucket Sort
",,"Bubble sort is used to h-sort the array when h = 1. In fact, the algorithm used to h-sort the array for every value of h in shell sort is a modified form of bubble sort.
",
"Classify this sorting algorithmIt has the following qualities:StableCan be used to sort linked listsRequires n slots of extra memory
","Insertion sort
","Shell sort
","Quick sort
","Merge sort
",,"SeeD&A-Revision2.pptx slide 24
",
"Which of these sorting algorithms is unstable?
","Insertion sort
","Quick sort
","Merge sort
","Bubble sort
","None of the above
","A stable sorting algorithm is one in which equal items retain their relative position after sorting.However, in quick sort this is not guaranteed.For example, if sorting an array [7, 5, 5], the '5's will not stay in their initial order.
",
"Calculate x for:
","10
","6
","4
","2
","8
","Application of Fermat's little theorem.Week 11b slide 12
",
"Calculate the average number of steps taken to find/insert an item into this closed hash table:Number of keys= 3500 Number of Buckets=15750
","1.04
","1.11
","1.42
","1.48
","2.01
","Load = (Max number of keys to insert) / (Total number buckets in array)Average number of steps for a closed hash: Week10b slide 31
",
"Take this Balanced BST as a basis.Insert 30 and 31 in this BST, don't forget to balance it after each insertion if necessary.We print the tree in an In-order traversal way, what is the outcome ?
","27,12,9,10,16,36,31,30,35,40
","9,10,12,16,27,30,31,35,36,42
","9,10,12,16,27,36,30,31,35,42
","10,9,16,12,27,30,31,35,36,42
",,"After adding 30 and balancing it :After adding 31 and balancing it :You can find the explanation of the in-order traversal in the slideshow ""2019 - Weeb7b-Trees1""
",
"In a singly linked list without a tail reference, what is the time complexity of adding an element to the end of the list?
","T(1)
","T(n)
","T(n^2)
","T(n^3)
","T(log(n))
","With a tail reference the time complexity could beT(1) but without a tail reference it has to check all n elements thusT(n).
",
"In an Open Hash Table, what type of data structure does each array bucket point to?
","Skip List
","Linked List
","Binary Search Tree
","ArrayList
","AVL Tree
","Week 10b � Hashtables 1, slide 23
",
"What is the time complexity of Dijkstra's Algorithm? (v is the number of vertices, e is the number of edges)
","?(ev)
","?(v!)
","?(v)
","?(v2)
","?(e2)
","from Lecture 18 � Graphs 2, slide 21
",
"A skip list consists of 64 items. How many lanes are present? (Answer should include lane 0)
","4
","5
","6
","7
",,"The number of lanes in a list with n items is log(n). Hence log(64)=6 hence there are lanes 0,1,2,3,4,5. This information was used in Coursework 2
",
"What is 2^35 mod 7?
","4
","5
","2
","1
","3
","By Fermat�s Little Theorem, 2^6 = 1 mod 7. Thus, 2^35 = 2^5 = 32 = 4 mod 7.
",
"Which of the following protocols are now deprecated?
","TLS (Transport Layer Security)
","SSL (Secure Sockets Layer)
","HTTPS (HyperText Transfer Protocol Secure)
","SSH (Secure SHell)
",,"2019 TLS Overview Slides, Slide 1
",
"A developer is working on a software that stores emails and the associated username which is a 6 digit number. The software has to be able to find the email associated with a given username quickly. Which data structure is most appropriate to store these?
","Closed hashtable
","Linked list
","Open Hashtable
","Sorted array
",,"Open hashtables store elements with two properties, data and a key indentifying this ie what we require. When you want to find a particular entry you know the key for, you can them find the associated data.2019 lec 10b for more info
",
"Compute the value of x:5^25=x mod(13)
","x=1
","x=5
","x=12
","x=11
",,"Application of Fermat's little theorem: 5^12=1 mod(13) hence 5^25=((5^12)^2)*5 = ((1)^2)*5 mod(13) = 1 mod(13)
",
"Consider the following functions:f(n) = 5n^2 , g(n) = 10n^2 and h(n) = 10^nSelect the true statement below:
","g is O(f), h is O(g), and f is ?(h)
","g is O(f), g is O(h), and f is O(h)
","g is ?(f), h is O(g), and f is O(h)
","f is O(g), g is ?(h), and f is O(h)
","None of the above
","g and f are both of order n^2 so have similar time complexity. h is of highest order because (a^n) grows faster than (n^a) for all a being constants. thus g describes the lower bound of h and h describes the upper bound of f.
",
"Use a standard closed hashtable with linear probing and the hash function has the form h(x) = x % 6 with slots 0, ... , 5. If you insert the elements 28, 43, 12, 7, 37,13 in that order, what does the hashtable look like at the end?
","12, 43, 7, 37, 28, 13
","7, 12, 37, 28, 43, 13
","12, 13, 7, 28, 43, 37
","37, 43, 13, 7 ,28, 12
",,"First start with 28, 28 % 6 is 4 so gets inserted in slot 4---28--Then next is 43%5 which is 1-43-28--Then we use 12%5 which is 012, 43, -,-, 28 ,-Then 7%5 which is 1 but 1 is full so it goes in position 2 the next empty spot12, 43, 7,-, 28 ,-Then 37%5 is 1 so we move to the ext empty spot in position 312,43,7,37,28,-Giving the full list12, 43, 7, 37, 28, 13
",
"Which of the following is valid advice when hashing passwords.
","Make your hash function as fast as possible.
","Ensure all password hashes are not stored on a solid state drive.
","Salt your hash by hashing the username and the password together.
","Use the hash function MD5.
","You don't need to hash your passwords.
","A - Hashes for passwords should actually be slow rather than fast so that dictionary or brute force attacks are slowed down.B - The physical storage device should have no impact on your hash functionC - Actual valid advice to increase resistance to dictionary attacksD - Hash function MD5 has been thoroughly brokenE - Never store your passwords in plain text
",
"What is the average time complexity for searching in a Skip List?
","T(n log(n))
","T(n)
","T(1)
","T(log(n))
","T(n2)
","Powerpoint - Week3b Slide 16
",
"A closed Hash-table with linear probing uses the function h(x) = x % 5 as a hash function and has slots 0,1,2,3,4.When the elements, (13, 4, 19, 5, 27), are inserted into the Hash-table in order, what is the resulting Hash-table?
","19, 5, 27, 13, 4
","4, 5, 13, 19, 27
","5, 27, 13, 4, 19
","27, 19, 5, 4, 13
","19, 5, 13, 27, 4
","Insert 13:13 % 5 = 3 0 1 2 3 4|__|__|__|13|__|Insert 4:4 % 5 = 4 0 1 2 3 4|__|__|__|13| 4|Insert 19:19 % 5 = 4 0 1 2 3 4|19|__|__|13| 4|Insert 5:5 % 5 = 0 0 1 2 3 4|19| 5|__|13| 4|Insert 27:27 % 5 = 2 0 1 2 3 4|19| 5|27|13| 4|
",
"What is the shortest path from u to z?
","10
","7
","5
","3
","2
","Using Dijkstra�s Algorithm (2019 Lecture 18) the shortest path is length 3 through the path u -> x -> y -> z
",
"Say you need to create a Closed Hash Table that can store up to 5000 items and can find an item in roughly 2 steps.How many buckets do you need ?
","You will need 8500 buckets.
","You will need 8000 buckets.
","You will need 7000 buckets.
","You will need 7500 buckets.
",,"It is the same principle that the slideshow ""2019 -Week10b-HashtablesAll"" n�34 but with the formula of the expected number of steps for a Closed Hash Table.You will find a load factor of 2/3.
",
"Which sorting algorithm best fits this description:StableBest case : (n log n)Average case: (n log n)Worst case: (n log n)
","Shell sort
","Selection sort
","Quick sort
","Merge sort
","Heap sort
","Quick, Merge, and Heap all match the complexities, however merge sort is the only one of them that is stable
",
"What is the runtime complexity for this code?for (int i=1; i<n; i++) System.out.println(�test�);int y = n;for (int j=1; j<n; j++) for (int k=1; k<y; k++) System.out.println(�test2�); y = y/2; for(int x = 10; x > 0, x = x-1) System.out.println(""test3"");
","(n2)
","(n3)
","(n log n)
","(1)
","None of the above
","int y = n;for (int j=1; j<n; j++) for (int k=1; k<y; k++) System.out.println(�test2�); y = y/2;Is the code that we care about as it has the highest order of n complexityThe first loop has complexity n, the second has log(n) as y (same value as n) is halved each time, so each loop there are half as many iterations.
",
"Which of the following statement is FALSE.
","For the same load factor, an open Hash Table is almost always faster than a closed Hash Table.
","One of the principles behind open Hash Table is the use of a linked list to extend each bucket, thus limiting collisions.
","It is faster to search in a nearly full Closed Hash Table than an empty one.
","Open Hash Table are preferable to handle collision.
",,"You can find all the information in ""2019- Week10b-HashtablesAll"".A) p33B) p24C) p28-29D) p23
",
"Which of the following statements about sorting algorithms is false?
","The merge sort is on average quicker than the insertion sort, but if the data is already very nearly sorted, the insertion sort can be faster.
","The bubble sort has the same average, best-case, and worst-case complexities as the insertion sort.
","The merge sort requires buffer space of complexity n, but the insertion sort and the bubble sort do not require buffer space (beyond O(1)).
","The merge sort, insertion sort, bubble sort, and quick sort are all stable sorting algorithms.
","The insertion sort can be considered as a special case of the shell sort.
","A is true because merge sort always has complexity n*log(n), while insertion sort has average (and worst-case) complexity of n^2 but best-case complexity of just n.B is true because both bubble sort and insertion sort have average (and worst-case) complexity of n^2 and best-case complexity of n.C is true as the merge sort effectively requires a second array of n data to use as a buffer.D is false because the quick sort algorithm is unstable (it does not maintain the order of equal valued elements).E is true because the insertion sort is effectively the shell sort with h=1.
",
"What is a hybrid sorting algorithm?
","An algorithm that combines multiple sorting algorithms.
","An algorithm that has a constant time complexity.
","An algorithm that combines at least one stable sorting algorithm and at least one unstable sorting algorithm.
","There is no such thing as a hybrid sorting algorithm.
",,"This was part of coursework 3.
",
"What is the difference between a singly linked list and a doubly linked list?
","In a singly linked list, a node is linked to one other random node whereas in a doubly linked list a node is linked to two other random nodes.
","It is quicker to search a singly linked list than a doubly linked list.
","A singly linked list can't easily be searched backwards, a doubly linked list can be.
","A doubly linked list is always better than a singly linked list.
",,"In a doubly linked list, each node contains a link to the previous node and it is therefor possible to search through the list backwards.However in a singly linked list, only the link to the next node is stored.
",
"The following list is being sorted by first letter only:hondahalloumibeeThe sorting algorithm produces the following output:beehalloumihondaWhat property is guaranteed to be true about the sorting algorithm used?
","The algorithm used had time complexity O(n)
","The algorithm used was unstable
","The algorithm used n comparisons
","The algorithm used was stable
","The algorithm used had time complexity O(nlogn)
","As we are only sorting by first letters as stated, honda and halloumi are considered equal. In the output, honda and halloumi have switched positions as halloumi is now above honda. This means the sort used is unstable, as in a stable sort items of equal value retain their relative position after sorting (2019 Week4a-post slide 10), i.e. honda would've stayed above halloumi as this is the order they were in the input.
",
"Below shows a binary search tree where V represents the values of each node in the tree. If the values had been inserted in the order 11, 4, 16, 2, 14, 19, 9, 3, 17, 12, 1, 15, 27, 10, 7 what would the value of X (in diagram) be? V V V V V V VV V V V X V V V
","11
","13
","15
","12
","10
","If the next input value in the list is greater than the value of the node you're currently visiting, travel right, otherwise, travel left. Continue until you reach the end of a branch.The tree would look like the following: 11 4 16 2 9 14 191 3 7 10 12 15 17 27
",
"With relation to graphs, what isdepth-first traversal?
","Move forward until you hit either a dead-end or previously visited vertex. At which point, backtrack and traverse along another path.
","Traverse along the left-most edges until all have been visited. Then backtrack and traverse right edges.
","Traverse the graph in growing concentric circles, exploring the different ""levels"" one at a time.
","Visit vertices randomly until all have been visited.
",,"A is depth-first traversal.B is a made-up, nonsense traversal method.C is breadth-first traversal.D is just randomness.
",
"Consider the following binary tree 17 / \ 14 43 / \ / \ 7 16 34 68 / \ 1 3By which traversal/traversals will the node 14 be printed out the latest?
","Pre-Order
","In-Order
","Post-Order
","Pre-Order and Post-Order
","In-Order and Post-Order
","Pre-Order: 17, 14 ... => 2nd element printedIn-Order: 1, 7, 3, 14 ... => 4th element printedPost-Order 1, 3, 7,16, 14 ... => 5th element printed
",
"One of the approaches to dealing with collisions in a hash table is known aslinear probing. How does this work?
","If a collision occurs, the data we were trying to insert is placed in a special section at the end of the hash table reserved for collided data.
","A linked list is placed in the slot where the collision occurred, allowing multiple values to be stored there.
","It uses a second, different hash function to re-calculate the the position in which the data should be placed.
","It scans down the hash table until a free, unoccupied slot is found and stores the value there.
",,"When linear probing is used, the algorithm scans down the table until a free slot is found. The data is then placed there. If it probes off of the end of the hash table, it simply loops back around to the beginning of the hash table and continues looking for a free spot.When searching for a piece of data that has been inserted via linear probing, we use the hash function to compute a target slot. The algorithm then linear probes down the list until it either finds the data or hits an empty slot. If it hits an empty slot, that means the data you're looking for isn't in the hash table at all. (or your linear probing algorithm is broken)
",
"In order to prove function f(n) is ?(g(n)), which of the following conditions must be satisfied?
","where c1, c2 > 0 and for all n>n0 for some n0 > 0
","where c1 , c2 > 0 and for all n>n0 for some n0 > 0
","where c1 > 0 and for all n>n0 for some n0 > 0
","where c1 > 0 and for all n>n0 for some n0 > 0
",,"2019 Week2b Slide 15,2019 DSA Proofs Tutorial 'Introduction to Compelxity Proofs' slide 14
",
"Given the tree: 5 / \ 3 10 / \ / \ 2 4 7 11 / / \ \ 1 6 9 12Apply the following operations in the given order:1.Remove 5;2.Re-balance, so that each node has balance factor in {-1,0,1}3.Apply post-traversalWhich output is correct?
","1,3,2,6,9,7,12,11,10,4
","4,3,10,2,7,11,1,6,9,12
","1,3,2,4,9,7,12,11,10,6
","4,2,1,3,10,7,6,9,11,12
",,"By deleting 5 can replace it by either rightmost in left sub-tree or leftmost in right sub-tree.The first case is done here:Tree becomes: 4 / \ 3 10 / / \ 2 7 11 / / \ \1 6 9 12Then re-balance left-subtree(3 has bal.factor= -2) 4 / \ 2 10 / \ / \ 1 3 7 11 / \ \ 6 9 12Now apply post-order traversal i.e. 1)left 2)right 3)current
",
"If the following binary tree was to be traversed in apre-ordermanner, in which order would the letters be read?
","C B D A E F
","C D B F E A
","A B C D E F
","A B E C D F
",,"A pre-order traversal reads nodes in the following order:1. Current node2. Left sub-tree3. Right sub-treeSo here, we first read the root, then move to the left and read that. Then move to the left and read that, and continue until we reach the bottom of the left-most sub-tree. Then we can traverse back up the way we came, reading out the right sub-trees of the nodes. Then once we reach back to the root node, repeat this same process but traversing down the root's right sub-tree.A is in-order traversal.B is post-order traversal.C is pre-order traversal (the correct answer to the this question).D is level order traversal.
",
"An open hash table is:
","Identical to a closed hash table but you can resize it
","A long linked list
","An array of linked lists
","A certain kind of skip list
",,"An open hash table is an array of linked lists. Each list holds items that all hash to the same value.
",
"After applying pre-order traversal on the following tree: 50 / \ 25 63 / \ / 8 31 5 / \ / / 3 10 20 1What will be the output?
","3,8,10,25,20,31,50,1,5,63
","50,25,8,3,10,31,20,63,5,1
","50,25,63,8,31,5,3,10,20,1
","3,8,10,1,5,63,50,25,31,20
",,"Apply pre-order i.e., 1) current 2)left 3)right
",
"What will be produced after applying 3-sorting followed by 2-sorting on the array10,8,50,6,3,0,2,15?
","0,2,6,3,8,15,10,50
","3,50,0,2,15,6,8,10
","0,3,8,2,6,10,15,50
","6,3,0,2,8,50,10,15
",,"First apply 3-sorting to get:10,8,50,6,3,0,2,15->6,8,50,10,3,0,2,15->6,3,50,10,8,0,2,15->6,3,0,10,8,50,2,15->6,3,0,2,8,50,10,15Now apply 2-sorting over the right-most on the upper row:6,3,0,2,8,50,10,15->0,3,6,2,8,50,10,15->0,2,6,3,8,15,10,50
",
"Alice receives a message, m, from Bob using the usual RSA encryption method (N and t public, s secret). She signs it by computing h(m) and then sending c = h(m)s(mod N) to Bob. How does Bob verify that Alice signed m?
","He computes h(c) and checks that m = h(c)t (mod N)
","He computes h(c) and checks that h(c) = mt (mod N)
","He computes h(m) and checks that h(m) = ct (mod N)
","He computes h(m) and checks that c = h(m)t (mod N)
",,"2019 week 11(b) slide 13
",
"I have a standard closed hash table with linear probing, with the function h(x) = x % 7. I wish to put the following elements: 10, 3, 11, 20, 21, 22, 8 (in that exact order). What does the table look like afterwards?
","21, 22, 8, 10, 3, 11, 20
","21, 22, 10, 8, 11, 3, 20
","20, 8, 22, 10, 3, 11, 21
","3, 8, 10, 11, 20, 21, 22
","None of the above
","10 % 7 = 3, so goes in 3_, _, _, 10, _, _, _3 % 7 = 3, but 10 is in 3, so goes in 4_, _, _, 10, 3, _, _11 % 7 = 4, but 3 is in 4, so goes in 5_, _, _, 10, 3, 11, _20 % 7 = 6_, _, _, 10, 3, 11, 2021 % 7 = 021, _, _, 10, 3, 11, 2022 % 7 = 121, 22, _, 10, 3, 11, 208 % 7 = 1, but 22 is in 1 so goes in 221, 22, 8, 10, 3, 11, 20Therefore, it is A
",
"For the below BST, what is the result of performing a postorder traversal on the tree?
","1 4 2 5 7 6
","1 2 4 5 6 7
","1 4 2 6 7 5
","5 2 1 4 7 6
",,"In postorder traversal, the tree is traversed in the following way:1. The left subtree is traversed.2. The right subtree is traversed.3. The root is visited.In this case, we consider first the left subtree, which has as root 2, and as leaves 1 and 4.We then consider the left subtree of this, which consists only of the node 1, so this is recorded. Current result: 1We then consider the right subtree, which consists only of the node 4, so this is recorded. Current result: 1 4We then return to the root of the subtree, which is 2, and record this. Current result: 1 4 2Next we examine the right subtree, which has as root 7, and as leaf 6.We consider the left subtree of this, which consists only of the node 6, so this is recorded. Current result: 1 4 2 6As there is no right subtree, we consider next the root, which is 7, and record this. Current result: 1 4 2 6 7Finally, we return to the root of the overall tree, which is 5, and record this. Final result: 1 4 2 6 7 5
",
"Which Asymptotic Complexity has the highest growth rate:
","n
","log^2(n)
","n log(n)
","sqrt(n)
","log(n)
","Comparing against n, it is intuitive that log(n), log^2(n) and sqrt(n) have smaller growth rate than n; and it also stands to reason that nlog(n) has a higher growth rate than n as log(n)>1 for all values of n greater than the base of the log.
",
"A large company is looking to store their employee ID numbers in an open hash table. They currently have 20,000 employees, however they would like to future proof their system and design their system for a capacity of 30,000. They would like to perform operations on certain IDs with an average number of steps at 4. How many buckets would their hash table require to fit these specifications?
","3334
","5000
","10000
","6667
","8000
","Week10b-Slide30Use the average step formula for open hash tables to find the load value ( steps = 1 + L / 2 which gives L = 6 ).Then use the load formula to find the number of buckets ( buckets = values / load giving the answer buckets = 5000).
",
"A binary tree has six levels, and all are full exceptfor the last level, which is only half full. How manynodes does it have?
","23
","64
","47
","127
","51
","Since it is a complete binary tree (ie. ""one in which every leaf node has same depth and every non leaf has exactly two children"")Level 1: 1 nodeLevel 2: 2 nodesLevel 3: 4 nodesLevel 4: 8 nodesLevel 5: 16 nodesLevel 6: 16 nodes (since half full)1+2+4+8+16+16 = 47
",
"You are a Postman and have been tasked with finding the shortest path to house D.You begin your route at the Post office (A).You have been given the following information:Distances between nodes are:A->D=6A->B=10A->C = 4C->D=1C->B=9D->B=3
","4
","5
","10
","15
",,"From A directly we can reach A=0,B=10,C=4,D=6Settle A and go to the closest vertex to A, which is C so settle C as there is no faster way of reaching C.Now can we get to any nodes faster by going through C? Yes D as can get to by 4+1. Therefore update D. There is no faster way of getting to D so settle D. Therefore we can get to D in 5.
",
"What is the output of an Post-Order Traversal of the following tree
","21, 28, 32, 38, 39, 42, 54, 59, 99
","42, 38, 28, 21, 32, 39, 59, 54, 99
","21, 32, 28, 39, 38, 54, 99, 59, 42
","42, 38, 59, 28, 39, 54, 99, 21, 32
",,"A: In-Order TraversalB: Pre-Order TraversalC: Post-Order Traversal (answer)D: Level-OrderIt helps me to look at the diagram on this Wikipedia article:https://en.wikipedia.org/wiki/Tree_traversal
",
"Where O represents big O notation , using Big O rules from week2)b):What is f(n)*h(n)=O(?) ?Where:c= constantf(n) = O(c*m(n))h(n) = q(n)+p(n)q(n)=O(t(n))t(n)=O(p(n))
","f(n)*h(n)= O(c*m(n)*t(n))
","f(n)*h(n)= O(p(n))
","f(n)*h(n)= O(m(n)*p(n))
","None of the above
",,"1) f(n) = O(m(n)) as by ""Scaling"" constant factors have no effect.2)By ""Transitivity"" O(q(n))<=O(p(n)) : q is bound above by t, which is bound above by p , therefore q is bound above by p3) By ""Sums"" h(n)=O(p(n)) as from 2) we see that p(n) is larger and the bigger sum dominates4) By ""Products"" we see that O(f(n)*h(n)) = O(m(n)*p(n))See week2)lec b) for the rules
",
"Which of the following sorting algorithms has the largest best time complexity, i.e. the largest O(n) in the best case:
","Quick Sort
","Selection Sort
","Bubble Sort
","Insertion Sort
","Merge Sort
","Quick Sort: O(n log(n))Merge Sort: O(n log(n))Bubble Sort: O(n)Insertion Sort: O(n)Selection Sort: O(n2)Thus, Selection sort has the largest time complexity with O(n2)
",
"You are working for a car manufacturing company (Honda) and you have a list of 10,000 car registration numbers.The admins who inputted this data into a list did not store the data alphabetically, but you want to sort them.Which sorting algorithm would be the quickest to use given the data is currently randomly sorted?
","Bubble sort
","Quick sort
","Selection sort
","Insertion sort
",,"Complexities averageBubble sort: n2= 100,000,000Quick sort: nlog(n) = 40,000Selection sort:n2 = 100,000,000Insertion sort: n2 = 100,000,000More information in Week 5a and 5b lecture slides 2019.
",
"What is ""time resolution""?
","How close together multiple timings are to one another
","The smallest unit of time that can be measured by the timer
","How close a timing is to the true value
","None of the above
",,"The correct answer is B. Lecture 1)b).A) is Time precisionC) Is Time accuracy
",
"Which of these sorting algorithms would be most appropriate for data which is nearly fully sorted?
","Merge sort
","Quicksort
","Bubble Sort
","Binary Tree Sort
",,"All other listed algorithms have a best case of nlogn.Bubble sort has a best case of N and will stop sorting when it does an iteration in which no swaps were required.
",
"Given the hash function f(x) = x % 10, for the following input (1234,60,1264,3456,638,3666,349,201,470,1000,84,3), which statement is true for this input using open hashing:
","The elements 3456, 3666 and 60 hash to the same value
","The element 3 generates an error with this hash function
","The elements 1234, 1264 and 84 hash to the same value
","Each element hashes to a different value(unique)
","Once one element hashes to a value, no other element can hash to this value
","In open hashing the function x % 10 gives:1234 = 460 = 01264 = 43456 = 6638 = 83666 = 6349 = 9201 = 1470 = 01000 = 084 = 43 = 3A is false as the elements 3456, 3666 and 60 DO NOT hash to the same valueB is false as 3 % 10 = 3, so NO error is generatedC is true as the elements 1234, 1264 and 84 all hash to the same value of 4D is false as each element DOES NOT hash to a different value(unique)E is false as multiple elements can hash to the same value (they are put into a linked list)Extra information on hashtables can be seen in the Week10b-HashtablesAll lecture from 2019
",
"You are implementing a data structure. When you insert a new items at the front of data structure, it can be done in just a few simple steps. When you try to access the 1500th item, you must pass through 1499 others first. If you want to remove an item, you can remove any item in just a few steps once you have found it. It does not have a previous pointer. What data structure have you implemented?
","Doubly linked list
","Linked list
","A graph
","An array
","None of the above
","You have to pass though x-1 nodes to access the x th node in a list. You can insert an item in just a few steps at the start of the list regardless of the number of nodes, unlike an array. Once you have found an item you want to remove, you can do so in just a few steps with a linked list, unlike an array where you would have to shift all the following items left one slot.Doubly linked lists make use of previous pointers, linked lists do not.More information:2019_TFLinkedlistsedit slide 13
",
"Draw a closed hash table with linear probing of size 7. The hash function is h(x) = x % 7.The following elements are inserted into the hash table: 2, 7, 13, 19, 21, 25, 29What is the correct order of the elements now in the hash table?
","7, 21, 2, 29, 19, 25, 13
","7, 2, 13, 19, 21, 25, 29
","7, 21, 2, 29, 13, 25, 19
","7, 21, 2, 29, 25, 19, 13
","7, 25, 21, 19, 13, 29, 2
","See 2019 lecture slides Week10b-HashtablesAll to understand the process of hashing and hash tables.
",
"Billy Bob needs to implement a searching algorithm. His algorithm keeps dividing the search area in half (on sorted data) until it arrives at his word. However, there's a twist! The algorithm is very clever, and, if for example the word starts with 'z', it will start searching towards the end. The steps taken by this algorithm is log_base2(log_base2(n)) on average. Which of the following algorithms did Mr. Bob implement?
","Linear search
","Binary search
","Interpolation search
","Exponential search
","None of the above
","Interpolation search is an improved binary search by choosing a different element (i.e. not necessarily the halfway element) based on what you are searching for. So, for A, B, C? Search at the beginning! K, L, M? Search in the middle! X, Y, Z? Search at the end!More information:DA-2019_TF_Lecture02-ADTs, slide 10.https://en.wikipedia.org/wiki/Interpolation_search
",
"Given the following algorithm:for(int i = 0; i < n; i++) for(int j = 0; j < n; j++) System.out.println(""I love DSA!!!"");Which of the following following describes the correct time complexity bounds?
","O(n^2), theta(n^2), omega(n^2) only.
","O(n^3), theta(n^2), omega(n) only.
","O(2^n), theta(n^2), omega(log n) only.
","They are all correct.
","None of them are correct.
","They are all correct time complexity bounds. Theta means exactly, big-O means at most, and omega means at least. Therefore, if theta is n^2, then big-oh of anything greater than or equal to theta is correct, and omega of anything lesser than or equal to theta is correct.In other words,Exact bound (i.e. big theta).Upper bound (i.e. big O).Lower bound (i.e. big omega).More information:2b Slide 10
",
"You are tasked to chose a sorting algorithm which will take the same time to sort any two lists with the same number of elements.Which one fits the requirements from the list below?
","Selection Sort
","Quick Sort with a median of three implementation
","Insertion Sort
","Bubble Sort
",,"Selection Sort: Best(n^2), Average(n^2), Worst(n^2)Quick Sort with a median of three implementation: Best(nlog(n)), Average(nlog(n)), Worst(nlog(n))Insertion Sort: Best(n), Average(n^2), Worst(n^2)Bubble Sort: Best(n^2), Average(n^2), Worst(n^2)Selection Sort is the only one which fits the requirements even if it's not the best algorithm in general2019 Week 7(a) slide 5
",
"The following pseudocode shows a function ""traverse"" that recursively performs a tree traversal algorithm to print the tree values. What is the name of the traversal?traverse(node) if (node == null) return traverse(node.left) traverse(node.right) print(node.value)
","Pre-order
","Level-order
","Post-order
","In-order
",,"Pre-order - current, left, rightIn-order - left, current, rightPost-order - left, right, currentLevel-order - visits every node on a level before moving down
",
"What is the best, average and worst time complexity of shell sort?
","Best: O(nlog(n)), Average: O(n^2), Worst: O(n^2).
","Best: O(nlog(n)), Average: O(nlog(n)), Worst: O(nlog(n)).
","Best: O((n^2)log(n)), Average: O(n), Worst: O(n^2).
","Best: O(nlog(n)), Average: Varies, Worst: O(n^2).
","Best: O(n), Average: O(n), Worst: O(n^2).
","2019 week5a slide 10 gives links
",
"Which of the following sorting algorithms does not have an average time complexity of nlogn?
","Quick Sort with a median of three implementation
","Heap sort
","Merge sort
","Shell sort
","Quick sort with a guaranteed median as a pivot
","Shell sort has an average complexity of O(n1.25).
",
"Between the following statements,which better explains the difference between an Open Hash Table and a Close Hash Table?
","A Close Hash Table can only store a fixed number of itemsAn Open Hash Table can be expanded when needed to store more items
","A Close Hash Table has a fixed number of buckets in which items can be storedAn Open Hash Table has a fixed number of buckets which contains other data types, like a linked list, in which items with the same hash code will be stored.
","An Open Hash Table can only store a fixed number of itemsA Close Hash Table can be expanded when needed to store more items
","An Open Hash Table has a fixed number of buckets in which items can be storedA Close Hash Table has a fixed number of buckets which contains other data types, like a linked list, in which items with the same hash code will be stored.
",,"See slides of the lecture 10b
",
"Which of the following sorting algorithms has an average time complexity ofT(n)=nlog(n) and space complexityT(n)=n?
","Heap Sort
","Stooge Sort
","Insertion Sort
","Merge Sort
","None of the above
","Heap Sort has a space complexityT(1).Insertion Sort has an average time complexityT(n^2).Stooge Sort is incredibly slow with time complexity higher than n^2.Merge sort has a time complexity of T(nlogn) and space complexity ofT(n) as it needs a temporary array for storing the sorted lists.
",
"Which of the following trees is a legit binary search tree containing the numbers (2,7,9,12,18,23,26,37,43,75)? Represented in PRE-ORDER traversal!
","26, 12, 7, 2, 9, 18, 23, 43, 37, 75
","26, 12, 43, 7, 18, 37, 75, 2, 9, 23
","2 ,7, 9, 12, 18, 23, 26, 37, 43, 75
","26, 43, 7, 2, 9, 18, 23, 12, 37, 75
","2, 9, 7, 23, 18, 12, 37, 75, 43, 26
","A) Pre-order traversalB) In-Level traversalC) In-order TraversalD) Not a legitimate binary search treeE) Post-order Traversal
",
"Given this graph:How many paths of length 2 or less are there from vertex C to F?
","0
","1
","2
","3
","4
","If you make the adjacency matrix for this graph then square it you get a 1 in the (3,5) slot on both meaning there is one path of length one and one path of length two so adding these gives 2 paths of length 2 or less.
",
"Consider a hash table of size seven, with starting index zero, and a hash function (3x + 4)mod7.Assuming the hash table is initially empty, which of the following is the contents of the table when the sequence 1, 3, 8, 10 is inserted into the table using closed hashing?Note that �_� denotes an empty location in the table.
","1, 8, 10, _, _, _, 3
","8, _, _, _, 3, 1, 10
","1, _, _, 10, 8, _,3
","1, 10, 8, _, _, _, 3
",,"Let us put values 1, 3, 8, 10 in the hash of size 7. Initially, hash table is empty- - - - - - -0 1 2 3 4 5 6The value of function (3x + 4)mod 7 for 1 is 0, so let us put the value at 01 - - - - - -0 1 2 3 4 5 6The value of function (3x + 4)mod 7 for 3 is 6, so let us put the value at 61 - - - - - 30 1 2 3 4 5 6The value of function (3x + 4)mod 7 for 8 is 0, but 0 is already occupied, let us put the value(8) at next available space(1)1 8 - - - - 30 1 2 3 4 5 6The value of function (3x + 4)mod 7 for 10 is 6, but 6 is already occupied, let us put the value(10) at next available space(2)1 8 10 - - - 30 1 2 3 4 5 6
",
"What is a Balance Factor used for in an AVL Tree?
","If all child nodes are at the same level
","What rotation to make.
","When the last rotation occured
","If the tree is unbalanced
",,"Answer: DThe balance factor (BalanceFactor = height(left-sutree) - height(right-sutree)) is used to check if the tree is balanced or unbalanced.
",
"What is the runtime of the following code ?for (int i=1; i<n; i=i*2) System.out.println(�hello�);for (int j=1; j<m; j++) for (int k=1; k<10; k++) for (int l=1; l<j; j++) System.out.println(�CM20254�);
","
","
","
","
","None of the above
","The answer is D since the first for loop is on its own and has complexity log(n) we then add on the complexity of the nested for loops which has complexity m^2.
",
"Which of these trees is NOT AVL balanced?
","
","
","
","
",,"The balance factor for all nodes must be either +1,-1 or 0 for an AVL tree. The balance factor for the root in C is 2.
",
"Which of the following is a graph representation?
","Linked list
","Array list
","Adjacency List
","B+ Tree
","Directed Graph
","Week 9a - graphs lecture; slide 12.
",
"Which of the following is pre-image resistance?
","It is hard (as hard as Birthday Paradox attack ~ 2n/2)to find two messages m1 m2 with h(m1) = h(m2).
","Given v, it is hard (~ 2n)to find m with h(m) = v
","Given m2, it is hard (~ 2n)to find m1 m2 with h(m1) = h(m2).
","The probability of a collision in a hash table is always < 0.1
",,"Week 11-a post slide 16.https://moodle.bath.ac.uk/pluginfile.php/1454603/mod_resource/content/0/Week11a-post.pdf
",
"Take the following list of numbers:13, 214, 24, 63, 46, 153If you were to apply a shell sort to this list, where h = 4, 2, 1, how many swaps take place to reach the sorted list:13, 24, 46, 63, 153, 214
","4
","5
","6
","10
",,"It would take 5 swaps to completely sort this list, therefore the correct answer is B.This sort could also be done in 5 swaps using a bubble sort. This fact may have benefitted you if you understand the process of a shell sort.The process of a shell sort can be understood using slides 3-7 of the 2019 lecture slides called ""Week5a-Powerpoint"" available on Moodle.
",
"Accuracy and precision are two important factors to consider when taking data measurements.What are the correct definitions of accuracy and precision?
","Accuracy is how close a value is to its true value.Precision means the level of detail at which data is stored.
","Accuracy means there is a lack of bias in the data.Precision is how repeatable a measurement is.
","Accuracy is how close a value is to its true value.Precision is how repeatable a measurement is.
","Accuracy is how repeatable a measurement is.Precision is how close a value is to its true value.
","Accuracy means the level of detail at which data is stored.Precision means there is a lack of bias in the data.
","Accuracy is how close a value is to its true value.Precision is how repeatable a measurement is and is measured using the standard deviation of the measurements X1, � , Xn.This information can be found on Moodle:Slides 8 and 9 of the Week1b-Powerpointv2 powerpoint.
",
"What is the formula to calculate the load on a hash table?
","
","
","
","
","L is always in the range of 0 to 1
","The answer is A.Look at moodle powerpoint Week10b-HashtablesALL
",
"Which answer is always TRUE for Linked Lists?
","When adding to Linked Lists, if they have a tail reference, they need to be resized.
","Linked Lists are always faster than array lists at getting to an element in the list/array respectively.
","In a Linked List, the best and worst case runtime for the operation add(o) is the same.
","All Linked Lists always have amortised runtimes of n for insert(o,i) and remove(i).
","Linked Lists are probabilistic lists.
","A. Linked Lists never need to be resized before an operation. When a Linked List is added to, regardless of whether it has a tail reference, the list does not need to be first resized.B. Array Lists find the nth element in one step. Linked Lists find the nth element in n steps. They only take the same length of time are when you are finding the first element.C. This is true, they both have a run time of 1.D. This is not always true. If a Linked List has a reference to the (i-1)th element, then the amortised runtime is 1.E. This is only true for skip lists.
",
"Management has asked you to change a closed hashtable to an open hashtable. It currently has a load factor of 0.75.What is the change in the average number of steps to find a bucket after you change the hashtable?Answer is: open av. - closed av, can be positive or negative
","+2.5, Increase
","-1.375, Decrease
","-1.125, Decrease
","+1.375, Increase
","None of the above
","2019 Week 10b-HashtablesAll, Slides 31-32. Using the equations for average number of steps for closed and open hashtables with the 0.75 load factor we find closed av. = 2.5 and open av. = 1.375. So the change is 1.375-2.5 = -1.125 steps
",
"Which of these sorting algorithms requires additional working space?
","Bubble sort
","Merge sort
","Heap sort
","Selection sort
",,"Merge sort has a worst case space complexity of O(n), while bubble sort, heap sort and selection sort have worst case space complexities of O(1)
",
"An algorithm has runtime, what is the asymptotic time complexity of this algorithm?
","
","
","
","
","None of the above
","The answer is C since the most significant term in the runtime is n^4. Explained in Lecture Week2b
",
"Choose the correct answer below that completes the definition of Amortised runtime analysis._______ runtime for a Data Structure operation when using it many times starting from an empty Data Structure.
","Best
","Average
","Worst
","None of the above options complete the definition correctly
",,"Stated in the lectureWeek3a-TF-Arrays lists edit, slide 14
",
"An abstract data type can be described as ""a coordinated group of ____, ____, and ____ that is used to solve a particular problem"". Which of the following options would be an incorrect choice to fill one of the blanks?
","interface functions
","networks
","algorithms
","data structures
",,"week 2a, lecture02-ADTs, slide 18""a coordinated group of data structures, algorithms, and interface functions that is used to solve a particular function""
",
"Order the complexities from lowest to highest growth rate:a = log(n)b = n log (n)c = (log(n))^2d = sqrt(n)e = 2^nf = n^3g = n
","a, b, d, g, c, f, e
","g, a, b, d, f, c, e
","a, g, b, c, d, f, e
","a, c, d, g, b, f, e
","g, a, c, e, d, b, f
","The order is:Logarithmic: log(n)Logarithmic-squared: log2(n)Square root: sqrt(n)Linear: nLogarithmic: nlog(n)Cubic: n^3Exponential: 2^n
",
"Which of the following is an AVL Tree:
","
","
","
","
","None of the Above
","A) Look at the node with element 4. The left subtree has height 0, whereas the right subtree has height 2, so it is unbalanced and thus not an AVL tree.B) Left subtree of root has height 2, whereas right subtree of root has height 0 => unbalanced => not an AVL TreeC) Height of subtrees doesn't differ by more than one at any node, smaller elements always on left, larger elements always on right.D) 6 < 7, but is on 7's right subtree.E) C is an AVL tree.
",
"Insert the following numbers lexicographically in an AVL tree: {5,20,8,9,3,11,4,65,85,35,15,1}.What is the in-order transversal of the tree?
","5, 20, 11, 1, 15, 35, 3, 4, 8, 65, 9, 85
","5, 20, 8, 11, 3, 65, 9, 1, 15, 4, 85, 35
","1, 11, 15, 20, 3, 4, 35, 5, 65, 8, 9, 85
","1, 11, 15, 20, 3, 35, 4, 5, 65, 8, 85, 9
","1, 15, 3, 4, 85, 11, 35, 65, 9, 20, 8, 5
","Below is the balanced AVL tree: 5 / \ / \ 20 8 / \ / \ / \ / \ 11 35 65 9 / \ / \ / / \ / \ / 1 15 3 4 85
",
"What is the time complexity of the following code:
","O(nLogn)
","O(n/2)
","O(n^2)
","O(n^2Logn)
",,"It is O(nLogn) becausej keeps doubling until it is less than or equal to n. Therefore, the inner loop has log(n) steps. The outer loop has n/2 steps. As a result,total steps = O(n/ 2 * log(n)) = O(nLogn).
",
"What is a balance factor in an AVL tree used to check?
","What sort of rotation to make.
","If the tree is unbalanced.
","The height of the tree.
","If all child nodes are on the same level.
",,"The balance factor(left sub-tree height � right sub-tree height) is used to check if the tree is balanced or unbalanced. It is balanced if the balance factor is either 1, 0, or -1. Otherwise, it is unbalanced.
",
"Consider the below BST, which is not a complete binary tree. Remove the root node 3 correctly, as described in lectures, then rebalance the tree as a complete binary tree according to the below definition. Which of the following statements describes the unique resulting tree?The definition of a complete binary tree is to be a binary tree in which every level, except possibly the last, is full, and all nodes on the lowest level are as left as possible.
","The root node is 2, and the leaves are 1, 5, and 7.
","The root node is 5, and the leaves are 1, 4, and 6.
","The root node is 5, and the leaves are 1, 4, and 7.
","The root node is 6, and the leaves are 1, 4, and 6.
",,"To remove a node with two children, it should first be replaced with another, and then that node should be removed. There are two possible nodes to replace such a node with: the left subtree's rightmost (largest-valued) child, or the right subtree's leftmost (lowest-valued) child. In this example, these are the nodes 2 and 4 respectively.Considering first node 2. Replacing the root node 3 with 2, then removing node 2 produces the following:This is unbalanced, and therefore also not complete. In order to make the tree complete, we must rearrange the nodes so that the minimal number of levels is achieved, and so that all nodes are leftmost on the lowest level. This produces the following:The tree is now balanced and a complete binary tree. We can see that the root node is 5, and the leaves are 1, 4, and 6, therefore this is the correct answer.If we consider now node 4, we must replace the root node 3 with 4, and remove node 4. This produces the following:Although the number of levels is now minimal, again, it is not a complete binary tree. For the tree to be complete, the 'gap' must be rightmost on the lowest level. Rearranging as such produces this:As you can see, this is identical to the result produced after rebalancing the tree in the case when 2 was considered above. Thus, again we reach the answer that the root is 2, and the leaves are 1, 4, and 6, and so we can see that the solution is unique.
",
"What is the average case and worst case runtime when searching for a value in a binary search tree with N values?
","Average:?(log N)Worst:?(N)
","Average: ?(log N)Worst: ?(log N)
","Average: ?(N)Worst: ?(N2)
","Average: ?(log N/2)Worst: ?(N)
",,"Week8a-Trees2 slide 12
",
"log212! = 28.8355. What is the minimum number of comparisons needed to sort 12 items?
","28
","29
","30
","31
","33
","Week 5a slide 8
",
"Given a particular load factor L for a closed hash table with linear probing, on average, how many steps does it take to find an item?
","�(1+ 1/(1-L))
","1 + L/2
","L
","None of the above.
",,"Week 10b Hashtables, page 31. (pptx)
",
"Let f (n) and g(n) be two real-valued functions defined on the positive integers.If there exist positive numbers b and B, such that |f(n)| = B|g(n)| for all n = b,which of the following is true?
","f (n) ? T(g(n))
","f (n) ? ?(g(n))
","f (n) ? O(g(n))
","None of the above.
",,"We say that f is of order at most g (written�f (n) ? O(g(n))�) if there exist positive numbers b and Bsuch that|f (n) | = B|g(n)| for all n = b.Week1a.pdf on moodle.
",
"The following text describes a type of tree traversal: - Process current node - Process nodes in the left sub-tree - Process nodes in the right sub-treeWhich of the following traversals does the above describe?
","Post-Order Traversal.
","Pre-Order Traversal.
","In-Order Traversal.
","Level Order Traversal.
","None of the above.
","Below is example code for printing out the data in all the nodes in a tree using the pre-order traversal:void preOrder(Node current) { if (current == null) { return; } System.out.println(current.data); //This is recursive so all the nodes in the left sub-tree will be processed first preOrder(current.left); preOrder(current.right);}
",
"What is the output of the pre-order traversal of the AVL tree which started empty and had the following elements inserted in this order:6, 43, 11, 23, 9, 15
","6, 43, 11, 23, 9, 15
","11, 6, 9, 23, 15, 43
","9, 6, 11, 23, 15, 43
","23, 11, 15, 9, 6, 43
","11, 9, 23, 15, 6, 43
","6 is entered, balanced43 is entered, balanced11 is entered, unbalanced --> LL rotate, now balanced23 is entered, balanced9 is entered, balanced15 is entered, unbalanced --> R rotate on '43' subtree, now balancedPre-order traversal as described in 2019 Lecture 13
",
"A graph in which all edges go from one vertex to another in a specific direction is known as what?
","Arrow Graph
","Pointer Graph
","Directed Graph
","One-Way Graph
","None of the above
","Directed graph is just what is it called (See 2019 Lecture 17)
",
"Finish the name of this module:Data Structures and _____
","Apples
","Absolut Vodka
","Jeffrey Epstein Didn't Kill Himself
","Algorithms
","Abstractions
","While C is factually accurate, D is the correct answer because the name of this course is Data Structures and Algorithms.
","samuelth (sth35)
"
"Finish the name of this module:Data Structures and _____
","Apples
","Absolut Vodka
","Jeffrey Epstein Didn't Kill Himself
","Algorithms
","Abstractions
","While C is factually accurate, D is the correct answer because the name of this course is Data Structures and Algorithms.
","samuelth (sth35)
"
"In a hash table with 600 slots, after how many insertions is there likely to be (i.e. with probability 0.5 or greater) a collision?
","300
","30
","7
","29
","28
","The explanation for this is alongside the Birthday Paradox (2019 Week 10b - slide 12). A collision is likely after approximately (3.s.f). Therefore 29 insertions are necessary.
",
"Within a singly linked list, what are the values stored at each node?
","A pointer to the next nodeAn array of elements
","A pointer to the next nodeA pointer to the previous nodeAn element
","An array of pointers, containing a pointer for each level in the list.An element
","A pointer to the next nodeAn element
",,"A singly linked list works in one direction and at one level. Each node contains its information in the element and has a single pointer that directs to the next node when traversing the list.
",
"A software developer created an algorithm to print all the nodes in a tree. This algorithm is used on the following tree: M / \ B P / \ / \ A D N ZIf the algorithm prints A B D M N P Z, what is the traversal order used by the software developer?
","Post-Order Traversal
","In-Order Traversal
","Pre-Order Traversal
","Level-Order Traversal
",,"for explanation check week 7b slides (first lecture about trees)
",
"Insert 28, 29, 16, 9, 34, 8, 20 in order into an empty AVL Tree. What are the leaf nodes after rebalancing to satisfy the AVL Condition?
","8, 20, 34
","9, 8, 16
","20, 34, 9
","9, 16, 29
","None of the above
","Add into the tree as normal (smaller than goes left, larger than goes right).The rebalancing problem comes once we add 8 to the tree, where the node (16) becomes unbalanced. Perform a single left rotation on the node and finally add 20.The leaves are 8, 20 and 34.
",
"What is the minimum number of comparisons required to sort any permutation of 7 integers?
","11
","12
","13
","14
","15
","It has been proven that the smallest number of comparisons is 13 for 7 objects. This is done by merge sorting 5 items and adding 1 then adding 1 again.
",
"Which tree traversal outputs the letters in alphabetical order?
","In-Order Traversal
","Post-Order Traversal
","Level-Order Traversal
","Pre-Order Traversal
",,"In-Order : d,b,e,a,f,c,gPost-Order : d,e,b,f,g,c,aPre-Order : a,b,d,e,c,f,gLevel-Order : a,b,c,d,e,f,g
",
"What is the difference between a singly linked list and a skip list?
","A skip list has both a next and previous pointer.
","A skip list has multiple lanes to allow for faster searching.
","A skip list has a tail pointer.
","A skip list has child nodes to allow for faster searching.
","A skip list has the head pointing to the center node.
","A skip list contains multiple lanes, a slow lane containing all of the nodes stored in a singly linked list way as well as faster lanes that have less elements in them to allow for faster searching.
",
"You've just started work at a long standing Technology company and your first project is to update old legacy data structures. You are given a closed hash tablewith linear probing containing identification numbers that is no longer being used, but is going to be archived due to its sensitive nature.You are tasked to copy this data into an array for archiving, but first the Load factor needs to be calculated.The closed hash table has 10,000 keys stored in it and you are told any item can be accessed in 3 steps on average. What is the Load Factor?
","0.6
","0.7
","0.8
","0.9
","None of the above
","The Load Factor is defined as:L = (Max number of keys)/(Total number or buckets).The average number of steps to find an item in a closed hash table with linear probing is given by .Setting this equation to equal to 3 gives a Load Factor of 0.8.
",
"You wish to use open hashing (where each array slot contains a pointer to a linked list). The hash function has the form h(x) = x % 6 and the hash table has slots 0, ... , 5. If you insert the elements 5, 6, 7, 9, 15, 21, 22, 61 in that order, what is the minimum list length at the end?
","0
","1
","2
","3
","None of the above
","For the elements5, 6, 7, 9, 15, 21, 22, 61 the open hash table will look like:0: 61: 7 612:3: 915214: 225: 5the 2 slot points to no values hence minimum list length is 0.
",
"An algorithm has runtime T(n) = 0.00149n14+ 100n2+ 48nlog(n) for input of size n. What is the asymptotic time complexity of this algorithm?
","
","
","
","
","None of the above
","Leading term is ,hence its asymptotic upper bound cannot be anything less than .Therefore A,B,D are incorrect. D is correct since this is an upper bound (but not exact bound) to T(n).
",
"What would the output of the following binary search tree using pre-order traversal look like?
","30, 15, 7, 22, 17, 27, 60, 45, 75
","7, 15, 17, 22, 27, 30, 45, 60, 75
","7, 17, 27, 22, 15, 45, 75, 60, 30
","7, 15, 17, 27, 22, 30, 60, 75, 45
",,"A) is pre-orderB) is in-orderC) is post-orderD) is random
",
"In the context of an AVL Tree, AVL stands for:
","Audio Video Library
","Adelson-Velskii and Landis
","Absolute Value List
","Adelson Vilgefortz and Loch
","Amateur Vascularity Listing
","B is the correct answers.AVL trees were named after two Soviet computer-scientists:Georgy Maximovich Adelson-Velsky andEvgenii Landis..
",
"Imagine you are a software engineer a Honda. Your boss asks you to implement a probabilistic skip list in Java with the probability of a new node being added to each lane decreasing by a factor of 0.5 for each lane as the lane number increases. However, due to lack of server space, she says that you may not use any arrays of size greater than 10 when defining the set of pointers for each node. Roughly how many items can this skip list hold before it can no longer be considered binary search when searching for nodes?
","10
","200
","512
","1024
","2048
","Week3b-TFLinkedlistsedit. Each node can only have 10 pointers, therefore there can only be 10 lanes (0-9). The 9th lane can skip 29(512)nodes. Therefore, for lists of size greater than 1024, the 9th lane will skip less than half of the nodes and is no longer binary search.
",
"What is one disadvantage of using a Hash Table with a small load L?(say, for L < 0.2)
","It is more likely that collisions will occur when inserting a new item.
","Searching for an item takes longer.
","You can't delete an item.
","A lot of memory is wasted.
","None of the above.
","See 2019 Lecture ""Week10b - HashtablesAll""
",
"Select the correct differences between a B-Tree and a B+ Tree?
","Unlike a B-Tree, a B+ Tree is self-balancing allowing deletion and insertion to more efficient.
","Unlike a B-Tree, a B+ Tree only contain key values in the internal nodes and only at the leaves do they contain both the key value and data pointer.
","Unlike a B-Tree, all the leaves on the B+ Tree are at the same depth, thus helping with the abilitly of the B+ Tree being self-balancing.
","Unlike a B+ Tree, a B-Tree is generally used to minimize disk reads and so the size of each node is typically the size of the disk block whereas a B+ Tree is used in main memory.
",,"A B+ Tree is a variation of a B-Tree that increases efficiency by reducing the data stored in each node. A B-Tree is a self-balancing BST that can hold more keys and children nodes than a normal BST. Note that B-Tree must also have leaves at the same depth. See Week8b - Trees3 Slide 29&30.
",
"Consider average time complexity for each search algorithm.Select the only true statement.
","Array List search and Linked List search have the same average performance of O(n)
","Array List search is faster than Linked List search, with Array List O(n) and Linked List O(n^2)
","Array List search is slower than Linked List search, with Array List O(n^2) and Linked List O(n)
","Array List search is faster than Linked List search, with Array List O(1) and Linked List O(n)
","None of the above
","ArrayList search is O(1) because it can access the i'th element in the array in constant time.Linked List search is O(n) because it must check each item from the beginning, and traverse the list element by element until it finds a match. Hence on average it will be doing n/2 comparisons which is O(n).
",
"Suppose I have a Close Hash Table with load L, and it takes me on average 1.15 steps to find an item in the table. What is the value of L (to 2 sig.fig.) ?
","0.40
","0.16
","0.23
","0.53
","0.22
","The average number of steps needed to find an item for a Closed Hash Table with load L is:# of steps =1/2(1 + 1/(1-L))Setting the above equation equal to 1.15 and rearranging, gives us L = 0.23.2019 Lecture ""Week10b""
",
"Which of the following statements is False?
","Open Hash Tables are generally more efficient than Closed Hash Tables.
","You can delete entries in a Closed Hash Table
","A good hash function disperses entries evenly across the array.
","The average number of steps to find an item in an Open Hash Table with load L isNumber of steps = 1+ L/2
",,"Correct answer is B. Deleting an item in a Closed Hash Table may result in the search algorithm terminating prematurely ( for example, if you delete an item that had collisioned when entered to the table).See 2019 Lecture ""Week10b - HashtablesAll""
",
"Consider the following doubly linked list:HEAD - one - two - three - four - five - TAILwhere one is a Node object with integer value 1, prev = HEAD, next = two. This object type is similar for the remaining nodes.What will the list be after performing the following operations:Node temp = New Node(value=7, prev=one, next=three)one.next = temp;three.prev = temp;
","HEAD - one - two - temp - four - five - TAIL
","HEAD - one - two - temp - three - four - five - TAIL
","HEAD - one - temp - three - four - five - TAIL
","HEAD - one - two - three - four - five - temp -TAIL
","None of the above
","The temp node is made with forward pointer to node three, and prev pointer to node one.one.next is updated to temp, hence 2 has been removed.three.prev is updated to temp, which removes the backwards pointer to the node two.
",
"What is the runtime for the following code?for (int i = 1; i < n; i=i*2){ System.out.println(""Data Structures "");}for (int j = 1; j < n; j++){ for int k = 1; k < 5; k++){ System.out.println(""and Algorithms""); }}
","T(n)
","T(n^2)
","T(n log n)
","T(log n)
",,"As we increase the n value, the amount of operations happening increases proportional to the number of n .
",
"An application for a supermarket checkout needs to store products with their serial numbers, and the application must be able to quickly find the product linked to the serial number which has been scanned by the cashier.Should the serial number of the product change, the application should also be able to quickly change the serial number associated with the relevant product. Which of the following data structures would be most appropriate to store the products and serial numbers in memory?
","Linked list
","Open hashtable
","Closed hashtable
","Sorted array
","Sorted ArrayList
","Open hashtable is the preferred ADT as they are the most efficient in searching/editing key value pairs.
",
"Alice sets up an RSA encryption and sends Bob all the necessary components to send her an encrypted message. What does bob need to compute to encrypt his message?Where m is the message Bob wishes to encrypt,N and t are Alice's public key?
","c = mt(mod N)
","c=m/(tN)
","c=mNmod(t)
","c=m(t/N)
",,"See Week 11b
",
"Using open hashing with ahash function of the form h(x) = x % 7 and a hash table with slots 0, �,6, if you insert the elements 15, 7, 22, 8, 19, 31, 30, 29, 40, 81 in that order, what is the maximum list length at the end?
","1
","2
","3
","4
","5
","The hash table would look as following:0: 7, 811: 15, 22, 8, 292: 303: 314:5: 19, 406:
",
"A quadratic time algorithm uses 70 elementary operations to process an input of size 20. What is the predicted number of elementary operations it will use for an input of size 200?
","700
","7000
","70000
","700000
","7000000
","The input size has increased by a factor of 10. Since it is a quadratic function, the number of elementary operations will increase by a factor of 10^2.
",
"Given the unsorted listed 15,3,6,5,19,4,10 how many passes of quick sort are needed to sort the list?
","3
","4
","5
","7
",,"15,3,6,5,19,4,10 under lined numbers are the pivot, and bold number are sorted.3,6,5,4,10,15,19 first pass 3,6,5,4,10,15,19 second pass3,5,4,6,10,15,19 third pass3,5,4,6,10,15,19 fourth pass3,5,4,6,10,15,19 fifth pass
",
"Consider a closed hash table, with linear probing, with 4 buckets: [0,1,2,3]Where a ""Value"" is input and the ""Bucket"" the value is placed into is decided by the hash function:Bucket = (Value+1) %4(Also written as : Bucket = (Value+1) mod 4 ).What is the final array, when 7,13,9,5 are added in the order specified.
","[5,7,9,13]
","[7,5,13,9]
","[7,13,9,5]
","[13,5,9,7]
",,"1st addition : (7+1)mod 4 = 0 therefore place 7 in position 0. [7,,,]2nd addition: (13+1)mod 4 = 2 therefore place 13 in position 2. [7,,13,]3rd addition: (9+1)mod 4 = 2 therefore 9 belongs in position 2, however there is already a value in position 2 so place in the next available spot. place 9 in position 3. [7,,13,9]4th addition: (5+1)mod 4 = 2 therefore 5 belongs in position 2, however there is already a value in position 2 so place in the next available spot (at end of array wrap around to the start). place 5 in position 1. [7,5,13,9]
",
"What is the minimum number of comparisons to sort 9 items?
","17
","19
","20
","21
",,"See Week 5a Sorting and Visuliser notes
",
"Which of the following statements is true?
","On average it will take fewer steps to find an item in a closed hash table with a load factor of 0.1 than an open hash table with a load factor of 0.1.
","On average it will take more steps to find an item in an open hash table with a load factor of 0.9 than a closed hash table with a load factor of 0.7.
","If i have at most 73 items I want to insert into my hash table with 365 buckets, my load factor will be 0.2.
","I will need at least 66 buckets in my hash table if I have at most 45 elements to insert and want a load factor of 0.6 or less.
",,"2019 week10b slides 30-33.
",
"In the first step of the RSA encryption process, the following are chosen or computed by Alice:- p,q = large primes- N = pq- s = relatively prime (i.e. coprime) to (p-1)(q-1)- t = chosen such that st = 1 (mod (p - 1)(q - 1))Which of the following are published to be received by Bob.
","st
","N, t
","p, q
","m^t (where m is her message)
",,"Week11(b) Slides 12 and 13.N and t are published. Bob then encrypts his message m by calculating c = (mod N) and publishing c.Alice can then calculate . As theRivest�Shamir�Adleman (RSA) corollary states thatIf N = pq with p, q distinct primes and k = 1(mod (p - 1)(q - 1)), then x^k = x (mod N).
",
"Consider the following hypothetical situation:You have a sorting algorithm which uses quicksort 50% of the time, and insertion sort 50% of the time, on average. n input lists arrive such a given list is already completely sorted with probability x, and the rest are random.Give an equality for x in terms of n for when this approach will be quicker than always using Selection sortYou may refer to the below:(Note that because of the hypothetical nature of the question, the answer may seem counter-intuitive, but will make mathematical sense)
","
","
","
","
","
","The average runtime for our method considering the different cases where the list is/isn't sorted is:We want to find where this is less than selection sort, which is expanding and multiplying by two, we have:so our final answer is:
",
"When you multiply an adjacency matrix by itself, what does the resulting matrix tell you?
","Defines the maximum path between each vertex.
","Defines the minimum path between each vertex.
","Defines which vertices are exactly two edges apart from each other.
","None of the above
",,"From lecture 9)b) panopto.""Graphs1TF"" Powerpoint slide 10.
",
"You work for Spotazon music, and have been asked to implement a data structure to store music playlists. Users will want to be able to easily add/remove tracks from any point in the playlist, and they should be able to skip forward/skip backwards a track. Your brief is to use a data structure that will maximise the speed of these functions. Which of the following data structures would be most appropriate.
","Singly-Linked List
","Array
","Doubly-Linked List
","Heap
","AVL Tree
","The doubly linked list has forward and back pointers, so the speed of traversing the tracks in either direction will be optimal. Furthermore, inserting/deleting to a specified point is fast (THETA(n)) [see Week 3b-TFLinkedListsedit on moodle].
",
"You use a standard closed hashtable with linear probing (to the right, i.e. in the direction of higher indices). The hash function has the form h(x) = x % 7 and the hash table has slots 0, � , 6. If you insert the elements 18,19,25,701,77,74,y in that order, where y is an unknown integer, what does the hashtable look like at the end?a) 77,701,74,y,18,19,25b) 77,25,701,y,18,19,74c) 77,701,y,19,18,25,74d) 77,18,19,701,25,74,ye) None of the above are correct
","77,701,74,y,18,19,25
","77,25,701,y,18,19,74
","77,701,y,19,18,25,74
","77,18,19,701,25,74,y
","None of the above are correct
","Standard hastable theory using Linear Probing. The unknown integer y makes no difference and goes in the only slot available, as it is at the end.
",
"Consider the following two lists:List X: List of integers from 1 to 100 (inclusive) in ascending orderList Y: Random permutation of list XWhich of the statements A-D is FALSE (on average)?
","Quicksort will sort list Y faster than it will sort list X
","Insertion sort will sort list X quicker than it will list Y
","Insertion sort will sort list X faster than Quicksort will
","Quicksort will sort list Y faster than Insertion sort will sort list X
","All of A-D are true
","A) True because nlogn < n2B) True because n < n2C) True because n < n2D) False because nlogn > n
",
"Which of the following statements about Dijkstra's algorithm is false?
","Its complexity is O(N^2)
","Dijkstra�s Algorithm can be applied on graphs which have negative weights
","The most commonly used data structure is a queue
","None
",,"A is true as it uses two nested loops, resulting in O(N^2) complexityB is falsebecause calculation of cost to reach a destination node from the source node becomes complex when we introduce negative weightsC is true
",
"In a linked list, insertion can be done...
","At the beginning
","In the middle
","At the end
","All of the above.
",,"Covered in lectures.
",
"Which of the following algorithms has the lowest complexity class
","for (int i=0 ; i < n+1000 ; i++){ int k = n; while (k > 1) { sum++; k = k/2; }}
","void foo( ){ int i, sum = 0; for (i=0 ; i < 10000*n*n ; i++) sum += i; for (i=0 ; i < 0.001*n*n*n ; i+=100) sum += i;}
","k = n;while (k > 1){ sum++; k = k/2;}
","Quicksort algorithm
","MergeSort algorithm
","Recall the order of complexities is as followsConstant: 1, Logarithmic: log(n), Log-squared: =log^2(n),Square root: sqrt(n),Linear: n, n log(n), Quadratic: n^2, Cubic: n^3...A has complexity n log(n)B has complexity n^3C has complexity log(n)QuickSort's complexity is n^2MergeSort's complexity is n log(n)Therefore the fastest algorithm is C
",
"A graph is a collection of nodes, called _____, and line segments called arcs or_____ that connect pairs of nodes.
","vertices, paths
","edges, vertices
","graph node, edges
","vertices, edges
",,"Definitions covered in slides - Lecture 17 slide 4/37
",
"Which of the following is a non-linear data structure?
","String
","List
","Tree
","Stack
",,"Covered in lectures.
",
"Which of the following statements about hash tables are true?
","Whenchoosing the exact size of your hash table (the number of buckets) you should use a prime number (eg 2021 instead of 2000)
","The higher the load factor of our table (open or closed) the more efficient open hash tables are in comparison to closed hash tables
","If we need to delete items from our tables you must never use a closed hashing table
","All the above
",,"A. Using a prime number of buckets will ensure the spreading of hash values, resulting in more even distribution and fewer collisions W10b s35B. The average number of steps for open table = 1 + L/2 (L is load factor) whereas for closed table =�(1+ 1/(1-L)), meaning that the higher the load factor the higher the difference between the number of steps for the two tables W10b s33C. W10b s22
",
"What is the runtime of the following code?for (int i=0; i < N; ++i) { for (int j=0; j < M/2; j=j*2) { System.out.println(j); if (i%2 == 0) { for (int k=0; k < 2*N; ++k) { System.out.println(i + "" is even""); } } }}
","
","
","
","
","
","The outermost loop undergoes O(N) iterations.The second loop undergoes iterates up to O(M), but increases logarithmically (thanks to the j=j*2) rather than linearly. Hence, this loop undergoes O(log(M)) iterations.Finally, the innermost loop undergoes O(N) iterations. The fact that this loop only executes for odd values of j is not relevant to the big theta approximation.Therefore, the overall runtime is that of answer A.
",
"An algorithm takes 60 seconds to process an input of n=100, 120 seconds for n=120 and 240 seconds for n=140.Which asymptotic complexity does it likely have?
","?(n^2)
","?(2^n)
","?(log(n))
","?(1)
",,,"tm694 (tm694)
"
"Given the following numbers: 6,2,18,34,13,14.When constructing a perfectly balancedbinary search tree from the numbers in that order, which number is its root?
","18
","6
","13
","34
","ALL
",,"tm694 (tm694)
"
"Selection Sort runs for 5 seconds for 100 records. How likely is it likely to run for 10,000 records?
","100 seconds
","500 seconds
","10 seconds
","50,000 seconds
","None of the above
",,"tm694 (tm694)
"
"Below is an incomplete code for the class LinkedList.Method 'Get' finds the ith element in the linked list. Which code must go at 'X' for the code to work.public Object get(int i){ if (i<0 || i>=n) { return error; } ListNode node = head; Xreturn node.element;}
","for (int j=0; j<0; j++){node = node.next;}
","for (int j=0; j<i; j--){node = node.next;}
","for (int j=0; j<i; j++){node = node.next;}
","for (int j=0; j<i; j++){node = node.prev;}
","for (int j=0; j<i; j++){head = node.next;}
",,"tm694 (tm694)
"
"Given a sorted array of length n of elements, what is the time complexity of implementing it into a Binary Search Tree (BST)?
","
","
","
","
",,"Since the input is sorted, the resulting tree will become very unbalanced meaning each node will only have a right child node. Thus every time an elements is inserted it must traverse the length of the entire tree. Hence, for an unsorted array of elements it would be quicker. See Week8a - Tree2 silde 14.
",
"You have to insert the element ""20"" in this skip list, p = 0.5, max lanes = 5:Which one of the following statements are true?
","The new element must point to ""30"" for each lane it exists on, apart from the lanes ""30"" doesn't exist on.
","There is a 15% chance that the new element will be on 3 lanes.
","The head values of the skip list must not be changed.
","The next values of the ""30"" element must be altered.
","It is not possible for the ""20"" element to point to NULL.
","""20"" goes before ""30"", therefore must point to ""30"" when it is inserted. The lanes can't ""skip over"" elements in the same lane, therefore every instance of ""20"" will point to a ""30"" on it's lane.This question is intended to be of high difficulty.Source: 2019, Week 3b, Slide 14-17
",
"Below is an example graph. Which of the following adjacency matrices represent this graph?
","
","
","
","
","None of the above
","See Moodle resource 'DA-Lecture17-Graphs1 TF 2019sem' for explanation on representing a graph as an adjacency matrix.
",
"What is the result of shell sorting the data set below with a gap size of 3.56 21 30 43 98 23
","23 98 43 30 21 56
","43 21 23 56 98 30
","30 21 56 23 98 43
","21 23 30 43 56 98
","None of the above.
","56 21 30 43 98 23 Original List43 21 30 56 98 23 Compare 56 and 43, and swap.43 21 30 56 98 23 Compare 21 and 98, no change.43 21 23 56 98 30 Compare 30 and 23, and swap.Then iterate once more through the list and no changes are made.
",
"For the following binary search tree:What is the output if we do a pre-order traversal on the tree?Image Source:https://www.gatevidyalay.com/binary-search-trees-data-structures/
","5 10 12 20 22 25 28 30 36 38 40 48
","5 12 10 22 20 28 30 38 48 40 36 25
","25 20 10 5 12 22 36 30 28 40 38 48
","48 40 38 36 30 28 25 22 20 12 10 5
",,"Pre - Order tree traversal:Process the current nodeProcess the left nodeProcess the right nodeThis question is intended to be of medium difficultySource: 2019, Week 7b, Slide 15
",
"Which nodes are visited when searching for ""c""?
","abdc
","bdc
","adebc
","bdec
",,"start at root node - bc>b, go right to d.d<c, go left to cc = c, therefore nodes visited are bdc
",
"Using Dijkstra's algorithm, starting at node S, state the order of nodestraversed before reaching the node B.
","S, A, E, C, B
","S, A, C, B
","S, A, E, C, D, F, B
","S, A, C, D, F, B
","None of the above.
","Dijkstra's algorithm will find the shortest path to an available node and take it, it will repeat this process until it has checked all possible paths and reached the destination.1. Starting at S we move to A is it is shorter Node: Distance A: 2 E: 3 C: 4 D: 5 F: 6 B: 7
",
"Below is an example binary tree. What is the pre-order traversal of this tree?
","1, 5, 13, 11, 2, 16, 23, 44, 22, 48, 50, 45, 21
","1, 2, 5, 11, 13, 16, 21, 22, 23, 44, 45, 48, 50
","21, 16, 2, 1, 11, 5, 13, 45, 22, 44, 23, 50, 48
","21, 16, 45, 2, 22, 50, 1, 11, 44, 48, 5, 13, 23
","None of the above
","Option A is post-order traversal (left, right, centre)Option B is in-order traversal (left, centre, right)Option C is pre-order traversal (center, left, right)Option D is level order traversal (traverse each node on current level then go down a level)Source: Moodle - Week7b-Trees1 (powerpoint)
",
"Which one of the following Big-Oh rules is incorrectly described?
","Transitivity: (""If A<= B, and B<= C, then also A<= C"")For example,If f(n) = O(g(n)), and g(n) = O(h(n)), then f(n) = O(h(n))
","Scaling: (""Constant factors matter"")For example,For all c>0, c*f(n) = c*O(f(n))
","Sums (""The bigger function dominates"")For example,If g(n) = O(f1(n)) and h(n) = O(f2(n)), then g(n) + h(n) = O(max{f1(n), f2(n})
","Products (""The effect of nested loops in an algorithm"")If g1(n) = O(f1(n)) and g2 = O(f2(n)), then g1(n)g2(n) = O(f1(n)f2(n))
",,"Constant factors don't matterFor example,for(int i = 0; i < 2*n; i++) m();has the same asymptotic bounds asfor(int i = 0; i < n; i++); m();This question is intended to be of low difficultySource: 2019, Week2b, Slide 6
",
"Which statement about linked lists and arrays is TRUE?
","It is faster to remove an element from the middle of an array than from a linked list.
","It is faster to search for an item in the middle of an array than a linked list.
","An array allocates memory at runtime and a linked list allocates memory at compile time.
","It is faster to insert an element at the beginning of an array than a linked list
","None of the other statements are true.
","Why option B is true:When searching for an item in the middle of an array, it can be found in one step by specifying the index of the element. However for a linked list each node from the head must be passed through to reach the target node.Why options A and D are false:When inserting or removing an element from an array, other elements must be shifted appropriately. Whereas for a linked list only the pointers of adjacent nodes need to be changed.Why option C is false:An array allocates space at compile time (static memory allocation) and a linked list allocated space at run time (dynamic memory allocation).Source:Moodle -Week3b-TFLinkedlistseditFile Slide 13 -https://moodle.bath.ac.uk/pluginfile.php/1430761/mod_resource/content/0/2019_TFLinkedlistsedit.pdf
",
"Consider a closed hash table with 150 buckets storing 100 items.On average, how many steps of linear probing would it take to find an item?
","1.75
","2
","2.25
","2.5
","2.75
","Load factor (L) = Number of items / Number of bucketsL = 100 / 150 = 2 / 3Average # of steps to find = 1/2 (1 + 1/(1-L))= 2
",
"The following integers are inserted into an empty ALV Tree in the following order: 4, 8, 15, 16, 23, 42. The tree puts the greater integers on the right, and smaller ones on the left e.g 8 would be somewhere to the right of 4. The tree is kept balanced after each insertion. Each node of the tree is then printed using pre-order traversal separated by commas. Nothing is printed if a null node is encountered using this method. Which of the following is the correct output produced?
","4,15,8,42,23,16
","16,8,4,15,23,42
","4,8,15,16,23,42
","15,4,8,23,16,42
","15,8,4,16,23,42
","Explanations can be found in: Week7b-Trees1 and Week8b-Trees3. Pre-order traversal prints the current node, then the left, then the right. I will run through is problem step by step after each insertion and show what would be printed using pre-order traversal at each. 4: Output: 4. 8: Output: 4,8. 15: Tree is now unbalanced at 4, so the tree rotates left with 4 as the pivot. Output: 8,4,15. 16: Tree is still balanced. Output: 8,4,15,16. 23: Tree is unbalanced at 15, so the tree rotates left with 15 as the pivot. Output: 8,4,16,15,23. 42: Tree is now unbalanced at 8, so the tree rotates left with 8 as the pivot. Output: 16,8,4,15,23,42.
",
"Which data structure should be used if you wanted to:Add and remove elements as quickly as possiblePrint the list in the order the elements have been added
","Open hash table
","Closed hash table
","Linked list
","Heap
",,"When using a linked list:Complexity of insertion/deletion = O(1)Complexity of printing the ordered list = O(N)
",
"When using a selection sort algorithm on multiple input data, which of the following statements is correct? It can be assumed that all input data is of equal size.
","Mostly sorted input data will be sorted the fastest.
","Completely unsorted input data (data in reverse order) will be sorted the fastest.
","Randomly ordered input data will be sorted the fastest.
","All input data will be sorted in (roughly) the same amount of time.
",,"Explanation can be found inWeek4a-post on Moodle. The answer is D, because no matter what order the input data is in, the selection sort algorithm will always do the same number of steps. It will always find the smallest item in the list then put that in the first position, then the smallest item in the remaining N-1 positions and put that in the second position and so on. Even if the data is completely sorted, it still iterates through the entirety of each sub-list, of sizes N, N-1, N-2, ... 2, 1. Therefor, the run time is always constant for same size input data.
",
"Correct assigments of big O notation forTheta, Omega, Oare:
","Best, Worst, Exact
","Exact, Worst, best
","Exact, Worst, Best
","Best, Exact, Worst
","Worst, Exact, Best
","2019 Week2b-Powerpoint slide5Theta = exactOmega = bestO = worst
",
"What is the ""load"" of a hash table?
","The total buckets in the array / the max number of keys to insert
","The max number of keys to insert / the total buckets in the array
","(The max number of keys to insert)2/ the total buckets in the array
","(The total buckets in the array)2 / the max number of keys to insert
",,"2019 Week 10 b, slide 30
",
"While searching a hash table for an ID number, I find the memory location according to the hash function to be occupied by a different ID number. I check the 2nd bucket, then the 3rd bucket, then abandon my search. What was in the third bucket?
","Zero
","Nothing
","The contents of the 2nd bucket
","There was no 3rd bucket
",,"Week 10b Slide 17. If there was no 3rd bucket then the search would loop back around.
",
"How many objects (roughly) for n data slots leads to a 50% chance of a collision occuring in a hash table?
","
","
","
","
",,"Week 10b Slide 12
",
"What is the time complexity of: Pre-order traversal, In-order Traversal, Post-order traversal, and Level-order traversal?
","
","
","
","
",,"Week 7b. Slide 29
",
"Which two qualities make up a complete (full) binary tree?
","Every non-leaf node has exactly two children.Number of nodes in the tree is exactly 2^(d+1) where d is the depth of the tree.
","Every leaf node has the same depth.Every non-leaf node has at least one child node.
","Every leaf node has the same depthEvery non-leaf node has exactly two children
","Every non-leaf node has at least one child node.Number of nodes in the tree is exactly 2^(d+1) where d is the depth of the tree.
",,"Week 7b Slide 9
",
"What is the difference between a binary tree and any other tree?
","In a binary tree, a child node is always greater than its parent node.
","A binary tree has at most two children nodes
","A binary tree only has two nodes
","A binary tree has the largest value at the root
",,"Week 7b Slide 6
",
"How many comparisons are required in a 4-way merge sort of n elements?
","
","
","
","
",,"Week 5b Slide 12
",
"What is the post-order traversal of 4 / \ 2 6 / \ / \ 1 3 5 7 \ 8
","1 2 3 4 5 6 7 8
","4 2 1 3 6 5 7 8
","1 3 2 5 7 8 6 4
","4 2 6 1 3 5 7 8
",,"Lecture 7b - Trees 1 - Slide 24
",
"A comparison sorting decision tree of height h has no more than ___ leaves
","
","
","
","
",,"Week 4a Slide 20
",
"What is the average runtime complexity of insertion into a linked list if the reference to the preceding node is given and where n is the number of items already in the list?
","
","
","
","
",,"Week 3b Slide 10
",
"What is the Big-Theta of this code:void myProgram (int a, int b, int c){ for(int i=0; i<a*a; i++){ for(int j=0; j<b; j++){ if(j==b/2){ for(int k=0; k<c; k++){ System.out.println(""TRUE""); } } else { System.out.println(""FALSE""); } } }}
","
","
","
","
","
","Week 2b Slide 23.
",
"What is the asymptotic memory usage of an adjacency matrix compared to an adjacency list?[v is the number of vertices, e is the number of edges]
","Matrix: List:
","Matrix: List:
","Matrix: List:
","Matrix: List:
",,"Lecture 17 - Graphs1 - Slide 17
",
"After two iterations of Selection Sort, what does the following list look like:3 5 2 1 6 4
","2 3 5 1 6 4
","1 2 5 3 6 4
","1 5 2 3 6 4
","1 2 3 4 5 6
",,"Lecture 4a - slide 6.A is two iterations of insertion sortB is two iterations of selection sortC is one iteration of selection sortD is a fully sorted list
",
"Two functions have respective time complexities defined by:where log is of base-2.For what value of n does g become faster than f?
","n=17
","n=107
","n=507
","n=1007
","n=5007
",,
"Consider the following tree:What would be the result of printing the values of each node via POST-ORDER traversal?
","A B C D E F G H
","A B D E G H C F
","D G H E B F C A
","G H E D B F C A
","G H D E F B C A
","Post-order traversal applies the following procedure to each node it arrives at, starting from the root node:1: Recursively traverse left sub-tree2: Recursively traverse right sub-tree3: Read/print current node
",
"Which of the following code snippets would correctly remove the nthelement, n, of a doubly-linked list?
","n.prev.next = n.next;n.prev = n.prev.prev;n.next = n.next.next;n.next.prev = n.prev;
","n.prev = n.next;n.next = n.prev;
","n.prev.next = n.next;n.next.prev = n.prev;
","n.prev.next = n.next.prev;n.next.prev = n.prev.next;
","System.out.println(""Remove "" + n.toString());
","The first line will ensure the previous node now skips over node n and points forward straight to the next node after it.The second line ensures the next node after n now points backwards to the previous node (again, skipping over n).
",
"Which of the following sorting algorithm is stable and has average time complexity of nlog(n)
","Selection
","Insertion
","Merge
","Heap
","Bubble
","Week 7a 2019 slide 5
",
"Assume that we have a perfect skip list (as described in 2019 coursework 2 Q3... ""every element is linked to the next, even numbered elements are also linked to the one 2 ahead, elements whose number is divisible by 4 are also linked to the one 4 ahead, and so on by powers of 2."").The skip list contains 32768 elements. How many elements have at least 11 lanes?
","15
","31
","16
","32
","11
","The number of elements with n lanes is given by:So for at least 11 lanes we need to find the number of elements with 11,12,13,14 and 15 lanes.
",
"For the above tree, what is the outcome for in-order traversal?
","10, 7, 14, 3, 8, 13, 17, 16, 18
","3, 7, 8, 10, 13, 14, 16, 17, 18
","10, 7, 3, 8, 14, 13, 17, 16, 18
","3, 8 , 7, 13, 16, 18, 17, 14, 10
",,"In-order traversal will process the nodes in the left tree, then it will process the node and finally it will process the nodes in the right tree (Slide 22 Week7b 2019).A is level-orderC is pre-orderD is post-order
",
"A binary tree has a depth of 6, it is full on all levels except for the bottom. The bottom level contains 4 nodes, how many nodes are there in the tree?
","63
","59
","67
","64
","68
","For simplicity, find the amount of nodes in the tree for all levels excluding the bottom one. This gives a complete tree with a depth of 5. The tree has 2^(5+1) - 1 = 63 nodes (from the formula on slide 11 of Week7b 2019). We simply add the 4 from the bottom level to get 63 + 4 = 67 nodes in total.
",
"Which of the following statements are true?
","When two items are mapped to the same index of an Open Hash Table will discard the replace the previous item with the most recently added item.
","When searching an Open Hash Table the algorithm will start at the lowest index and continue to the next index until it finds the correct item, which will be returned.
","When adding a value to an Open Hash Table the current index is already in use the algorithm will add it to the end of a linked list associated with that index.
","When removing an item from an Open Hash Table if the correct item is not found in the initial index, the algorithm will repeatedly move to the next index in the table until the item is found and hence removed.
","None of the above.
","an open hash table uses linked lists to solve collisions by adding each item to the end of the linked list.options A) and B) are not features of Hash Tablesoption D) describes removing in a closed Hash Table
",
"What is the time complexity of the following extract of code?System.out.println(""Hello world"");for(int i = 0; i < n; i++){ System.out.println(""Test"");}for(int j = 0; j < n; j++){ System.out.println(""Test"");}
","O(1 + 2n)
","O(n)
","O(1)
","O(1 + n + n)
","None of the above
","2019 Week1b-Powerpointv2
",
"Given the above binary tree, which type of traversal should be carried out to obtain the output2, 5, 11, 6, 7, 4, 9, 5, 2?
","Level-Order Traversal
","In-Order Traversal
","Pre-Order Traversal
","Post-Order Traversal
",,"2019 Lecture 13, slide 24
",
"for an algorithm operating on n items and a runtime of?(n2) when n's size quadruples, by how much will T change? (denoted by T')
","T' = 8T
","T' = T1/2
","T' = 16T
","T' = T
",,"n increases by a factor of 4 leading to T increasing by a factor of 42= 16
",
"Which one of the following defines a complete binary tree?
","A binary tree with an odd number of nodes and every non-leaf node has exactly two children
","A binary tree with a prime number of nodes and in which every leaf node has the same depth
","A binary tree in which every leaf node has the same depth and every non-leaf node has exactly two children
","A binary tree with an even number of nodes and every non-leaf node has exactly two children
",,"2019 Lecture 13, slide 11
",
"If we cube the adjacency matrix of a directed graph, what should happen?
","The adjacency matrix is an identity matrix so should be the same as the adjacency matrix.
","The resulting matrix should show all the matrices that are 2 arcs apart from each other.
","The resulting matrix should show all the matrices that are 3 arcs apart from each other.
","The resulting matrix should show all the matrices that are 3 arcs apart from each other (including all the combinations that are 1 apart from each other, as you can just traverse the same arc back again).
","The resulting matrix shows all the nodes that can be reached by travelling along arcs of length 3.
","If the graph had the adjacency matrix of an identity matrix, all points would point at themselves, so it wouldn't be directed and it wouldn't be a graph. However, as the adjacency matrix shows all the nodes that can be reached by an arc, cubing the graph has the property of showing the nodes that can be reached by 3 arcs. Note that not all arcs have to be of unit length, so E is discounted, and as this is a directed graph, then not all combinations of length 1 can be returned to. Sorry for the slightly trick question :)
",
"Which sorting method has a best average case for n=2 (and all n greater than 2) out of the following options?
","Shell Sort
","Insertion Sort
","Selection Sort
","Merge Sort
",,"Selection and insertion sort both have an average case ofT(n^2), which is a lot slower thanT(n^1.25) of shell sort. However it can be seen that this is slower than theT(n log(n)) of merge sort, as n^0.25 scales faster than log(n)and (for n starting at 1) starts off at 1 rather than negative infinity. Merge sort takes the same amount of time as insertion sort for n=1 as they are the same program.
",
"What is the best, average and worst case complexity for insertion sort?
","O(n)O(n)O(n2)
","O(n)O(n2)O(n2)
","O(n/2)O(n)O(n2)
","O(n2)O(n2)O(n2)
",,"Week 7a slide 5
",
"Which out of these types of sorts is stable?
","Merge Sort
","Shell Sort
","Quick Sort
","Heap Sort
",,"Microsoft PowerPoint - D&A-Revision2.pptx, slide 24
",
"Which method of tree traversal is used to display the elements starting at the root of the tree, and making its way down to the leaves of the tree, one level at a time?
","Post-order traversal
","Breadth first traversal
","In-order traversal
","Pre-order traversal
",,"Breadth first traversal makes sure not to descend a level of the tree until all the possible points of the level have been displayed, with the levels further down being called recursively afterwards. The 4 traversal methods can be described by marking each node of the tree with 4 dots on each side of the node (top, bottom,left,right) and by drawing a line around the outside of the entire tree. While breadth- first just requires you to look from the root down and to record the node when the top dot is reached, the others can be described by their relationship to the surrounding line. Pre-order requires you to follow the line anticlockwise starting at the root , and to write down when the line goes past the left dot of the node. In-order and post-order are the same for the bottom and right dots respectively. Breadth first traversal is useful for trees with the same value multiple times in the same tree, as you can use breadth first search to see which instance is the least levels down the tree.
",
"What is the maximum height of a perfectly balanced tree with n nodes?
","n log (n)
","log(n)
","en
","log(n2)
",,"Stated on Week8b, slide 3
",
"For the following piece of Java code, select the worst case runtime from the options given.N.B. You can assume that printing a string to console takes constant time.public static void function (int N) { for (int i = 1; i < N; i++) { for (int j = 1; j < N; j = j * 2) { System.out.println(""hello world""); } }}
","O(logN)
","O()
","O(NlogN)
","O()
","None of the above.
","First you should notice that there are nested for loops which are both bounded by N and start at 1.The outer for loop increments by the addition of 1 to i each iteration, while the inner for loop increments by the multiplication of j by 2 each iteration.Therefore:Outer for loop: O(N) iterationsInner for loop: O(logN) iterations- Why?- If we say k is equal to the number of iterations of the inner for loop, then N = - If we take logs of both sides, we are left with k = log NMultiplying together since they are nested for loops, gives you the following answer:O(NlogN)
",
"What option has the correct definitions of each of the following:leafComplete (Full) Binary treeBinary tree
","leaf - A node with 2 childrenComplete (Full) Binary tree - Every leaf node has the same depth, Every leaf node has exactly two childrenBinary tree - A tree where every node has at most two children
","leaf - A node with only 1 childComplete (Full) Binary tree - Every leaf node has a different depth, Every leaf node has exactly two childrenBinary tree - A tree where every node has at least two children
","leaf - A node with 0 childrenComplete (Full) Binary tree - Every leaf node has the same depth, Every non-leaf has exactly two childrenBinary tree - A tree where every node has at most two children
","leaf - A node with more than one childComplete (Full) Binary tree -Every leaf node has the same depth, Every leaf has more than one childBinary tree - A tree where every node has at least one child
","leaf - A node with 0 childrenComplete (Full) Binary tree -Every leaf node has the same depth, Every non-leaf has exactly two childrenBinary tree - A tree where every node has at least one child
","leaf - A node with 0 childrenComplete (Full) Binary tree - Every leaf node has the same depth, Every non-leaf has exactly two childrenBinary tree - A tree where every node has at most two children
",
"which of these options is in the order of:pre-order TraversalIn-order TraversalPost-order Traversal
","1. Process the nodes in the left sub-tree2. Process the Current node3. Process the nodes in the right sub-tree1. Process the nodes in the left sub-tree2. Process the nodes in the right sub-tree3. Process the current node1. Process the current node2. Process the nodes in the left sub-tree3. process the nodes in the right sub-tree
","1. Process the nodes in the left sub-tree2. Process the nodes in the right sub-tree3. Process the current node1. Process the current node2. Process the nodes in the left sub-tree3. process the nodes in the right sub-tree1. Process the nodes in the left sub-tree2. Process the Current node3. Process the nodes in the right sub-tree
","1. Process the nodes in the left sub-tree2. Process the nodes in the right sub-tree3. Process the current node1. Process the nodes in the left sub-tree2. Process the Current node3. Process the nodes in the right sub-tree1. Process the current node2. Process the nodes in the left sub-tree3. process the nodes in the right sub-tree
","1. Process the current node2. Process the nodes in the left sub-tree3. process the nodes in the right sub-tree1. Process the nodes in the left sub-tree2. Process the Current node3. Process the nodes in the right sub-tree1. Process the nodes in the left sub-tree2. Process the nodes in the right sub-tree3. Process the current node
","1. Process the current node2. Process the nodes in the left sub-tree3. process the nodes in the right sub-tree1. Process the nodes in the left sub-tree2. Process the nodes in the right sub-tree3. Process the current node1. Process the nodes in the left sub-tree2. Process the Current node3. Process the nodes in the right sub-tree
","Pre-order Traversal1. Process the current node2. Process the nodes in the left sub-tree3. process the nodes in the right sub-treeIn-order Traversal1. Process the nodes in the left sub-tree2. Process the Current node3. Process the nodes in the right sub-treePost-order Traversal1. Process the nodes in the left sub-tree2. Process the nodes in the right sub-tree3. Process the current node
",
"Order the following Big O runtimes from largest to smallest:O(log n), O(1), O(n log n), O(n), O(), O()
","O(log n), O(1), O(n log n), O(n), O(), O()
","O(), O(),O(n), O(n log n), O(log n), O(1)
","O(1), O(log n), O(n), O(n log n), O(), O()
","O(), O(), O(n log n), O(n), O(log n), O(1)
","None of the above.
","Take care to read the question carefully:Order the following Big O runtimes from largest to smallest.>> n log n > n > log n > 1
",
"If the closed hash table with linear probing has a load factor of 0.30, what is the average number of steps to insert/find an item.
","~1.05
","~1.12
","~1.21
","~1.3
","~1.5
","For a closed Hash table with linear probingAverage number of steps = 1/2(1+1/(1-L)) for L < 1.0(1-L) - % empty spacefor a open hash tableAverage number of steps = 1 + L/2
",
"What is the correct recurrence relation for merge sort (when N, the number of elements of the list being sorted, is greater than 1 and a positive power of 2 for simplicity)?
","T(N) = T(N/2) + O(1)
","T(N) = T(N/2) + O(N)
","T(N) = 2T(N/2) + O(N)
","T(N) = 2T(N/2) + O(1)
","None of the above
","If the length of the list, N, is equal to 1, then the list is sorted so merge sort just returns the list: T(1) = O(1) (this is the base case).Otherwise, merge sort splits the list into two equal halves (since the number of elements is a positive power of 2) and then recursively sorts each half: 2 * T(N/2)Then the two sorted halves are merged where the runtime of the merge operation is O(N) where N is the number of elements being merged.Therefore the correct answer is: T(N) = 2T(N/2) + O(N)
",
"What order would the nodes in the following tree be visited in, when carrying out a level-order traversal?
","5, 4, 2, 1, 3, 6, 11, 22
","5, 4, 6, 2, 3, 11, 22, 1
","1, 2, 4, 3, 5, 6, 11, 22
","None of the above
",,"2019 Week7b-Tree1Visit each of the nodes reading left to right on each level, starting at the root.
",
"What is the best, average and worst case complexity of selection sort?
","
","
","
","
","None of the above.
","2019 Week 7a Slide 5
",
"Consider a closed hash table with linear probing. If there is a load factor of .10, what is the average number of steps?
","~1.12
","~1.05
","~1.21
","~1.47
",,"The calculation for average number of steps is�(1+ 1/(1-L)), where if L is replaced with 0.10, then the result is ~1.05.
",
"Perform Dijkstra's algorithm on the following graph with starting vertex A.What will be outputted?
","A one dimensional array with values: 0, 5, 3, 2
","A one dimensional array with values: 5, 3, 2
","A two dimensional array with values: A, B, C, D 0, 5, 3, 2
","A one dimensional array with values: 0, 6, 3, 2
",,"Dijkstra's algorithmdetermines shortest paths from a start vertex s to all other vertices in graph.We can see that the shortest path of from A to A is 0, from A to B is 5, from A to C is 3 and from A to D is 2.From Week 10 Lecture A we can see that the output of Dijkstra's algorithm is a single 1D array containing the shortest distance from the start vertex to every other vertex in the graph. Hence why answer A is correct.
",
"What is the input and output of Dijkstra's algorithm?
","Input: A graph Gand starting vertex sOutput: array called Dist of optimal distances from s to every node in graph.
","Input: An array Aand starting vertex s and nodes containing weight N.Output: array called Dist of optimal distances from s to every node in graph.
","Input: A graph Gand starting vertex sOutput: Array called Dist of optimal distances from s to every node in graph and and the weights of each node
","Input: A graph Gand end vertex eOutput: Array called Dist of optimal distances to e from every node in graph.
",,"This is taken from the slides in week 10 lecture A.Graph is a graph where different vertices have different weights (prices) to get to them.The Dist array returned is an array which will contain the elements that have the best possible price to get to each vertex.S is the vertex where the weights to get to the other vertices is calculated from.
",
"What is the formal definition of 'Big-Omega' , for a positive function f(n)?
","A function g(n) equalsO(f(n)) if and only if there are constants c>0 and n0>0 so that for all n>n0, g(n)= cf(n).
","A function g(n) equals O(f(n)) if and only if there are constants c>0 and n0>0 so that for all n>n0, g(n) = cf(n).
","A function g(n) equals O(f(n)) if and only if there are constants c1>0 and c2>0 and n0>0so that for all n>n0, g(n) = c1 f(n) and g(n) = c2 f(n).
","The exact bound of a function f(n), where the order of complexity of f(n) is exactly O(f(n)).
","None of the above.
","See 2019 Week2b Powerpoint Slide 5 for formal definitions.
",
"Assume you are deleting an element (called 'node') from the middle of a doubly-linked list equipped with prev and next references. Which of the following lines of code would correctly delete the element in the list?
","node = null; node.prev.next = node.next; node.next.prev = node.prev;
","node.prev.next = node.next; node.prev = null; node.next = null; node.next.prev = node.prev;
","node.prev.next = node.next; node.next.prev = node.prev;
","node.next = node.next.next; node.prev = node.prev.prev; node = null;
","None of the above.
","As the node is in the middle of the list, two references have to be reassigned; the next reference from the previous element and the prev reference from the next element.The references of the node in question do not have to be reassigned, as the node is no longer going to be accessed.See: 2019 Week3b Linked Lists Slides.
",
"If we have a binary tree which represents a mathematical expression - where the operands are contained in leaf nodes and the operator nodes all have two children (see below for example) - what type of traversal algorithm should be used to evaluate the expression?
","Pre-order
","In-order
","Post-order
","Level-order
",,"Any expressions in the left and right sub-trees must be evaluated first, before the operation in the current node can be applied. This is an example of post-order traversal (see 2019 Week 7b-Trees 1 slides).
",
"Class for an AVL tree node is given below:class AVLNode { int value; int balance; AVLNode left, right;};In this AVL tree node, what does the balance value of 1, 0 and -1 indicate?
","� 1 = node balance on the right subtree is one higher than on the left.� 0 =node balance on the left and on the right subtree are the same.� -1 = node balance on the left subtree is one higher than on the right.
","� 1 = node balance on the left subtree is one higher than on the right.� 0 = node balance on the left and on the right subtree are the same.� -1 = node balance on the right subtree is one higher than on the left.
","� 1 =node balance on the left and on the right subtree are the same.� 0 =node balance on the left subtree is one higher than on the right.� -1 = node balance on the right subtree is one higher than on the left.
","� 1 = node balance on the right subtree is one higher than on the left.� 0 = node balance on the left subtree is one higher than on the right.� -1 = node balance on the left and on the right subtree are the same.
",,"This is taken from the powerpoint slides from Week 8 Lecture B called Trees 3.The balance of nodes in an AVL tree indicates whether the tree needs to be rebalanced to the left or to the right.The balance is calculated via the subtracting the height of the right subtree with the height of the left subtree.Below is an example of a balanced tree. The balance value of each node is shown.Example Tree: Node-1 Node-1 balance = 1 / \ Node-2 balance = 0Node-2 Node-3 Node-3 balance = 0 / \ Node-4 balance = 0 Node-4 Node-5 Node-5 balance = 0
",
"Three types of search that we can use to find an element in an ordered set of data are binary search, interpolation search and linear search. What are their complexities?
","Binary Search is?(n), Interpolation Search is?(log(n)),Linear Search is?(n)
","Binary Search is ?(log(n)), Interpolation Search is ?(n), Linear Search is ?(n)
","Binary Search is ?(log(n)), Interpolation Search is ?(log(log(n))), Linear Search is ?(n)
","Binary Search is ?(log(n)), Interpolation Search is ?(log(n)), Linear Search is ?(n)
","None of the above
","See slides 5-10 in lecture week2a.
",
"Santa was trying to mathematically speed up his delivery times, so he made a graph (graph A) where the vertices were houses and two houses had an edge between them if they were on the same street. He also decided to make a graph (graph B) to monitor friendships between his elves so he could best choose which elves would get each other for the factory Secret Santa that year; however, he found it to be nearly pointless, as although he has 1000 elves working for him, almost all of them are friends with each other! In this graph each elf is a vertex and they have an edge drawn between each other if they are friends.To respresent each graph, should Santa use an adjacency matrix or an adjacency list?? Hurry up, he has to start preparing for Christmas 2020 ASAP!!
","Matrix for Graph A, List for Graph B
","Matric for Graph A, Matrix for Graph B
","List for Graph A, List for Graph B
","List for Graph A, Matrix for Graph B
",,"In graph A, there are billions of vertices, each of which is not likely to be connected to more than a hundred others. A matrix would store way too much data, most of which wouldn't be used! An adjacency list would be a much more suitable option.In graph B, almost all vertices are connected, so although a list and a matrix would store a similar amount of data (roughly 1000x1000), a matrix would be much less complicated. The amount of data to store is not too much.
",
"Which of the following algorithms is stable?
","Merge sort
","Heap sort
","Selection sort
","Shell sort
","Quick sort
","A stable algorithm is one where keys of the same value remain in the same order after sorting.
",
"Given the AVL tree:When the value of 12 is inserted, which rotation is required in order to balance the tree?
","Left rotation
","Left-right rotation
","Right rotation
","Right-left rotation
","No rotation required
","The value of 12 is initially inserted into the tree as the left node of 14, meaning the tree is unbalanced.Then, traversing the tree from the node that was inserted, updating the heights and checking balance factors, it is found at value 11, it is not balanced. Therefore, a rotation of some kind needs to take place.Since the since the right node of 11 has the value on its left, a right rotation must occur. However, once this is complete the tree is still unbalanced, so a left rotation must occur.
",
"The following is code for a Node for a particular ADT. Which ADT is it?class Node{ public Object element; public Node[ ] next; public Node(Object o){ element = o; next = new Node[5]; }}
","Linked List of length 5
","Doubly-Linked List of length 5
","Binary Search Tree of depth 5
","Skip List with 5 lanes
","AVL Tree of depth 5
","In a skip list, there are different lanes; hence the 'next' property is an array of nodes rather than just one node, as the ith node in the array follows from the current node in the ith lane. Binary Search Trees and AVL Trees also point to multiple nodes, but these are commonly programmed as the 'left' and 'right' properties.
",
"Using the hash function h(x) = x%5, insert the elements 31, 60, 7, 46, 73, 82, 9, 57, 23, 92, 28 into an open hash table with slots 0,...,4. Which of the following options shows the third element of the longest list after the insertions?
","82
","28
","57
","46
","None of the above
","Using the method shown in slide 24 of the week 10b hash table powerpoint, the hash table becomes:6031, 467, 82, 57, 9273, 23, 289So the slot corresponding to 2 is the longest and its third element is 57.
",
"What is the�Time complexity� of an algorithm (T(n))?
","The total time taken for the algorithm to finish (using, for example, a stopwatch).
","The time taken for the algorithm to finish excluding stoppage time (e.g. the algorithm being halted due to another process being scheduled).
","The number of instructions used by an algorithm as a function of the size of the input data.
","The average time taken for many hundreds/thousands of runs of the algorithm.
",,"We cannot consider the time complexity to be a set time as there are many factors that must be taken into account such as, how many CPU cores does the processor have, is multi threading enabled, are there any other processes running at this time, what is the clock speed of the processor and much more.We therefore consider time complexity as a function of the size of the input data. This way we can generalize the complexity of the algorithm to all processors and applications and it allows the algorithm to be directly compared to another algorithm.We calculate the time complexity by determiningthe number of elementary operations an algorithm performs.
",
"When considering Big-O notation, if |f(n)| = B|g(n)| ? n = bthen we say that...
","f is of order at most g, writtenf(n) ? O(g(n))
","f is of order at least g, writtenf(n) ? O(g(n))
","planation: So as n gets large, if the function f(n) remains smaller than some function B(g(n)) then we say that f(n) ? O(g(n)) because Big-O is an upper bound, i.e. f(n)will never have order greater than O(g(n)).
","gs: Complexity
",,,"tristan (tr548)
"
"In which case are all of the following sorting algorithms stable?
","Shell sort, insertion sort, bubble sort
","Heap sort, merge sort, quick sort
","Shell sort, quick sort, insertion sort
","Selection sort, insertion sort, bubble sort
",,"see slide 5 of week 7(a) powerpoint
",
"What does it mean for an algorithm X to be asymptotically more efficient than another algorithm Y
","X is a better choice for all inputs
","X is a better choice for large inputs
","Y is a better choice for large inputs
","X is a better choice for small inputs
",,"definitions of time complexity (for all b>=B)
",
"What is mean by binary trees are identical?
","When the binary trees are structurally identical and have different value in the nodes.
","When the binary trees are structurally identical and have same value in the nodes.
","When the binary trees are structurally different and have different value in the nodes.
","When the binary trees are structurally different and have same value in the nodes.
","All the binary trees are identical.
","Tree 1 Tree 2 10 10 2 4 2 41 5 6 8 1 5 6 8
",
"Choose the correct steps of insertion sorting on the array below: 7 6 2 5 1
","6 7 2 5 12 6 7 5 12 5 6 7 11 2 5 6 7
","2 7 6 5 12 6 7 5 12 5 6 7 11 2 5 6 7
","1 6 7 2 51 2 6 7 51 2 5 6 71 2 5 6 7
","7 6 2 1 57 6 1 2 57 1 2 5 61 2 5 6 7
","6 2 5 1 72 5 1 6 72 1 5 6 71 2 5 6 7
","In insertion sort, it should start sorting with first 2 elements and ignore the rest. After sorted the first 2 elements, focus on the first 3 elements and sort it. Then, continue with the next elements until the last.
","min (mjt65)
"
"Choose the correct steps of insertion sorting on the array below: 7 6 2 5 1
","6 7 2 5 12 6 7 5 12 5 6 7 11 2 5 6 7
","2 7 6 5 12 6 7 5 12 5 6 7 11 2 5 6 7
","1 6 7 2 51 2 6 7 51 2 5 6 71 2 5 6 7
","7 6 2 1 57 6 1 2 57 1 2 5 61 2 5 6 7
","6 2 5 1 72 5 1 6 72 1 5 6 71 2 5 6 7
","In insertion sort, it should start sorting with first 2 elements and ignore the rest. After sorted the first 2 elements, focus on the first 3 elements and sort it. Then, continue with the next elements until the last.
","min (mjt65)
"
"What is the in-order traversal of the tree seen below? 8 / \ 6 9 / \ \ 2 7 15 /1
","8, 6, 9, 2, 7, 15, 1
","8, 6, 2, 1, 7, 9, 15
","1, 2, 6, 7, 8, 15, 9
","1, 2, 7, 6, 15, 9, 8
","None of the above
","A shows level order traversalB shows pre-order traversalC shows in-order traversalD shows post-order traversalSlides: Week7b-Trees1 slides 15, 22, 24 & 26
",
"f(n) = 2, g(n) = 56 log(n), h(n) = 17n log(n)Which of the following statements is correct?
","g is O(f), h is (g), f is (h)
","g is O(f), g is O(h), f is (h)
","g is (f), f is O(g), f is (h)
","f is (g), g is (h), f is O(h)
","None of the above are correct
","Very similar but just different numbers to Q3 of the 2017-18 exam from two years ago.
",
"When creating a new hashtable, why should we create it such that it has a prime number of buckets?I.e. we should only create hashtables w/ a prime number of buckets, for example 2021 buckets rather than 2000.
","Harder for hackers to obtain access to our hashtable
","Ensures fewer collisions and more even distribution of values
","Reduces the load factor of a hashtable
","Guarantees the hashtable will not need to be resized
","Easier for us to encrypt the data in our hashtable
","Using prime numbers ensures fewer collisions and more even distributions. slide 35 Week 10b
",
"What is the experimental time complexity of shell sort?
","
","
","
","
",,"Lecture 11 - Sorting 2, previous year's lecturer's slides. Slide 8 (not on the slide but in the comments).The worst case is n^2, but there is no theoretical average case.
",
"If N = 91, and k 1 mod 72, then mod N.What is the value of ?
","x = 1
","x = N - 1
","x = 14
","x = mod N
","x = mod N
","Rivest�Shamir�Adleman (RSA) Corollary from Lecture 11b.N =pq, where p and q are distinct primes (p=7,q=13)k 1 mod((p-1)(q-1)) = 1 mod(6.12) = 1 mod 72Hence the Corollary states = mod N, so our answer is C) x = 14
",
"Take the input array: [49, 42, 67, 85, 23, 56, 34, 15]. After one iteration of h-sorting (the underlying operation in Shellsort) with h = 4, what is the resulting array?
","[42, 34, 23, 15, 85, 67, 56, 49]
","[23, 42, 34, 15, 49, 56, 67, 85]
","[15, 23, 34, 42, 49, 56, 67, 85]
","[49, 23, 56, 34, 15, 67, 85, 42]
","[49, 42, 23, 56, 34, 15, 67, 85]
","Applying h-sorting as specified in 2019 Week5a PowerPoint Slides 3-6 to the array.
",
"An closed hash table of length 10 is used with hash function h(k)=k%10, and linear probing. After inserting 6 values into an empty hash table, the table is as shown below.012 423 234 345 526 467 3389In what order where the values inserted?
","46, 42, 34, 52, 33, 23
","34, 46, 23, 52, 33, 42
","46, 34, 42, 23, 52, 33
","42, 34, 23, 33, 46, 52
","none of the above
","In the first one the numbers would be ordered in the following way 42 52 34 33 46 23in the second one, they would be ordered as 52 23 34 33 46 42and in the last one, 42 23 34 33 52 46only one that works is CBecause it's a closed hash table, when the key we want to put a number in is full, we have to look for the next empty one
",
"In a weighted, undirected graph if we apply Dijkstra's algorithm and then we add 1 to all the edge weights, does the shortest path remain the same?
","yes
","no
","planation: it depends on the number of nodes in the path. For example:a-b-c-fl-------l (a-f also connected), with a-b=5, b-c=2, c-f=3 and a-f=11the shortest path before adding 1 to all nodes is a-b-c-f (total of 10) but after adding 1 to all nodes it becomes a-f (12<13)
","gs: Applications, Graphs
",,,"cg853 (cg853)
"
"Supposeis the adjacency matrix representing a graph. Which of the following is the matrix representing vertices that areedges apart, whereis a natural number?
","
","
","
","
","
","From 2019 Lecture 17 slides 10 and 11,would tell us the vertices that are 2 edges apart andwould tell us which vertices are 3 edges apart. Thereforetells us the vertices which areedges apart.
",
"You find yourself volunteering at the local library during the holidays to pad out your CV.Each day, people take books from shelves and put them back in the wrong place, out of order.You're asked to ensure that all books are sorted after the library closes each day, but this takesages and you need to get home to revise. You decide to use a sorting algorithm to speed things up.You make the following observations:There are thousands of books in the library but only a small number of them are misplaced each day.People tend to put books back close to where they were taken from.Given these observations, which of the following algorithms would be most efficient?
","Merge sort.
","Selection sort.
","Insertion sort.
","Quick sort.
",,"The important observation is that the books are almost sorted since people put them back close to where they were taken from.The following complexities can be found in Week 7a, slide 5.Merge sort has complexity for all cases. It also requires working space which would make a mess of the library floor.Selection sort has complexity for all cases.Insertion sort has best-case complexity. The best case for insertion sort is when the list is almost sorted, which is one of our observations.Quick sort has complexity for all cases.
",
"What is the best case time complexity for the following code snippet:public static void sort(int[]array) { for(int i = 0; i<array.length-1; i++) { int min = array[I]; int minIndex = I; for(int j = i+1; j<array.length;j++) { if(array[j]<min) { min = array[j]; minIndex = j; } } int temp = array[minIndex]; array[minIndex] = array[I]; array[i] = temp; }}
","O(n2)
","O(n)
","O(n+m)
","O(n*logm)
","O(n*m)
","This code is the sorting algorithm for selection sort. The complexity of selection sort in the best, average and worst case isO(n2).For more information about selection sort: Week 4a-post 2019 slides 6 to 8.
",
"What is the best, average and worst case for a bubble sort?
","Best:T(n)Average:T(n/2)Worst:T(n^2)
","Best: T(n)Average: T(n)Worst: T(n^2)
","Best: T(n)Average: T(n^2)Worst: T(n^2)
","Best: T(n^2)Average: T(n^2)Worst: T(n^2)
",,"Refer to Week 7a slide 5.
",
"Consider the following adjacency matrix representing a directed graph. Using the methods in lecture 17 - Graphs 1, find the nodes that are exactly two edges apart.
","Mary -> CamFred -> TomFred -> JoshTom -> CamJosh -> TomCam -> FredCam -> Josh
","Mary -> JoshMary -> FredFred -> CamFred -> TomTom -> JoshTom -> FredJosh -> CamCam -> JoshCam -> Tom
","Mary -> TomMary -> JoshFred -> FredFred -> JoshFred -> CamTom -> TomTom -> JoshJosh -> FredJosh -> JoshCam -> TomCam -> Cam
","Mary -> JoshMary -> FredMary -> TomFred -> TomTom -> JoshTom -> FredJosh -> TomCam -> JoshCam -> Tom
",,"Refer to lecture 17 - Graphs 1 Slide 11. You have to multiply the matrix by itself to find the adjacency matrix representing all nodes exactly two edges apart. Then, translate the matrix to the appropriate nodes. Answer A is the same graph as before. Answer C is nodes exactly three edges apart. Answer D is random nodes.
",
"Below this paragraph is a diagram of tree; A / \ B C / \D EConsidering with the list of values, describe how 'Post-order' search / traversal is done by showing what the output would be for this search / traversal method:
","A, B, D, E, C
","D, B, E, A, C
","D, E, B, C, A
","D, E, B, A, C
","D, B, E, C, A
","D, E, B, C, A - This is 'Post order' traversalD, B, E, A, C - This is 'In order' traversalA, B, D, E, C - This is 'Pre order' traversalD,E,B,A,C and D,B,E,C,A are not any form of searching or traversal!
",
"Regarding Hash Tables, which of the followingstatements is false?
","The efficiency of a hash table can depend upon the type, how full the table is and how many collisions you have in the table
","It takes on averageO(1) for the following operations to be performed in an Hash Table; inserting, finding and remove elements (If the load factor is limited)
","Open Hash Tableshandle collisions by inserting objects to the next sequentially available index.
","Hash Tables need to be sized in accordance to limit the load factor
","None of the above
","It takes on average O(1) for all operations to be performed in an Hash Table. It can take O(n) operations, if you were considering the worst case for a Hash Table.Open Hash Tables handles collisions by adding values to the end of the list. Closed Hash Tables handle collisions by inserting objects to the next sequentially available index.Hash Tables need to be sized for the load factor because it is calculated by the number of values you intend to add, divided by the number of buckets in the array.
",
"Consider a list and the operations that can be performed on it. If you wanted to retrieve a value'get' from an index/node in a list, which of the following does not take an average of O(n) operations?
","An Array List
","A Linked List
","Linked List and Array List
","Neither
",,"An Array List does not take O(n) operations on average. This is given to other list structures like aLinked List that can consist of this Big O. On the other hand, anArray List has an average case of O(1) operations.This is apparent as the Array List would simply have to search up the index that is being requested to retrieve the value. Compared to the Linked List, this has to search the index that would contain another index in a node, thus following this path 'n' times to eventually retrieve the value from a node in the list, wherever in the list that may be.
",
"Which of these statements is true of passwords?
","Always store passwords as they are when the user types them.
","Store the hash of a password instead of the password itself.
","When hashing passwords your own version of a hash function is always best to use
","MD5 is a more secure hashing algorithm than SHA-3
",,"A is false because you should never store passwords in clear as it makes it vulnerable to attacks.B is true because storing the hash means even if the database is hacked the hacker can't see the actual password and is very hard to reverse engineerC is false because your own version wont be as secure as the ones that have been tested.D is false as MD5 is an algorithm that was popular in 1990 and has vulnerabilities and SHA-3 is currently the most secure one
",
"What is the best time complexity for sorting a sorted list using selection sort?
","O(n)
","O(Log n)
","O(n2)
","O(1)
","O(n log n)
","Selection sort has worst, best and average time complexity of O(n2) because it runs through the whole list multiple times whether the list is sorted or not
",
"What is the equation to calculate the average number of steps required for Closed hashing.
","= 1/2(1+1/(1-L))
","= 1 + L/2
","planation: for explanation take a look at ""2019 week10b slide 31""
","gs: Hashtables
",,,"mn585 (mn585)
"
"What is the average case time complexity of insertion sort?
","
","
","
","
","
","Best case for insertion sort is, however worst case and average case is.
",
"A company wants to store 10,000 values in a closed hash table using linear probing to find values.To be fast enough, they require values to be found in no more than three steps of linear probing on average.What is the minimum number of buckets that should be used for the closed hash table for this condition to be met?
","10,000 buckets
","12,500 buckets
","15,000 buckets
","17,500 buckets
","20,000 buckets
","We can calculate the average number of steps linear probing will take based on the load factor using this expression: (2019 week 10b, slide 31)Since we know the average number of steps, three, we can rearrange this function to find the required load factor : where n is the average number of steps. Evaluating this gives .The company wants to insert 10,000 values, so we can work out how big the hash table should be using .
",
"Consider a Closed Hash Table with a Fixed size. Which of the following approaches is NOT a viable way of deleting entries?(Sorry CL.)
","Remove the desired elementGo to the next bucketIf the bucket is empty, quitIf the bucket is full, delete the element in that bucket and re-add it to the hash table using the normal means. The item must be removed before re-adding, because it is likely that the item could be added back into its original spot.Repeat step 2.
","Remove the desired elementFill the bucket with a ""Dummy"" element that has a special ""empty"" value.When searching/inserting, skip over this element as if it was a real element.
","Remove the desired elementFlag the empty bucket.When searching, skip over flagged bucketsWhen inserting treat flagged elements like empty buckets and remove flag at the end of insertion
","In the case of removing many items from the hash table.Create a new Hash table with only the elements you wish to keep, ommiting the ones you wish to delete.
",,"In a Fixed size hash table, if you chose the method outlined by B, you will run out of space as spaces will be taken up by the Dummy elements.The sildes in 10b said CL doesn't recommend looking into this but JHD was going to more in Week11. I didn't go to Week 11 and can't see anything about it in the notes. Please let comment if you think it is an irrelevent question. Thanks!
",
"which tree traversal does the following order of operations:1_ Process the node in the left sub-tree2_ Process the node in the right sub-tree3_ Process the current node
","In-Order Traversal
","Post-Order Traversal
","Pre-Order Traversal
","Level order traversal
",,"For more information check week 7b slides
",
"Which of the following is a False statement for Shell Sort?
","It is based on H-sort
","The last step is always a Bubble sort
","Worst case worst gap sequence complexity is O(n^2)
","Shell sort is a ""stable"" sort.
",,"See Week 5a powerpoint.Shell sort is not stable as elements can ""jump"" over elements with the same value
",
"Which of the following inputs makes mergesort in ascending order perform the largest numberof comparisons?
","2,1,4,3
","1,2,3,4
","3,4,1,2
","3,1,2,4
",,"D -Takes one more comparison compared to the rest.
",
"Consider the following AVL tree:After inserting the value 7, what sequence of rotations would be required to rebalance the tree?(The subtrees at which rotations are applied are left unspecified)
","Left rotation.
","Right rotation.
","A left rotation, then a right rotation.
","A right rotation, then a left rotation.
","No rotations required.
","The value 7 would be inserted as 6's right child. This causes 8 to have a balance factor of -2, meaning its left subtree is two nodes higher than its right subtree (which is empty). The 8 subtree must be rebalanced.We cannot perform any left rotations at node 8 because it has no right child to take its place.A right rotation at 8 gives the following tree, which is symmetrically as unbalanced as before:To properly balance the tree, we must first perform a left rotation at node 6 followed by a right rotation at node 8, as shown in the following two trees:The final tree is now balanced (node 4 has a balance factor of 1, node 7 has a balance factor of 0).
",
"Let p and q be primes such that p*q = N and p != q.If (p-1)(q-1) = 36What is N?
","N = 3
","N = 56
","N = 57
","N = 70
","N = 30
","p = 3 and q = 19 so 3*19 = 57
",
"This adjacency matrix shows who is friends with who.Which node has the most friends?
","1
","2
","3
","4
","None
","Node 1: has 2 friendsNode 2: has 1 friendNode 3: has 0 friendsNode 4: has 1 friend
",
"What doesSystem.currentTimeMillis() measure?
","The number of secondssince 1 Jan 1970.
","The number of milliseconds since 1 Jan 1970.
","The number of nanoseconds in this Java Virtual Machine since whenever.
","The number of seconds since 1 Jan 2000.
","The number of milliseconds since 1 Jan 2000.
","Solution: Week 1(b) Slide 2 2019
",
"What is 413 mod 7?
","0
","1
","2
","4
","5
","Application of Fermat's Little Theorem 2019 Lectures - Week 11b - Slide 12. p = 7, k = 1 mod 6, x = 4.
",
"Which is a better way to represent a graph (in terms of memory storage) if you had lots of edges but few vertices?
","Adjacency list
","Adjacency matrix
","planation: Powerpoint: ""graphs1TF"" - Slide 17
","gs: Graphs
",,,"lm889 (lm889)
"
"A certain quadratic time algorithm uses 4 elementary operations to process an input of size 10.What is the most likely number of elementary operations it will use if given an input of size100?
","40
","400
","4000
","4
",,"Since the time algorithm is quadratic and you have increase the input size by 10. The number of elemtary operations is multiplied by 10^2 = 100. Thus, 4 * 100 = 400.
",
"An algorithm has runtime T(n)=n^2+ n^3+ 55n+108 + 0.0025n^5 for input of size n. Whatis the asymptotic time complexity of this algorithm?
","O(n^4)
","?(n^5)
","O(n^2)
","?(n^3)
",,"The greatest power in the time complexity is n^5.
",
"What are the leaves of a perfectly balanced binary tree when you enter numbers in order: 10,8,6,2,11,100,7
","2,6,11,100
","2,7,11,100
","2,8,10,100
","2,7,10,100
",,"Root = 8Children of 8 = 6 11Children of 6 = 2 7Children of 11 = 10 100Therefore leaves are 2,7,10,100
",
"Consider the following skip list. If we were to insert a node with value ""Cameron"" which has 4 lanes and insert a node with value ""Diego"" which has 2 lanes. What does the skip list look like now?
","
","
","
","
",,"Refer to lecture week 3b slide 17. ""Cameron"" comes between Barry and Derek alphabetically and has 4 lanes so must have four elements in its pointer array. ""Diego"" comes between Derek and Edgar alphabetically and has two lanes so must have two elements in its pointer array. The number of lanes for other nodes must stay the same.
",
"Suppose you have an AVL tree storing elements in alphabetical order.Out of the following binary tree traversals, which will output the tree elements in alphabetical order?
","Pre-order traversal
","In-order traversal
","Post-order traversal
","Level-order/Breadth-first traversal
",,"For each node in the tree, in-order traversal first processes the nodes in the left sub-tree (less than the current node), then the current node, then finally the nodes in the right sub-tree (greater than the current node).
",
"Which matrix represents the nodes which can be traversed to in 2 steps on the following graph?
","
","
","
","
",,"C is the adjacency matrix. Multiplying it by itself gives those nodes that are 2 paths apart (answer A), with the number '2' representing 2 different ways of getting from one node to another in 2 steps.B shows the nodes 3 steps apart (multiplying the adjacency matrix by itself 3 times gives this result)D shows the correct matrix but with the '2's replaced by '1's
",
"Place the following algorithms in order of most to least efficient when dealing with around 10,000 items:A: Bubble sortB: Quick sortC: Bucket sortConsider the average case complexities.
","ABC
","CBA
","BAC
","ACB
","BCA
","Bubble sort: O(n2)Quick sort: O(nlogn)Bucket sort: O(n + k), where k is the number of bucketsInterestingly, will much more data, 'clustering' can occur, meaning that many items are put into the same bucket and thus can take longer, hence the specified amount of data.https://smartbear.com/blog/develop/bucket-sort-vs-quick-sort-which-is-faster-aqtime-b/ is an interesting read :)
",
"Here is some code given in lectures:What line will need to go at X to print the time taken for MyClass.m() to run?
","System.out.println(end);
","System.out.println(end-start);
","System.out.println(start)
","System.nanoTime();
","System.out.println(System.nanoTime());
","See slide 4 week 1b
",
"Is the following tree a valid AVL tree?
","Yes
","No
","planation: Although the root node is balanced, its children are not.
","gs: Trees
",,,"moi21 (moi21)
"
"Given the incomplete Java code for the classes DoublyLinkedList and ListNode2:class ListNode2 { Object element; ListNode2 prev = null; ListNode2 next = null;ListNode2(Object e, ListNode2 p, ListNode2 n) { element = e; prev = p; next = n;}}class DoublyLinkedList { private ListNode2 head = null; private ListNode2 tail = null; private int n = 0;//other methods from DoublyLinkedList commented outpublic void insert(Object o, int i) { if (i < 0 || i > n) { System.out.println(""i value out of bounds""); }ListNode2 node = head; for (int j = 0; j < i - 1; j++) { node = node.next; }node.next = new ListNode2(o, node, node.next);Xif (i == n) { tail = node.next;}n++;}The insert method is used to insert object o in doubly linked list at ith position as seen in coursework 2. Which code must go at the place marked with X for the method to work correctly?
","if (node.next.next != null) {node.next.next.prev=node.next;}
","if (node.next.next != null) {node.next.prev=node.next;}
","if (node.next.prev != null) {node.next.next.prev=node.next;}
","nothing
",,"We need to make sur node.next.next is not null in order to adjust node.next.next.prev, making the list go both ways
",
"Given the following numbers 58, 4, 102, 13, 27, 99, 1, arrange them in a complete balanced binary search tree. Which of the following is the preordered traversal of the tree?
","27,4,1,13,99,58,102
","1,4,13,27,58,99,102
","27,4,99,1,13,58,102
","27,99,102,58,4,13,1
","none of the above
","pre-order traversal consists of processing the current node's value out, then processing to nodes in left subtree and then processing the nodes in the right subtree.
",
"Which of the following statements from a to d about array lists is FALSE? If none of them is false, choose option e.
","There exists an index i anywhere in the array list such that removing at that index takes a complexity of .
","The worst case to insert an element anywhere in a non-full array list without resizing takes a time complexity of O(log n).
","The worst case of removing an element from the array list is always slower than to get an element in the same list.
","Array lists are an example of ADT.
","None of the statements above is false.
","The worst case to insertan element anywhere in a non-full array list without resizing takes .
",
"What is the worst case run time complexity of selection sort?
","O(n^3)
","O(nlog(n^2))
","O(nlog(n))
","O(n^2)
","O(nlog(log(log(n^5))))
","All cases of selection sort are O(n^2)
",
"In a real world application when would you use a linked list over an array list?
","When every you are going to be inserting into the middle of the list no matter the size of the list
","When every you are going to be inserting into the middle of the list and the list is small
","When every you are going to be inserting into the middle of the list and the list is large
","If the list requires frequent access to items in the centre of the list
","When the order of items in the list does not matter
","For most applications an array list will be the way to go even if insertion into the centre of the list is frequent. This is because a lot of programming languages have blazing fast array copying operations such as java's System.arraycopy. This means the overhead from iteration over the list in a linked list is not outweighed by cost of copying the array in an array list for most cases. For this reason a list has to be large before any performance benefit can be noticed when using a linked list over an array list and inserting into the middle.
",
"Finish the sentence correctly:An AVL tree is a ...
","a tree which is balanced and is a height balanced tree
","immutable object once initialised
","a tree which is unbalanced and is a height balanced tree
","a tree with each node having atmost 3 children
",,"An AVL tree is a self balancing binary tree with height difference of at most 1.
",
"Which of the following statements about linked lists is true?
","Linked list lets you add an element at the start of the array with cost ?(1)
","inserting elements anywhere between the head and the tail of the linked list requires every element to be shifted by 1 on the right
","linked lists support random access for every element with index i
","removing elements anywhere between the head and the tail of the linked list requires every element to be shifted by 1 on the left
",,"For reference check week 3b slides.
",
"Which of the following statement is not true?
","If an array has been recently sorted, insertion sort will have ?(n)
","Stooge sort is faster than Merge sort
","Selection sort is not a stable sorting algorithm
","If an array has been already sorted and the pivot chosen is the first element of the array, Quick sort will have?(n^2)
","Whatever is the case, the runtime of selection sort will be?(n^2)
","For more information, check week 4b/8 and the other slides regarding sorting
",
"In the worst case scenario, what is the big-o of insertion sort?
","T(N^3)
","T(N)
","T(N^2)
","T(NlogN)
",,"Refer to week 4a ppt slide 16 for more info
",
"Consider the following binary tree, which of the following traversal is true? 15 / \ 7 19 / \ / \ 6 8 16 21
","Preorder: 6,7,8, 15, 16,19,21.Postorder: 15,7,6,8,19,16,21.Inorder: 6,8,7,16,21,19,15.
","Preorder: 15,7,6,8,19,16,21.Postorder: 6,7,8, 15, 16,19,21.Inorder: 6,8,7,16,21,19,15.
","Preorder: 6,8,7,16,21,19,15.Postorder: 15,7,6,8,19,16,21.Inorder: 6,7,8, 15, 16,19,21.
","Preorder: 15,7,6,8,19,16,21.Postorder: 6,8,7,16,21,19,15.Inorder: 6,7,8, 15, 16,19,21.
","None of the above.
","Lecture note week7b trees orhttps://www.tutorialspoint.com/data_structures_algorithms/tree_traversal.htm
",
"Linked List vs Array List comparison.Which of the following is false?
","It is faster to remove an item from the middle of a linked list than from the middle of an array.
","It is faster to insert a new item at the front of a linked list than an array.
","It is faster to get to the 700th item in an array than linked list.
","None of the above is wrong.
",,"The answer is D because none of the above is wrong.A is correct because we can just change the reference of the nodes to remove the node containing the item to be removed in a few steps, while we have to remove the item in an array, then shift all the following items left one slot.B is correct because we can once again insert a new item at the front of the linked list by changing the references to the items, while we have to shift all the n items in an array right one slot.C is correct because we can get to any item in an array in 1 step, while we have to pass through 699th nodes to reach the 700th node in a list.
",
"Find the Bound Challenge! (What is the average run time of the function below)int count = 0;void foo(){ for (int i = 0; i <n; i++) for(int j = 0; j < 100*n; j++) for(int k = 0; k < n*m; k++) count++}
","
","
","
","
","None of the above.
","Lecture noteWeek2b-Powerpointon moodle page 22,23. (Find the Bound challenge)First for loop has runtime nSecond for loop has runtime 100nThird for loop has runtime n*mHence we get the average time complexity
",
"A user on Stack Overflow has asked you to fudge his coursework to work.His assignment is to make a class, with a method that reverses an array.He gave you the incomplete code in Java.Which code would you suggest him to put instead of a? for the method to work?
","
","
","
","
",,"Function reverse takes the array as a parameter.Inside the function, a new array (size of the original array) is initialised. The original array is iterated from the first element (i = 0) and each element of it(i < n; i++) is placed in the new array, starting from the back.
",
"Honda vs Lamborghini pt 4if you haven't answered part 1-3 of this question please do so first:part 1: https://peerwise.cs.auckland.ac.nz/course/main.php?cmd=answerQuestion&id=4250213part 2: https://peerwise.cs.auckland.ac.nz/course/main.php?cmd=answerQuestion&id=4250257part 3: https://peerwise.cs.auckland.ac.nz/course/main.php?cmd=answerQuestion&id=4250259Having received information and payment from a client about a new target the hitman must now attempt to kill his target. The target is having a press conference about their recent success. Looking at his route (lengths given in minutes) and using Djikstra's shortest path algorithm, what is the minimum time it will take him to get from his home at C to the conference at E?
","8
","9
","5
","6
","4
","The shortest path is C>A>B>E so the minimum time needed is 5 minutes
",
"Honda vs Lamborghini pt 3if you havent answered part 1 or two of this question please do so first:part 1: https://peerwise.cs.auckland.ac.nz/course/main.php?cmd=answerQuestion&id=4250213part 2: https://peerwise.cs.auckland.ac.nz/course/main.php?cmd=answerQuestion&id=4250257Having decided on the hitman with the best value for money they now need to communicate with him. But they need to use a cypher to do so. They decide to use a Ceasar shift with key 8. Code the following message to send to the hitman:CEO OF HONDA
","NPZ ZQ SZYOL
","KBW WN PWAWL
","KMW WN PWVLI
","KMW HY AHGWT
",,"The Ceasar shift cypher shifts each letter by a key. In this examble the key is 8 so A -> I and B -> J and so on.
",
"Honda Vs Lamborghini pt 2if you haven't answered part 1 of this question please use the following linkhttps://peerwise.cs.auckland.ac.nz/course/main.php?cmd=answerQuestion&id=4250213As the year draws to a close, Honda is set to beat Lamborghini in profits due to their new method of storing ID numbers of vehicles! This is quite embarrassing for Lamborghini so the board of directors meet to discuss how they can beat Honda. After their meeting, they come to the conclusion they have no other choice but to assassinate the CEO. They download the TOR browser and navigate the dark web to a hitman site. Each hitman listed has a price, a time-frame and a success rate. They decide on a formula to decide which hitman has the best value and then sort them using the following steps:1) pick the first hitman2) Go along the list and put all the worse hitmen in one group and the better in another group3) In this better group they repeat the process. They then repeat this process in the worse group4) They then concatenate the two sorted groups into one sorted listWhat algorithm did they use?
","Merge Sort
","Bubble Sort
","Quick Sort
","Insertion Sort
",,"Quicksort chooses a pivot (in this case the first element) and then categorises the rest of the elements into two groups of worse and better than the pivot. This method is called recursively on the two groups until you have two sorted lists which can then be concatenated
",
"Which of the following sorting algorithms has its best case time complexity (for n elements), to be the same as the time complexity of tree traversal methods (for a tree of n nodes)?
","Quick sort
","Merge sort
","Selection sort
","Insertion sort
",,"See 2019 weeks 7a at page 5 for reference to all sorting algorithms, along with their average and worst case scenarios for time complexity as well.Moodle: ""Week7a.pdf""See 2019 Week 7b at page 29 for the big-Oh of traversals' reference.Moodle: ""Week7b-Trees1.pptx""
","quadristavrioverde (sk2285)
"
"Which of the following sorting algorithms has its best case time complexity (for n elements), to be the same as the time complexity of tree traversal methods (for a tree of n nodes)?
","Quick sort
","Merge sort
","Selection sort
","Insertion sort
",,"See 2019 weeks 7a at page 5 for reference to all sorting algorithms, along with their average and worst case scenarios for time complexity as well.Moodle: ""Week7a.pdf""See 2019 Week 7b at page 29 for the big-Oh of traversals' reference.Moodle: ""Week7b-Trees1.pptx""
","quadristavrioverde (sk2285)
"
"Suppose you have the following AVL tree:Select the correct order in which the following 3 tree traversal ways are displayed: i) A > B > D > E > C > F > Gii) D > B > E > A > F > C > Giii) D > E > B > F > G > C > A
","i) in-orderii) pre-orderiii) post-order
","i) post-orderii) in-orderiii) pre-order
","i) pre-orderii) in-orderiii) post-order
","i) pre-orderii) level-orderiii) post-order
","i) post-orderii) level-orderiii) pre-order
","The definitions for each traversal order method are:Pre-order:1. Process the current node.2. Process the nodes in the left  sub-tree.3. Process the nodes in the right  sub-tree.In-order:1. Process the nodes in the left sub-tree.2. Process the current node.3. Process the nodes in the right sub-tree.Post-order:1. Process the nodes in the left sub-tree.2. Process the nodes in the right sub-tree.3. Process the current node.For further information regarding Binary Tree Traversals see 2019 Week7b between pages 14-28See .pptx file from moodle: ""Week7b-Trees1.pptx""
",
"In data structures and algorithms, we use various sorting algorithms to sorta data. Depending on various factors, we might choose a different algorithm.Which of the following, appropriately and formally defines the term""Sorting"" for a sorting algorithm?
","It is the process of replacing items with other items, depending on whether they are smaller or bigger in value.
","It is the process of ordering a bunch of items based on one (or more) rules, subject to one (or more) constraints.
","It is the process of re-ordering items one by one in a list, subject to one (or more) constraints.
","It is the process of ordering a bunch of items based on one (or more) rules.
",,"The definition of Sorting is given in the set of slides 2019 week4b on page 2. It is followed by the definitions of items, rules and constraints, individually.See PDF file on moodle: ""Week4b-post.pdf""
",
"An AVL Tree is made containing 35 nodes. What is the minimum height of the tree
","33
","5
","6
","24
","no minimum
","As all nodes have maximum of two child nodes each. The minimum height of the tree is (log2(33)) rounded up which is 6
",
"The run times for a sorting algorithm, for a list size and time taken in seconds , are as follows: = 420, = 69 = 840, = 1104 = 1680, = 17664What is the run time complexity of the algorithm?
","
","
","
","
","
","When doubles, the time taken, , is increased by a factor of , which is .
",
"Before working at the University of Bath, while working in Honda, Dr. Tom Finch created a binary tree about one of Honda's competitors.When delivering the Power Point presentation, the tree on the projector looked like this:He also passed round some handouts, with his comments and text explaining some of the aspects of the presentation.But to be more environmentally friendly, he decided to save some paper, and print the tree in one line:He was later asked:""Which tree traversal algorithm did you use on the binary tree to get this output?""What was his reply?
","In-order
","Pre-order
","Post-order
","Level-order
","Breadth First
","Week 7b slides from Moodle_____________________________________________________P.S. He later realised that he should have kept the tree as it was...
",
"Starting with an empty circular buffer of size 7 that allows overwriting:1) Insert: 4 then 1 then 9 then 23) Call Remove twice4) Insert: 3 then 1 then 1 then 8 then 3If I were to print the elements of the buffer in order from the start, what would be printed?
","4, 1, 9, 2, 3, 1, 1, 8, 3
","4, 1, 3, 1, 1, 8, 3
","9, 2, 3, 1, 1, 8, 3
","3, 1, 1, 8, 3, 4, 1
",,"Initially, we insert [4, 1, 9, 2] which go in order. Then when calling remove the oldest two elements are removed so now the buffer looks like [9, 2] with the start point being shifted to the position that 9 is in. We now insert 5 more elements 3, 1, 1, 8, 3 which all go in order so the final buffer is C
",
"By constructing the adjacency matrix of the graph below (with rows/columns arranged alphabetically), which of the following matrices describes vertices which are three edges apart?
","
","
","
","
",,"The adjacency matrix isIn general, computing Antells us which vertices are n edges apart.Here, A3gives us the result in (C).See Lecture17 - Graphs1 slides 7-11
",
"Insert the arrayinto a Self-BalancingBinary Search Tree. What is the output if you perform a Level-Order Traversal on the tree?
","1,2,3,4,5,6,7,8
","4,2,6,1,3,5,7,8
","4,6,2,7,5,3,1,8
","4,2,1,3,6,5,7,8
","None of the above
","Using the definition of a BST (as given in 2019 W8a Slide 4 of the lecture slides), the tree has the following structure:Root: 4Level 1: 2,6Level 2: 1,3,5,7Level 3: 8So our output is 4,2,6,1,3,5,7,8.Performing the wrong traversal may give one of the other choices, as will incorrectly applying the definition of a BST.
",
"Which statement best describes what happens when you sort an array, arr, of length n during one pass of aShell (k-)Sort(assuming k<n)?
","Shell's areoften shown as an illustration of the golden ratio,,in nature, similarly to the Fibonacci Numbers. As a result we do the following:1) Find the largest Fibonacci number smaller than n, call this ""r""2) Create a temporary array made up of arr at unique indices of the Fibonacci sequence (e.g. arr[0], arr[1], arr[2], arr[3], arr[5], arr[8], ... ,arr[r])3) Sort the temporary array.4) Update the values of arr at the indices of the Fibonacci numbers based on the sorted temporary array.5) Traverse the array backwards to create a second temporary array (e.g. arr[n], arr[n-1], arr[n-2], arr[n-3], arr[n-5], arr[n-8], ... ,arr[n-r])6) Sort the temporary array7) Update the values of arr at the indices {n - Fibonacci numbers} based on the sorted temporary array.8) Increase the index of the elements we're sorting by k and repeat
","1) Split the array into ""shells"" of length k2) Sort the shells3) Sum the total value of each shell4) Re-order the shells based off of their total shell value and concatenate the arrays back together5) Repeat
","1) Compare elements arr[0] and arr[k]2) Swap if arr[k] is smaller3) Compare arr[1] and arr[k+1]4) Swap if arr[k+1] is smaller and so on5) If we performed a swap before reaching the end of the array, repeat. Otherwise we're done.
","1) Sort the firstelements2) Sort the lastelements3) Repeat
","Shell Sort does not exist
","(c) is the only feasible sorting algorithm. Donald Shell invented Shell sort and shells have no correspondence with the workings of the algorithm - (a) and (b) are completely made up. (d) is somewhat similar to Stooge sort, (with 3=k) but again is made up. A google search will quite quickly allow you to deduce (e) is false.See the 2019 Week 5a .ppt file for the explanation of shell sort.
",
"Which of these sorting is best suited for recently sorted data?
","Merge sort
","Selection sort
","Quick sort
","Insertion sort
",,"Insertion sort works by placing the last element in a sub-array into a correct position after the rest of the sub-array has already been sorted. If the original array is sorted, the last element of a sub-array is already in its' correct place, eliminating the need to move it somewhere else. Thus, only n comparisons are required for a sorted array (or list).
",
"Given the following binary tree, which method of tree traversal would result in the output:a b d c e f
","In-order traversal
","Pre-order traversal
","Post-order traversal
","Level-order traversal
",,"Pre-order traverses in the following way:Processes the current node (starting at the root)Processes nodes in left sub-treeProcesses nodes in right sub-treeRefer to Week7b slides 14-28 for details.
",
"How do you calculate steps to search for/insert an element in an OPEN hash table with load factor L?
","1 + (L/3)^2
","1 + L/2
","1 + L
","1 + (L/2)^2
",,"Naturally this value is dependent on the effectiveness of your hashing algorithm and the size of the array 2019 Lecture 10b Slides 32,33
",
"Which of the following sorting algorithms is NOT stable?An algorithm is stable if it retains the order of equal elements.Ie: if x = y and x comes before y in the unsorted list, then x will come before y in the sorted list.
","Selection Sort
","Quick Sort
","Bubble Sort
","Insertion Sort
","Merge Sort
","There is a 50/50 chance that the order of two equal elements will swap order during quick sort. This depends on what pivot is chosen. In the rest of the algorithms, the order will be preserved
",
"What is the difference between precision and accuracy?
","Precision is the ability of the measurement system to detect and faithfully indicate small changes in the characteristic measurement result.Accuracy iss how close measurements are to the true value.
","Precision is how close measurements are to the true value. Accuracy is how close measurements are to each other.
","There is no difference between them.
","Precision is how close measurements are to each other. Accuracy is how close measurements are to the true value.
",,"The definitions of precision and accuracy can be found in week 1b-powerpoint v2 slide 8 2019.
",
"An algorithm has a runtime, for input size n, of T(n)=10000n4+0.075n2+0.091n+102500.What is the asymptotic time complexity of this algorithm?
","O(n5)
","?(n3)
","O(n3)
","?(n4)
","None of the others
","From lectures 2019 week1a slides 14,15, we can define the asymptotic time complexity of this algorithm, and show it is?(n4).T(n)? O(n4): for b=1 and B= 10001. Eg for 1=n, T(n)=10001n4T(n)? ?(n4): for a=1 and A= 10000. Eg for 1=n, 10000n4 = T(n)Therefore T(n)? T(n4), and our answer is D.
",
"An algorithmhas time complexity. Using the Definition of Big-Oh as given in the 2019 Week 1a Lecture (slide 14), fix B = 5.Assuming, what is the lowest possible value ofb for which the definition holds?
","
","
","
","
","
","You need to solve for the roots of |T(N)| = | 5N2|. Then you need to find the range of values for which 5N3 outgrows T(N).You should obtain the roots in answers (a), (c), (d) and (e) (and a further 2 roots). Using the definition it is clear that we must pick b=10, as all other selections of b allows you to pick an n, (e.g n=9) where the definition does not hold.
",
"A phone network provider wishes to store the mobile numbers for their customers (a large amount of people). The application needs to be able to add and remove new mobile numbers quickly, for when a customer joins or leaves the provider, and the company wants to be able to determine quickly whether an individual with a specific name is a customer, and be able to retrieve their phone number. Which data structure would be MOST appropriate to store the phone numbers in memory?
","Linked List
","Closed hashtable
","Open hashtable
","Sorted ArrayList
","Sorted Array
","We know the answer must be either B or C, because for large data sets hashtables are the most efficient to store data (is in O(1) steps, rather than O(N or logN), lecture 2019 week10b slide3), and the best way to access specific unsorted data like these mobile numbers will be. It can be shown the open hashtable (answer C) is the most suitable, because it's runtime is quicker than a closed hastable (lecture 2019 week10b slide33), and due to each bucket being a linked list, it is really easy to delete a value compared to a closed hashtable- just removing it from the linked list (lecture 2019 week10b slide 26).
",
"Suppose that you are an employee in the sales department at a large car manufacturing company, (i.e. Honda). Your boss has tasked you with reducing the cost of transporting new cars to dealerships from the factory, in order to maximise profits.Below is a graph with the costs associated with delivering a single car to dealerships from other locations, our factory is at location A. Using Djikstra's Algorithm, calculate the cheapest costs to deliver to each dealership from our factory at A.
","B = 7C = 9D = 22E = 26F = 11
","B = 7C = 9D = 22E = 20F = 14
","B = 7C = 9D = 20E = 20F = 14
","B = 7C = 9D = 20E = 20F = 11
","B = 7C = 9D = 20E = 26F = 11
","D is the correct answer. Djikstra's Algorithm was covered in the lecture named shortest_path on Moodle.
",
"An array is provided with the following numbers: {16, 87, 54, 98, 61, 33, 74}. If a perfectly balanced binary search tree is constructed from this array, which number will be in the root node?
","16
","61
","54
","74
","None of the others
","From lecture 2019 week7b slide 6. Using the numbers within the array, aperfectly balanced binary search tree will be created as below: 61 / \ 33 87 / \ / \16 54 74 98From this. it is clear the root node is 61 (answer B), because it is the value at the start(top) of the tree, and using this as the root node makes the tree balanced.
",
"Which of these functions has the lowest growth rate?
","n
","nlog(n)
","log(n)
","n2
","2n
","2019 Lectures - Week2b - Lecture 4 - Complexity 2 - Slide 12. A list of functions with ascending growth rate is given.
",
"In what order are the vertices 'settled' whenDijkstra�s Algorithm is applied to the below graph to determine the lengths of the shortest paths from A to all other vertices?
","A B C D E F
","A C F B D E
","A C E D F B
","E D B F C A
","C B F D E A
","2019 Lectures - Lecture 18 - Graphs 2 - Slide 6 - Currently saved on Moodle as shortest_path.pdf. The starting vertex A is settled first with a length of 0. Lengths to B and C are noted as 10 and 2 respectively. A to C has the shortest length so C is settled next with a length of 2. Length of ACF is noted as 4. ACB is shorter than AB so length A to B is updated to 5. A to F is the next shortest length so F is settled with a length of 4. Length of ACFD is noted as 6. A to B is the next shortest length so B is settled with a length of 5. Length of ACBE is noted as 8. Length of A to D is the next shortest length so D is settled with a length of 6. Length of A to E is the next shortest length so E is settled with a length of 8.
",
"Which of the following searching algorithms performs the best giving that we have as much memory as needed and we apply them to the most appropiate data structures.
","Linear search
","Binary search
","Binary tree search
","Hash search
",,"Hash search can be O(1) depending on how good the hash function is.
",
"Which of the following BSTs is not a valid AVL Tree?
","A
","B
","C
","D
","E
","2019 Lecture Slides - Week 8a - Trees 2 - Slide 30 - An AVL tree is a BST in which the heights of the left and right sub-trees of each node differ at most by 1. The root node in tree D has a left sub-tree of height 2 and a right sub-tree of height 0 so the difference is 2.
",
"The picture below shows a balanced AVL Tree.If I were to insert 10 (or '0010') into the tree. What will the balanced AVL Tree look like after?
","
","
","
","
","
","W8(b) Trees3 is the lecture where AVL Trees were covered.Below is a pic of the tree with weightings:Now when we insert 10 (or '0010') it is a child of '0009', which means that the node at '0006' becomes unbalanced and hence rotates. This means that '0007' becomes a child of '0006', and '0008' becomes the child of the root '0004'. After this rotation, the tree is balanced and hence there is no more rotations, leaving the AVL Tree as:This leaves us with B being the correct answer. (https://www.cs.usfca.edu/~galles/visualization/AVLtree.html could be useful to visualise this)
",
"Which one of the following sorting algorithms, is a non-comparison sorting algorithm?
","Counting Sort
","Heap Sort
","Shell Sort
","Selection Sort
","Stooge Sort
","W7(a) slide 8/16 states that Counting Sort is a non-comparison sorting algorithm. The other 4 mentioned all make use of comparisons in their sorting algorithms.
",
"Which one of the following hash functions is the current reccomendation?
","MD5
","SHA-1
","SHA-3
","SHA-224
","SHA-2
","SHA-3 (also known as Keccak), is the current reccomendation. SHA-2/SHA-224 has also not yet been cracked yet, but is considered to be less secure (easier to crack).W11(a)post slide 17/21
",
"Which of the following sorting algorithms, uses h-sorting as part of its alogorithm?
","Selection Sort
","Heap Sort
","Insertion Sort
","Shell Sort
","Merge Sort
","W5(a) Powerpoint on Shell Sort. Slides 4-6 explain how h-sorting works.
",
"What is the time complexity of Tree traversal Methods in a binary tree?i.e. Pre-Order, Post-Order etc
","(log2n)
","(n2)
","(n)
","(n log2n)
","(log22n)
","W7(b) Trees1 slide 29
",
"For the following binary tree, which tree traversal method would print the following output?Output : d e b f g c a
","Preorder Traversal
","Post-Order Traversal
","In-Order Traversal
","Level-Order Traversal
",,"w7b Trees1 slides 14-26
",
"Which of these is not a requirement for a good cryptographic hash?
","Pre-image resistance
","Collision resistance
","Second collision resistance
","Second pre-image resistance
",,"2019 Week 11a slide 16
",
"Consider this question on cryptography: To ensure Eve doesn't replace Alice's public key with her own, what can Alice do?
","Make her public key private
","Release fake keys to disguise the original key
","Encrypt the key
","Have her public key signed by a Certificate Authority
","Get rid of Eve.
","Lecture 20 - Cryptography, slide 12.
",
"What is the RSA encryption system based on?
","The presumed difficulty of discrete logarithms
","The presumed difficulty of finding Mersenne primes
","The presumed difficulty offactoring large integers
","The presumed difficulty of integrating trigonometric functions
","The presumed difficulty of finding the circumference of the sun given half a dozen apples cost �3.20
","A) This is actually the basis of the ElGamal encryption systemB) Not a basis for an encryption system (that I am aware of)C) RSAD) Sorry for the use of 'presumed', integrating trig functions is difficult, but not a basis of an encryption systemE) Apples are expensive these days :(
",
"Running a 7-sort (Shellsorting) followed by a 4-sort and then a 2-sort on the following array [10,5,7,11,15,3,4,9] will give which of the following arrays.
","[9,3,4,10,15,5,7,11]
","[4,3,9,7,10,5,11,15]
","[3,5,4,9,7,10,15,11]
","[4,3,7,5,9,10,15,11]
","[5,7,3,4,9,11,10,15]
","7-sort: [9,5,7,11,15,3,4,10]4-sort: [9,3,4,10,15,5,7,11]2-sort: [4,3,9,5,7,10,15,11]2-sort second pass: [4,3,7,5,9,10,15,11]For more details see lecture Sorting 2 (Shell sort)
",
"When is quick sort (ascending) not of O(nlogn) complexity?
","When running the algorithm on a slow computer
","When the data type of the elements is a string
","When the data is in a random order
","When the data is entered in descending order
","When it's a Wednesday
","A) The speed of the computer will not effect complexity, only total time run. It still has the same number of elementary operations.B) Should not effect time complexityC) When the data is in a random order then that is the best time that it will run with O(nlogn)D) If the data is sorted into descending order we will have O(n2) complexity, much like bubble sortE) The day of the week does not affect time complexity (I hope.)
",
"This is a closed hash table that uses linear probing:[7,4,3,5, ,11, , ,12, , , , ]This is the hashing algorithm it uses: h(x) = (x2- 7x) % 13If we were to remove 4, would our hash table break?
","No, it will work fine.
","Yes, it's broken.
","planation: Look at 3, if we were to put that into our hashing algorithm: 32-7*3 = 9-21 = -12 =1 mod 13. If we were to remove 4 & then look at position 1 to find 3, we would find an empty space and our probe will stop, so despite 3 being in the hash table, we can't find it. Thus our hash table is broken.
","gs: Hashtables
",,,"nmparrott (nmp31 - permission to this course revoked)
"
"Using the formula we were taught in lectures, what is the average number of steps it will take to find an element in this closed hash table using linear probing? And, how many steps will it take to find '4' if we use this hashing algorithm?Hash Table:[ , , , ,12,1,4,7]Hashing Algorithm:(x2-4) % 8(Hint: Hash table has 8 total buckets)
","Average number of steps: 5/6Number of steps to find '4': 2
","Average number of steps: 5/6Number of steps to find '4': 3
","Average number of steps: 1.5Number of steps to find '4': 2
","Average number of steps: 1.5Number of steps to find '4': 3
","Average number of steps: 11/6Number of steps to find '4': 1
","L = 4/8 = 1/2This is a closed hash table so to calculate the average number of steps we use: 0.5(1+1/(1-L))This gives us 3/2.Inserting 4 into the hashing algorithm we get 42-4 % 8 = 4So we look at bucket 4 in the hash table which is occupied by 12, so we go to the next one, which contains 1, and so we go to the next one which contains 4. That was 3 steps.
",
"Which of the following procedures describes ElGamal public key cryptography?
","Key Generation1. Bob generates multiplicative cycle group G with generator g.2. Bob chooses a random exponent x in {0, ..., |G| - 1}3. Bob publishes G, g and g^xEncryption1. Alice gets Bob's public key: G, g and g^y2. Alice chooses a random exponent y in {0, ..., |G| - 1} and her message m3. Alice computes and sends g^x, m*g^xyDecryption1. Bob computes g^xy = g^yx2. Bob computes m = (m*g^xy)*(g^xy)^-1
","Key Generation1. Bob generates multiplicative cycle group G with generator g.2. Bob chooses a random exponent x in {0, ..., |G| - 1}3. Bob publishes G, g and m*g^xEncryption1. Alice gets Bob's public key: G, g and g^x2. Alice chooses a random exponent y in {0, ..., |G| - 1} and her message m3. Alice computes and sends g^y, m*g^xyDecryption1. Bob computes g^xy = g^yx2. Bob computes m = (m*g^xy)*(g^xy)
","Key Generation1. Bob generates multiplicative cycle group G with generator g.2. Bob chooses a random exponent x in {0, ..., |G| - 1}3. Bob publishes G, g and g^xEncryption1. Alice gets Bob's public key: G, g and g^x2. Alice chooses a random exponent y in {0, ..., |G| - 1} and her message m3. Alice computes and sends g^y, m*g^xyDecryption1. Bob computes g^xy = g^yx2. Bob computes m = (m*g^xy)*(g^xy)^-1
","Key Generation1. Bob generates multiplicative cycle group G with generator g.2. Bob chooses a random exponent x in {0, ..., g}3. Bob publishes G, g and g^xEncryption1. Alice gets Bob's public key: G, g and g^x2. Alice chooses a random exponent y in {0, ..., |G| - 1} and her message m3. Alice computes and sends g^y, m*g^xyDecryption1. Bob computes g^xy = g^yx2. Bob computes m = (m*g^xy)*(g^xy)^-1
",,"From lec 10 slides 7 - 9.
",
"Which of these options is NOT properties of minimum spanning tree?
","sum of the weights of all the edgesis minimum among all the spanning trees
","The tree is always unique
","Reaches out to (spans) all vertices.
","can be applied with Prim�s Algorithm
",,"MST is not necessarily uniqueLecture 19 Graph3
",
"What does recursion do?
","calls function itself one or more times until a specified condition is met
","input will be used again after the function executed
","acts as infinite loop to operate on continuous application
","None of these correct
",,"It is a programming technique involving the use of a procedure, subroutine, function, or algorithm that calls itself one or more times until a specified condition is met at which time the rest of each repetition is processed from the last one called to the firstreferencehttps://www.merriam-webster.com/dictionary/recursion
",
"Which of the following is NOT an advantage of using a singly Linked List instead of an array?
","Can easily expand and contract size
","Faster insertion of new elements
","Faster deletion of elements
","Allows Random access
",,"Linked Lists do not allow Random Access, only sequential access.
",
"Which of the following statements about AVL trees is NOT true?
","Every node in an AVL has at most two children
","For any node, all nodes in its left sub-treemust be strictly less than the node�s value.
","For any node, all nodes in its right sub-treemust be strictly greater than the node�s value.
","The heights of the left and right sub-trees of each node differ at most by 1
","The balance value of a node is zero if the node's left and right sub-trees have the same height
","For any node, all nodes in its right sub-treemust be greater than (OR equal to) the node�s value.
",
"In an average BST with n values, how many steps are typically required to find a value?
","?(n logn)
","?(n)
","?(n2)
","?(logn)
",,"Source: DA Lecture 14 Trees 2
",
"Which sorting algorithms are stable?
","Shellsort, Quicksort, Bubblesort
","Mergesort, Bubblesort, Insertionsort
","Selectionsort, Heapsort, Insertionsort
","Bubblesort, Shellsort, Heapsort
",,"Shellsort, Quicksort, Heapsort and Selectionsort are unstable
",
"According to thethe following source code file StringRepeater.java:There are four statements about this code:(1). Theformula for the elementary operationsin this code is T(n)= 4+4n.(2). For big n, the complexity class of this code is O(n^2).(3).To measure the runtime of this code, we can test this code in 500 times or more, and average the running time to get a fairly precise runtime.(4).Changing the type of the input and output as StringBuffer, and change the loop code ""result.append(s)"" can reduce the runtime of the code.Which of the following statements are true?
","(1)(3)
","(2)(3)
","(1)(3)(4)
","(2)(3)(4)
","(1)(2)(3)(4)
","Based on the PS1, question 2,3:(1). Not True, the operation ""result + s"" in the code has a special runtime (not just 1 elementary operation, since the type is string)(2).True, by the measurement of this test, we can observe the runtime hasa quadratic growing trend.(3). True, by lecture 4, averaging the measurements canquantify accuracy.(4). True, as PS1 test, this is better than the previous code.
",
"Two or more pieces of code running simultaneously are known as what?
","Processes
","Processors
","Branches
","Threads
","Leaves
","Threads are 2 or more pieces of code running simultaneously, processes are two or more programs running at the same time.
",
"Suppose you have the following hash table, implemented using linear probing, and that the hash function we are using is the function, h(x) = x mod 9.0 1 2 3 4 5 6 7 8 [hash ids]9 18 12 3 14 4 21 [elements entered]Which of the following are orders in which the elements could have been added to the table:(i) 9, 14, 4, 18, 12, 3, 21(ii) 12, 3, 14, 18, 4, 9, 21(iii) 12, 14, 3, 9, 4, 18, 21(iv) 9, 12, 14, 3, 4, 21, 18(v) 12, 9, 18, 3, 14, 21, 4 ?
","(iii) only
","(iii) and (iv)
","(i) and (v)
","(iv) only
","None of the above
","In (i), 4 would be inserted at index 4 instead of 6.In (ii), 18 would be inserted at index 0 instead of 1.In (v), 21 would be inserted at index 6 instead of 7.
",
"When should you use an adjacency matrix rather than an adjacency list?
","Lots of edges and lots of vertices
","Lots of edges and few vertices
","Few edges and few vertices
","Few edges and lots of vertices
",,"Source: DA Lecture 17 Graphs 1
",
"Consider a sorting algorithm which takes ... to sort a random array (n being the size of the input array)- 10 seconds for an input for n = 100- 10 seconds for an input for n = 1000- 10 seconds for an input for n = 10,000
","T(n)
","T(n2)
","T(log n)
","T(1)
",,"Since no matter the size of n, the sorting time remains the same, henceT(1)If every time, n doubles, the time doubles, it would beT(n)If every time, n doubles, the time quadruples, it would beT(n2)If every time, n doubles, the time increases by a constant amount, it would beT(log n)
",
"An implementation of the selection sort algorithm takes 2 seconds to sort 10^5 random Integers. How long will the same algorithm likely take to sort 10^6 random integers?
","4 seconds
","20 seconds
","100 seconds
","200 seconds
","1000 seconds
","Selection sort isT(n^2). Then, (n)^2=k*2 where k is a constant of proportionality. In this case k=1/2*(10^5)^2 and so (10^6)^2=k*ans, ans = 2*((10^6)^2)/((10^5)^2)=2*100=200
",
"When working with a perfectly balanced, binary, AVL tree consisting of the values[84,112,201,267,273,1023,1749,2044] by traversing from start to finish the following output is given:84,201,267,112,1023,2044,1749,273What type of transversal was used?
","A Level-Order Transversal
","An In-Order Transversal
","A Pre-Order Transversal
","A Post-Order Transveral
",,"A (Level-Order) would be273, 112,1749,84,267,1023,2044,201B (In-Order)would be84,112,201,267,273,1023,1749,2044C (Pre-Order) would be 273,112,84,267,201,1749,1023,2044D (Post-Order) is correct(84,201,267,112,1023,2044,1749,273)
",
"Which of the following is the most efficient unstable sorting algorithm based on time complexity?
","Selection sort
","Merge sort
","Heap sort
","Insertion sort
","Bubble sort
","Selection sort - unstable but theta(n^2)Merge sort - can be theta(n) but it is stableHeap sort - theta(n*log(n)) and unstableinsertion - stablebubble - stable
","tc702 (tc702 - permission to this course revoked)
"
"Which of the following is the most efficient unstable sorting algorithm based on time complexity?
","Selection sort
","Merge sort
","Heap sort
","Insertion sort
","Bubble sort
","Selection sort - unstable but theta(n^2)Merge sort - can be theta(n) but it is stableHeap sort - theta(n*log(n)) and unstableinsertion - stablebubble - stable
","tc702 (tc702 - permission to this course revoked)
"
"Which of the following is a stable sorting method?
","Quick sort
","Merge Sort
","Heap Sort
","Select Sort
",,"Source: DA Lecture 12 Sorting 3
",
"Which one of these is one of Carey's rules of sorting
","Choose a sorting algorithm that best meets your requirements regardless of complexity.
","Don't choose a sorting algorithm until you understand the requirements of the problem.
","Always choose the simplest sorting algorithm.
","The first thing to choose when starting a sorting problem is which algorithm to use.
",,"This is as quoted in the lectures
","tc702 (tc702 - permission to this course revoked)
"
"Which one of these is one of Carey's rules of sorting
","Choose a sorting algorithm that best meets your requirements regardless of complexity.
","Don't choose a sorting algorithm until you understand the requirements of the problem.
","Always choose the simplest sorting algorithm.
","The first thing to choose when starting a sorting problem is which algorithm to use.
",,"This is as quoted in the lectures
","tc702 (tc702 - permission to this course revoked)
"
"How do you calculate the load factor for a Hash Table
","Load = number of pieces of data / total buckets in array
","Load = max.no of buckets required / total buckets in array
","Load = max.no of buckets required / number of empty buckets
","Load = 100 / number of empty buckets
",,"This is the formula quoted in lectures
","tc702 (tc702 - permission to this course revoked)
"
"How do you calculate the load factor for a Hash Table
","Load = number of pieces of data / total buckets in array
","Load = max.no of buckets required / total buckets in array
","Load = max.no of buckets required / number of empty buckets
","Load = 100 / number of empty buckets
",,"This is the formula quoted in lectures
","tc702 (tc702 - permission to this course revoked)
"
"What are singly linked lists?
","Linked lists with elements that have one pointer to the previous element.
","Linked lists withelements that have one pointer to the previous element and one pointer to the next element.
","Linked lists withelements that have one pointer to the next element.
","Linked lists withelements that have one pointer to either the previous or next element.
",,"Singly linked lists have elements with one pointer to the next element in the list. This allows for only one direction of traversal.
",
"Why is removing an item an issue in closed hash tables that utilised linear probing to handle collisions?
","Because once the value is removed the hash table becomes more empty, which makes searching through the table far less efficient.
","The value removed will cause issues if a value that has been linearly probed is searched for as the removed value may end a search prematurely with the empty space.
","If removing values is allowed in a hash table, the linear probing insertion algorithm will no longer function correctly as it would allow values to be inserted into the incorrect spaces for searching.
","Removing an item is not an issue in this case because linear probing is mainly concerned with inserting elements into a hash table as opposed to inserting them.
",,"Searching with linear probing functions by continuing a search at the next bucket if the current bucket does not hold the correct value being searched for, so if a value has been moved to another bucket using linear probing and a value in between the original hash value bucket and the new probed location in the table is removed, the search for that value will end prematurely at the empty space. Thus the searching of hash tables will become inaccurate as a result.
",
"Which ONE statement out of these are true?
","The height of a node is dependant on it's children, the balance of a node is dependant on it's ancestors?
","The height of a node is dependant on it's ancestors, the balance of a node is dependant on it's ancestors?
","The height of a node is dependant on it's ancestors, the balance of a node is dependant on it's children?
","The height of a node is dependant on it's children, the balance of a node is dependant on it's children?
",,"Both the height and the balance of a node depends on the node children only.
",
"What is the purpose of linear probing in hash tables?
","In order to fill up the hash table as much as possible in order to improve the efficiency of searching.
","To spread out collisions throughout the hash table so that values with the same hash value can still be stored and searched with minimal issue in the table.
","To decide which value should be stored in the hash table when a collision occurs during insertion.
","To ensure that any values attempting to be inserted at the end of the hash table is moved to the front of the table, not exceeding it's limits.
",,"Linear probing moves values that have the same hash value as a item already stored in the hash table to the next available bucket for storage. When searching for a value that has been moved, if the bucket does not contain the value searched for, the search will continue to the next bucket until it finds the value, completing the search, or finds an empty bucket, indicating the value is not in the table. This allows for collisions to still be stored in the hash table without disallowing values to be inserted into the table, up to a point.
",
"Which of these is the right description for the load of a hash table?
","Max # of keys to insert /Total buckets in the array
","Min # of keys to insert / Total buckets in the array
","Total buckets in the array /Max # of keys to insert
","Average # of keys to insert / Total buckets in the array
",,"Lecture 9
",
"Which of the following is not a property of the Upper Bound O(n)?
","If g(n) = O(f1(n)) and h(n) = O(f2(n)), then g(n)+h(n) = O(max{f1(n), f2(n)})
","For all c>0: cf(n) = O(f(n))
","If f(n) = O(g(n)) and g(n) = O(h(n)), then f(n) = O(h(n))
","If f1(n) = O(g(n)) and f2(n) = O(g(n)), then f1(n)f2(n)=O(g(n))
","If g1(n) = O(f1(n)) and g2(n) = O(f2(n)), then g1(n)g2(n) = O(f1(n)f2(n))
","The answer is D. Consider the functions f1(n)==f2(n). Both f1(n)=O() andf2(n)=O(), however, f1(n)f2(n)==/=O().
",
"Which of these would be a correctly balanced, binary, AVL tree consisting of the values [84,112,201,267,273,1023,1749,2044]?
","
","
","
","
",,"It is not A since 273 is greater than 267It is not B since273 is greater than 267 (and it is not perfectly balanced).It is not C since the tree is not perfectly balanced as the number of nodes in the left and right subtrees at 1749 does not differ by at most 1.D is correct.
",
"Which of the following has the correct time complexities for the following sorting algorithms.
","Selection sort always ?(n^2)Shell sort approx ?(n^1.25)Quick sort always ?(n log(base 2)n)
","Selection sort always ?(n^2)Insertion sort?(n^2) worst case, or?(n log(base 2)n) best caseHeap sort always?(n log(base 2)n)
","Selection sort always ?(n^2)Shell sortapprox ?(n^1.25)Merge sort always ?(n log(base 2)n)
","None of the above are all true
",,"For a) Quicksort only has ?(n log(base 2) n) average, but ?(n^2) for already/mostly/reverse ordered arrays.For b) Insertion sort has?(n) for best case
",
"Which of the following scenarios would use an adjacency matrix over an adjacency list?
","Representing a map of Bath with buildings as the nodes and the streets connecting them as the edges.
","A graphical representation of YouTube with user accounts being the nodes and the relationship being if they are subscribed to the channel or not.
","A graph of all the train systems in the UK with the nodes being train stations and the relationships being if a train goes directly from one stop to the other.
","A graphical depiction of all the ports in the world with companies offering trips to nearly every other port directly. The nodes being the ports, and the relationship being whether or not a ship travels between them.
",,"Despite there being a large number of ports, the situation describes that there is a ship travelling from one to almost every other port in the world, meaning the number of relationships is much larger than the number of nodes in the graph, making it a dense graph requiring an adjacency matrix.
",
"Which of the following best describes a doubly linked list?
","Two pointers to the previous element.
","One pointer to previous element and one pointer to next element.
","Two pointers to the next element.
","Two pointers to the previous element and two pointers to the next element.
",,"Unlike a singly linked list, in which every element has a pointer to the next element, in a doubly linked list each element has a pointer to the previous element and a pointer to the next element. This allows traversal in both directions.
",
"When are O(Big-Oh), ?(Big-Theta), and O(Big-Omega), meant to be used for estimating complexity/run times/instructions required?
","O - To over-estimate and identify the upper-bound, aka Worst case.? - Wherever possible, as it states the exact complexity.O - To under-estimate and identify the lower-bound, aka Best case.
","O - To under-estimate and identify the lower-bound, aka Best case.? - Wherever possible, as it states the exact complexity.O -To over-estimate and identify the upper-bound, aka Worst case.
","O - Wherever possible, as it states the exact complexity.? -To over-estimate and identify the upper-bound, aka Worst case.O - To under-estimate and identify the lower-bound, aka Best case.
","O - To under-estimate and identify the lower-bound, aka Best case.? - To over-estimate and identify the upper-bound, aka Worst case.O - Wherever possible, as it states the exact complexity.
","O - Wherever possible, as it states the exact complexity.? - To under-estimate and identify the lower-bound, aka Best case.O -To over-estimate and identify the upper-bound, aka Worst case.
","From lecture 4:When do I use them??(�) whenever you can: �the complexity is exactly of the order n2�O(�) for over-estimating: �it can�t be more than n3�O(�) for under-estimating: �it must be at least n�
",
"In what type of hash table is linear probing used?
","Open hash table
","Closed hash table
","Neither, it is not used for hash tables
","gs: ADTs, Lists, Hashtables
",,,"jr934 (jr934)
"
"Which of these sorts is unstable?
","Selection Sort
","Merge Sort
","Bubble Sort
","None of the above
",,"See D&A midterm revision lecture, slide 31.
",
"for the following AVL tree, what tree will be the result of adding the string ""10"" 5 / \ 2 7 / \ / \ 0 3 6 9
","5 / \ 2 7/\ /\0 3 6 9 \ 10
","5 / \ 2 7 /\ /\0 3 6 9 \ 10
","5 / \ 10 7 /\ /\ 0 2 6 9 \ 3
","5 / \ 3 9 /\ /\0 2 7 10 / 6
",,"the string ""10"" is between 0 and 2 as it is not ordered numericallyno rotation is needed after insertion as it is balanced
",
"Which of the following is NOT true for an open hash table:
","If you want to store up to 5000 items, and have an average number of steps to find/insert an item = 1.3. Then you need approximately 8000 buckets.
","Increasing the load factor does not affect the average number of steps needed to insert/find an item.
","Open hash tables use pointers to singly linked lists in each bucket instead of the values directly.
","Hash tables with a load factor of 0.1 allow very quick searching/inserting but wastes a lot of memory.
","None of the above
","Although the increase is small in an open hash table, an increase in load factor still increases the average number of steps needed.
",
"Which of these is the definition of a directed graph?
","All edges are bi-directional. You can go either way along any edge.
","All edges go from one vertex to another in a specific direction.
","planation: See D&A Lecture 17, slide 6
","gs: Graphs
",,,"rlw44 (rlw44 - permission to this course revoked)
"
"There is a closed hash table with 120 slots, the number of elements stored in this hash table currently is 90.What is the average number of steps needed to find an element?
","4
","2.5
","5
","2.16
","3.28
","Average # of steps = �(1+ 1/(1-L)) where L is load factor.L = Keys/slotsL = 90/120L = 0.75so �(1+ 1/(1-.75))�(1+ 1/(.25))�(1+ 4)�(5)Average # of steps = 2.5
",
"What is the worstcase complexity for the ""inTree"" method for a binary AVL tree with height of m layers?
","m
","m2
","m3
","1
","log(m)
","for m layers complexity is m, forn nodes complexity is log2(n)
",
"What is the complexity of the following algorithm?for (int i=0; i<n; i++){ for (int j=1; j<n; j=j*2){ doTheThing; }}
","n
","n^2
","logn
","nlogn
",,"outer loop has complexity n, inner loop has complexity logn. Thus we have nlogn.
",
"Which of these IS a valid AVL Tree?
","10 / \ 6 14 / \ / 4 7 9
","10 / \ 8 11 / \ 5 12 / \ 4 13
","10 / \ 8 12 / / \ 4 11 13 / 2
","10 / \ 7 14 / \ \ 5 9 18
","None of the above
","a) is not a BST because of 9.b) node 8 & 12 are unbalanced.c) node 8 is unbalanced.
",
"Which of the following statements about linear data structures is FALSE?
","Linked lists can be implemented to have constant time for adding elements to the end.
","It is always faster to find an element in a skip list that a linked list.
","An array should be used if the amount of data is known and constant.
","The average runtime complexity for performing a find in a linked list is n.
","They are all false.
","A. You can add a reference to the tail for adding to the end. - TRUEB. A skip list is probabilistic so not necessarily - FALSEC. An array is very fast for accessing data and is easy to implement. It works well when the amount of data is always the same.D. See lecture 7
",
"What is the adjacency matrix for this directed graph?
","
","
","
","
","None of these options are correct.
","The answer is A because an adjacency matrix for a directed graph shows if there is an edge from vertex I to vertex J (where vertex I is represented by the rows in the table and vertex J is represented by the columns in the table). In this example, if there is an edge then the cell contains a 1. Otherwise there is a 0 at that position in the table.The answer is not D because D is the adjacency matrix for the undirected version of this graph.
",
"What is the definition of a stable sorting algorithm?
","Stable sorting algorithms are algorithms suitable for large number of elements
","Stable sorting algorithms make use of the divide-and-conquer paradigm
","Stable sorting algorithms maintain the relative order of records with equal keys.
","stable sorting re-orders items without taking into account their initial ordering.
",,"Refer to Sorting 1 slides
","ubza20 (ubza20)
"
"What is the definition of a stable sorting algorithm?
","Stable sorting algorithms are algorithms suitable for large number of elements
","Stable sorting algorithms make use of the divide-and-conquer paradigm
","Stable sorting algorithms maintain the relative order of records with equal keys.
","stable sorting re-orders items without taking into account their initial ordering.
",,"Refer to Sorting 1 slides
","ubza20 (ubza20)
"
"What is the average performance for insertion sort?
","
","O(n log n)
","O(n)
","gs: Complexity
",,,"adam (ap2280 - permission to this course revoked)
"
"Given that selection sort has a time complexity of O(n^2) for an unsorted set of data, what is the time complexity of selection sort for a sorted set of data?
","O(n^2)
","O(1)
","O(n)
","O(n log n)
","None of the above
","O(n^2) as selection sort's time complexity is independent of how the data is sorted
",
"Which of the following best describes a full binary tree?
","Every leaf node has the same depth and every non-leaf has exactly two children.
","Every node has at most two children nodes.
","Any node can have any number of children nodes
","Given any node, all nodes in its left sub-treemust be less than the node�s value.Given any node, all nodes in its right sub-treemust be greater (or equal) than the node�s value.
",,"Refer to Trees Slides 1 and 2
",
"A collision in a hash table is:
","When two different keys are mapped to the same table address.
","When two table addresses are mapped to the same key.
","When a table address does not have a mapped key.
","gs: Hashtables
",,,"adam (ap2280 - permission to this course revoked)
"
"What is the worst case complexity of quick sort and in what scenario will this occur?
","O(nlogn) the pivot is repeatedly chosen as the largest element of the list.
","O(n^2) the pivot is repeatedly chosen as the smallest element of the list.
","O(nlogn) the pivot is randomly chosen.
","O(n^2) the pivot is chosen randomly on a list which is in reverse order.
","O(n) the pivot is chosen as either the largest or smallest element each time.
","The complexity of the worstcase is O(n^2) ruling out A, C and E.The average case when the pivot is chosen randomly should give complexity of O(nlogn)The worst case is when the pivot gives one sublist of (n-1) elements and the other sublist with 1 element. This occurs when either the smallest element is chosen repeatedly or the largest element is chosen repeatedly.See lecture: Sorting3orhttps://en.wikipedia.org/wiki/Quicksort#Worst-case_analysis
",
"What is the order for traversal of a binary tree with n elements?
","
","
","
","
","None of the above
","When traversing the tree we only need to visit each node once.
",
"What is the wprst case run time complexity of merge sort?
","nlogn
","log n
","n
","n^3
","N^2
","It is nlogn
",
"What type of binary tree traversal does this process describe?:Step 1. Traverse the left subtreeStep 2. Traverse the right subtreeStep 3. Visit the root
","Inorder Traversal
","Preorder Traversal
","Postorder Traversal
","Outorder Traversal
",,"The answer is: Postorder Traversal. A good way to remember the different traversals is the order in which steps happen as each traversal is made up the the same basic steps, current (C), left(L), and right (R).Preorder is: Current, then left, then right, so C L R.Inorder is: L C RPostorder is : L R C
",
"Which of the following statements are true?:
","Quick sort is unstable and has a best case time complexity of O(n log n)
","Quick sort is unstable and has a worst case time complexity of O(n2)
","Quick sort is stable and has a best case time complexity of O(n log n)
","A and B
","None of the above
","Quick sort is unstable, as sorting with quicksort re-orders items without taking into account their initial ordering.Quick sort's best and case preformance is O(n log n).Quick sort's worst case preformance is O(n2). However this only occurs when the array is already sorted in same, or reverse, order, or when all elements are same.
",
"""In this type of search, a sequential search checks each element of a list, one by one, until a match is found or the whole list has been searched""Describes which searching algorithm?
","Binary Search
","Interpolation Search
","Jump Search
","Linear Search
","Exponential Search
","This describes linear search, as each element in the list is checked sequentially until a match is found.
",
"Given n = 4, what is the final value of k in the below algorithm.int k = 0;for (int i=0; i<n; i++){ for (int j=n; j>0; j=j/2){ k++; }}
","k = 12
","k = 15
","k = 16
","k = 20
","None of the above
","j = 4 then 2 then 1 then 0 (won't run at 0), so we have k++ * 3, outer loop will run 4 times. So, k = 3*4=12
",
"You have two different algorithms to accomplish a given task. One algorithm runs in time 2nand another runs in 500 time. The maximum value of n in the algorithm is 10. What run time should be used?
","2n
","500
","planation: Up to n = 10.5, 2nis smaller than 500 .
","gs: Complexity
",,,"alexemurphy (aem60 - permission to this course revoked)
"
"What is the most efficient type of number to choose when decided on the size of a hash table?
","Random
","Prime
","Power of 2
","Power of 10
",,"Choosing a prime number results in more even distribution and fewer collisions.
",
"Given n = 5, what will be the final value of k in the algorithm below & what is it's run time complexity, which we'll call O?int k = 0;for (int i=0; i<n; i++){ for (int j=i; j<n; j++){ k = k++; }}
","k = 15, O = n
","k = 12, O = n^2
","k = 15, O = n^2
","k = 18, O = n^2
","None of the above.
","i = 0, k++ * 5. i = 1, K++ * 4. ... i = 4, k++ * 1. k = 5+4+3+2+1 = 15.Nested loops implies complexity of n^2.Please correct me if you believe I am wrong.
",
"What rough value bounds the maximum height of an AVL tree
","1.44*log2(N)Where N is the number of nodes in the tree
","3log2(N)Where N is the number of nodes in the tree
","N/3Where N is the number of nodes in the tree
","H=Nc^2Where H is the height of the tree, N is the number of nodes and c is the balance constant.
",,"The maximum height of an AVL tree is bound by roughly 1.44*log2(N) as the height cannot exceed the (rounded up) value of this.
",
"Which of the following answers describes the correct process of collision handling in a closed hash table with linear probing?
","When collision: Program Crashes
","When collision: Move backwards across hash table until open slot is found If reach end of hash table: Loop back to the end If no open slot: Return that hash table is full
","When collision: Move across hash table until open slot is found If reach end of hash table: Loop back to the beginning If no open slot: Return that hash table is full
","When collision: Move across hash table until open slot is found If reach end of hash table: Loop back to the beginning If no open slot: Crash
","When collision: Move forwards across hash table until open slot is found If reach end of hash table: Return that hash table is full
","Answer C: correctin the case of a collision in table [1,2,-,3,4,5] (where ' - ' represents an open slot)let's say we're inserting something with hash value 2: it will detect that there is already something in that hash slot, and move across to the next slot, which in this case is openlet's say now we're inserting something with hash value 3: it will detect that there is already something in that hash slot, move across to the next slots, which are full until it hits the end of the table (5) and then loop back to the beginning (1) and move across again until it hits where the collision occured again (indicating table is full) and return that the table is full and that the item cant be inserted.Answer A: noAnswer B: the moving across is done towards the end of the table not the beginningAnswer D: look at AAnswer E: missing the looping back
",
"What is the complexity of the following code?int f( int n, int m) { int count = 0; for (int i = n; i > 0; i--) { for (int j = 0; j < m; j = j + 2) { count++; } } return count;}
","max{ ?(n),?(m) }
","?(n* log(m))
","?(n*m)
","?(n + m)
","?(n2)
","This function contains a nested loop where the operation in the inner loop runs approximately m/2 times giving us ?(m) for each iteration.This is iterated n times and so the complexity of the function as a whole is ?(n*m)
",
"Which of the following statements is false?
","Insertion sort is less efficient for large lists.
","Quick sort is a comparison sort.
","Merge sort is a divide and conquer algorithm.
","Shell sort is stable.
",,"Shell sort is not stable because items that are far apart (H items apart) can move far distances jumping earlier in the array than items that have their same value
",
"Which of these formulas will provide theload factor of a hash table?
","
","
","
","
","None of the above
","As shown in lecture 9, the formula produces the load factor of a hash table.
",
"What's the difference between an open and closed hash table?
","In a closed hash table our data is stored in a fixed-size array, there are a fixed (closed) number of buckets for us to put values whereas in an open hash table instead of storing our values directly in array, each array bucket points to a linked list of values.
","A closed hash table stores values in a linked list and an open hash table stores data directly in an array.
","A closed hash table stores values in a tree and an open hash table stores data in an array.
","A closed hash table stores values in an array and an open hash table stores data in a tree.
",,"The difference is to avoid the common drawbacks of a closed has table. Which are fixed capacity and it is difficult to delete items.
",
"What is the average runtime of Skip List?
","O(logn)
","O(n)
","O(nlogn)
","O(n^2)
",,"There are O(logn) levels because you half the number of items at each level. You will visit a maximum of 2 nodes per level. So search time is O(logn)
",
"I am implementing a Binary Search Tree (BST). Which of the following statements do not have to be true about my BST?
","It MUST have connected notes with a linked list.
","It MUST have a reference to a root node
","A given node MUST have all nodes in its right sub-tree greater or equal than node's value
","All techniques for traversal in BST MUST have O(n)time-complexity
",,"Using a Linked List in your implementation is optional - (Source: Lecture 14, Slide 9).We may use Arrays,type of Node class etc--Crucially, it's important to recognise the Binary Search Tree has a higher abstraction, it doesn't specify how it's to be implemented. It needs to meet certain criteria, as well as being a Binary Tree, that allows for optimal traversal.
",
"Which of these sorting algorithms has theworst space efficiency?
","Quicksort
","Mergesort
","Shell Sort
","Selection Sort
","Heapsort
","Quicksort has O(log n) space complexity. All of the others have O(1) complexity, with the exception of mergesort, which has a complexity of O(n).
",
"What is transitivity? In terms of time complexity.
","If f1(n) = O(g1(n)) & f2(n) = O(g2(n)) then f1(n) + f2(n) = O(max{f1(n), f2(n)})
","If f1(n) = O(g1(n)) & f2(n) = O(g2(n)) then f1(n) + f2(n) = O(min{f1(n), f2(n)})
","If f(n) = O(g(n)) & g(n) = O(h(n)) then f(n) = O(h(n))
","c*f(n) = Of(n), for all c>0
","None of the above
","Lecture 4 - Complexity 2, slide 7.
",
"Add new nodes with the following datas in order : 50, 76, 21, 4, 32, 100, 64, 52, use the tree insertion algorithm, find out the value which the node based on.
","52
","64
","32
","100
",,,
"Depth First Search is equivalent to which of the traversal in the Binary Trees?
","In-order Traversal
","Pre-order Traversal
","Post-order Traversal
","Level-order Traversal
","None of the above
","Depth First Search explores all the nodes aggressively to one path and then backtrack to the node. This is equivalent to the pre-order traversal of a Binary Tree.
",
"What is the average runtime complexity of an Array list's add operation? (if resize doubles array size)
","1
","log n
","n
","n^2
","n log n
","Over many adds() only about as many copys() as adds() writes
",
"Which of the following is NOT an advantage of using open hash table over closed hash table.
","Open hash tables have no fixed number of buckets.
","You can remove objects in an open hash table.
","Open hash table uses less memory.
","Open hash tables are almost always more runtime efficient.
","None of the above.
","Closed hash table uses less memory since its a fixed size.
",
"Which statement is false?
","The average time complexity for searching an array and a linked list is the same.
","Bubble sort has a faster best case than merge sort
","Insertion sort is a stable sorting algorithm
","The average case time complexity for searching a BST is slower than an AVL tree
",,"A) True, the average time complexity for searching both isT(n)B) True, the best case for bubble sort isT(n), whereas it isT(nlog(n)) for merge sortC) Insertion sort takes into account the order of the inputted data, so therefore is a stable sorting algorithmD) The average case of searching a BST and AVL tree isT(log(n))
",
"What is the tree equivalent of a linked-list 'head' pointer?
","A leaf node.
","A parent node.
","A child node.
","A root node.
","A depth node.
","Since a tree is a linked list based data structure it carries over some similarities. However, in a linked list we have the head pointer but in a tree we have a root pointer.Both these pointers point to the first node of each data structure.
",
"What operation has the lowest average runtime complexity in a singly linked list.
","get(i)
","add(o)
","insert(o, i)
","remove(i)
","find(o)
","add(o) has constant runtime complexity O(1), while others have linear O(n).
",
"1, 3, 7, 8, 9, 11 is a _________ traversal of this binary tree.
","Inorder
","Preorder
","Postorder
","gs: Trees
",,,"danielwa (dwa23 - permission to this course revoked)
"
"Which sorting algorithm does this piece of code belong to?Note: numbers is a list of unique ints.for (int position=1; position < numbers.length; position+=1) { int currentIndex = position; while (true) { if (currentIndex == 0) { break; } if (numbers[currentIndex] < numbers[currentIndex-1]) { int temp = numbers[currentIndex-1]; numbers[currentIndex-1] = numbers[currentIndex]; numbers[currentIndex] = temp; currentIndex-=1; } else { break; } }}
","Bubble sort
","Insertion sort
","Selection sort
","Shell sort
",,"It starts at position 1 and compares the value at the current index to the one before. If its smaller it swaps the two values and the current index is decreased by one. If not (or the current index is the start of the list) it exits the loop and starts again at the next position until every position has been done. This is the key process in insertion sort.
",
"Which sorting algorithm has the worst average time complexity (?)
","Bubble Sort
","Quicksort
","Mergesort
","gs: Sorting, Complexity
",,,"danielwa (dwa23 - permission to this course revoked)
"
"The following code is for an insertion sort. Select from the options below, the line of code which should replace Xpublic static void insertionSort(int[] array) { int[] a = array; int n = a.length; for (int i=1; i<n; ++i){ int key = a[i]; int j = i-1; while (j>=0 && a[j].compareTo(key) > 0){ a[j+1] = a[j]; j = j-1; } X }}
","a[j] = key;
","a[i] = key;
","a[j+1] = key;
","a = key;
","None of the above
","After you have compared all the elements to the key and moved them around, you must then re add the key to your array.
",
"Which one correctly describes the complexity of the following code fragment?for (int i = 1; i < n; i = i * 2){ for(int j = n; j > 0; j--) { System.out.print(""hello world""); }}for (double i = n; i > 1; i = i / 2){ System.out.print(""goodbye world"");}
","
","
","
","
","None of the above
","When for loops are nested as in the first two we multiply the complexities. As the first one doubles each time it has log n order. The second one works from n to 1 linearly so that gives n. Thus we have n log n. The final for loop has log n complexity but we take the worst case so that gives O(n log n).
",
"A post order traversal of the tree; [a] / \ [b] [c]
","a b c
","a c b
","b c a
","b a c
","c a b
","Post order traversal prints the node after printing the left and right subtrees, hence post order
",
"Which of the following statements about doubly-linked lists is true?
","Doubly-linked lists can only move in one direction.
","In order to insert a node, only the new node's pointers must be updated.
","Nodes in doubly-linked lists have 3 pointers: prev, current and next.
","The previous pointer for the ""head"" node and the next pointer for the ""tail"" node have the same value.
","It is impossible to insert or remove the ""head"" node of a doubly-linked list.
","The values of the previous pointer for the ""head"" node and the next pointer for the ""tail"" node are both NULL, and thus equal.
",
"Which of the following statements about linked lists is false?
","The time complexity of finding the ith element is?(n)
","When you have a tail pointer, the time complexity of adding an element to the end is?(logn)
","It is faster to add and remove elements in a linked list than in an array
","A tail pointer in a linked list is optional
",,"Without a tail pointer, the time complexity of adding to the end is?(n), however with a tail pointer, the complexity changes to?(1).
",
"Which of the following statements about array lists and arrays in java are false1.Array lists can be resized whereas arrays can't.2.Array lists can have gaps in the list whereas a standard array cannot.3. A linear search in an array list is slower than in an array (where both have the same elements).4. An array can be of a primitive data type whereas an array list can be of a primitive or non-primitive data type.5. Array lists are always single dimensional however arrays can also be multi-dimensional.
","2 and 5
","3 and 4
","2 and 4
","4 and 5
","1 and 2
","1. True: an array is a set space in memory so it cannot be resized, however an array list uses pointers to the next value so can be resized by re-directing the pointers.2. False: array lists can have gaps in memory (so not a linear block of memory) but not in the list as each element must have a pointer to the next element.3. True: in an array the value is checked then the next value in memory is looked at, however in a linked list the pointer for the next value must also be looked at each time.4 False: an array list cannot be of a primitive data types such as int or char. Wrapper classes must be used.5. True: An can be both whereas array lists are only ever single dimensional (Note: a common work around of this is to make an array list of lists).
",
"What is the equation for finding the average number of steps for inserting/finding an item in a hash table? With this equation, what is the average number of steps to find a bucket for a hash table that is 80% full?
","1/2(1 + 1(1 - L)) & 6
","2(1 + 1(1 - L)) & 3
","1/2(1 + 1(1 - L)) & 3
","1/2(1 - 1(1 + L)) & 3
",,"At 80% full then 1 - L = .2
",
"What is the correct formula for the load factor of a hash table?
","L = total buckets in the array / max number of keys to insert
","L = amount of free buckets in the array / total buckets in the array
","L = max number of keys to insert / total buckets in the array
","L = least amount of keys to insert / total buckets in the array
","L = (1 + 1/(1 - X))
","The �load� of a hash table is the maximum number of values (�keys�) you intend to add divided by numberof buckets in the array.A load of L=.3 means your array has 30X more buckets than you need (you�ll only fill 30% of the buckets).
",
"Which of the following sorting algorithms has the best/ quickest WORST CASE time complexity?
","Quick Sort
","Bubble Sort
","Insertion Sort
","Merge Sort
","Selection Sort
","Quick sort - O(n^2)Bubble sort -O(n^2)Insertion sort - O(n^2)Merge Sort - O(n log(n))Selection Sort-O(n^2)This is because Merge Sort is a divide and conquer approach. It has a set number of steps for n which always gives O(n log(n)) for best, average and worst case. Although Quick Sort is also a divide and conquer approach, it's worst case time complexity is O(n^2) like the rest.
",
"Which of the following sorting algorithms is stable?
","Selection Sort
","Shell Sort
","Insertion Sort
","Quick Sort
","Heap Sort
","Insertion sort is stable - it takes into account the initial order of the objects to be sorted.
",
"Which of the following statements about basic trees is false?
","Trees are made up of nodes.
","The top node of a tree is called the ""leaf"" node.
","Every tree has a ""root"" node.
","Every node on a tree can have zero or many ""children"" nodes.
","Tree nodes can have two or more ""next"" pointers.
","The top node of a tree is called a ""root"" node - a ""leaf"" node refers to a node with 0 children.
",
"I am tasked with programming a sorting algorithm with large data-sets on a powerful computer. This is an important part of my company's time-critical, safety application. I'm told that completing the sorting very quickly- in all possible cases - is the biggest priority. What's the appropriate choice of algorithm?
","Insertion Sort
","Merge Sort
","Quick Sort
","Heap Sort
","Bubble Sort
","Merge Sort has O(nlogn)worst case scenario run time, it's only drawback is space inefficiency, which isi not a factor in this case.While Quick Sort - if well implemented - is normally superior, it's worst case is polynomial runtime -O(n^2) -which is undesirable in a time-critical task given large data sets.It is well known thatHeap Sortis usually outperformed in real world/ industry, with its advantage lying in its superior memory efficiency.
",
"In this question we'll consider the Abstract Data Type: Heaps.If the data for a node in a heap is stored in position i in an array, what positions will its children be stored in?
","Left Child: Right Child:
","Left Child: Right Child:
","Left Child: Right Child:
","Left Child: Right Child:
","None of the above.
","Let's consider the example i = 0. Its children are in position 1 & 2 & we can deduce that 2i+1 = 2(0)+1 = 1 & 2i+2 = 2(0)+2 = 2. This doesn't rule out option C so we'll also consider the example i = 3. Its children are in position 7 & 8 & deduce that2i+1 = 2(3)+1 = 7 & 2i+2 = 2(3)+2 = 8. Therefore the answer is B. Refer to lecture 16 - Trees 4 if you are still unsure of the reasoning.
",
"Sort the algorithm complexities from fastest to slowest when n = 100.1. 1502. 50n3. 5n^24. log(3000n)5. 6nlog(400n)
","4, 1, 5, 2, 3
","4, 5, 2, 1, 3
","1, 2, 3, 4, 5
","3, 2, 5, 1, 4
","5, 1, 3, 2, 4
","1. 1502. 50(100) = 50003. 5(100)^2 = 500004. log(3000(100)) = 5.477...5. 6(100)log(400(600)) = 2761.2...
",
"What is the average runtime complexity of a binary tree search?
","O(1)
","O(n2)
","O(log n)
","O(n!)
","O(n)
","Lecture 2 in the notes.
",
"Consider functions g(n) and f(n) with g(n) >0 and f(n) >0 for n>0.Which of the following is the correct definition for the exact bound?
","g(n) = ?(f(n)) (""g(n) is Big-Theta of f(n)"")iff there are two positive constants c1 and c2 and a n0>0 so that for all n>n0: g(n)= c1f(n) and g(n)= c2f(n)
","g(n) = O(f(n)) (""g(n) is Big-Omega of f(n)"")iff there are constants c>0 and n0>0 so that for all n>n0: g(n) = c f(n)
","g(n) = ?(f(n)) (""g(n) is Big-Theta of f(n)"")iff there are two positive constants c1 and c2 and a n0>0 so that for all n>n0: g(n) = c1f(n) and g(n) = c2f(n)
","g(n) = ?(f(n)) (""g(n) is Big-Theta of f(n)"")iff there are two positive constants c1 and c2 and a n0>0 so that for all n>n0: g(n) = c1f(n) and g(n)= c2f(n)
","None of the above
","These definitions are provided in lecture 4.
",
"You plan to store data in a closed hash table with linear probing to the right. The hash function you are using is h(x) = x % 7, meaning there are 7 slots in your hash table; 0,1,2,3,4,5,6. Inserting the elements 22, 8, 5, 26, 4, 13, 9 in that order, what would be the end result?
","26, 22, 8, 9, 4, 5, 13
","26, 22, 9, 8, 4, 5, 13
","13, 22, 8, 9, 4, 5, 26
","13, 22, 8, 9, 5, 4, 26
","13, 22, 8, 26, 4, 5, 9
","22mod7=1 so goes in slot 1, 8mod7=1, since slot 1 is occupied, it goes in the next free slot to the right, slot 2. 5 goes in slot 5, 26mod7=5 so goes in slot 6 as is next available, 4 goes in slot 4, 13mod7=6. Since slot 6 is occupied, we wrap around back to slot 0, and finally 9mod7=2, but since there is only one remaining space, 9 ends up in slot 3, giving us13, 22, 8, 9, 4, 5, 26.
",
"Which of these algorithms have the fastest best case?(assume all elements are distinct)
","Heap sort
","Merge sort
","Selection sort
","Insertion sort
","Shell sort
","Heap sort is O(nlogn) (if not all keys are distinct then it can be O(n))Mergesort is O(nlogn)Selection sort is O(n^2)Insertion sort is O(n)Shell sort is O(nlogn)
",
"What is the best a comparison sort algorithm can perform in the average or worst case?
","O(1)
","O(logn)
","O(n)
","O(nlogn)
","O(n!)
","WLOG WMA that a given permutation has n distinct elements (as this is worst case scenario). There are therefore exactly n! permutations.Now suppose a sorting algorithm always finishes sorting n elements in S(n) steps. As a sorting algorithm can only work out the order of the elements it is sorting by comparisons and as comparisons can only have one of two outcomes, it can't distinguish most than 2^(S(n)) cases.This means 2^(S(n)) >= n! => S(n) >= log(n!) => S(n) >= (n/2)* log(n) => S(n) = O(nlogn)
",
"Suppose we have 100 different arrays of integers, all of which are length n, and we wish to order all of them.But also suppose that x of these arrays are already completely ordered, while the rest remain random, and unfortunately we do not know which are which.At what value ofx, in terms ofn, does it become more efficient to use, say, Insertion Sort rather than Quick Sort to ensure all 100 arrays are correctly ordered in minimal time?(One may assume that that an algorithms exact bound is its precise number of operations for the sake of this question, i.e. ?(n)=n, or?(n2)=n2.)
","
","
","
","
",,"The first thing to note is that Insertion Sort is?(n2) normally, but?(n) for already ordered arrays,but Quick Sort is?(n*log2(n)) normally and?(n2) for pre-ordered arrays.So, using our assumption of the exact bound being the precise operation runtime, we set up two expression in terms ofx andn for how long it takes each algorithm to sort the arrays:Insertion Sort: Quick Sort: Then, we create an inequality for Insertion Sort's equation to be less than Quick Sort's (and hence have less operations, or rather, be faster):And simply follow through the maths by rearranging:To then give our final answer:
",
"Which of these algorithms are NOT usually stable?
","Merge sort
","Quick sort
","Insertion sort
","Bubble sort
",,"Quicksort is not usually stable though there are ways to make it stable.
",
"What is putting in instructions which measure codes runtime called?
","Debugging
","Instrumenting
","Optimising
","Refactoring
",,"Lecture 3, complexity 1 slide 4
",
"Which type of tree transversal will first process the nodes in the left subtree, then the right subtree and finally the current node?
","In-order
","Post-order
","Level-order
","Pre-order
","Dis-order
","Pre-order is node->left->right.In-order is left->node->right.Level-order is top node->next level nodes->next level nodes->etc.Dis-order is just bad.
",
"Consider the following statements about lists and choose the statement that is FALSE.
","For an Array list the average case to remove an element is?(n)
","Linked lists do not allow random access so elements have to accessed sequentially.
","For a Linked list the average case to access an element is?(i)
","Removing an element from a Linked list is faster than removing from an Array.
","For an Array list the worst case to access an element is ?(1)
","For a Linked list the average case to access i is ?(n)
",
"Consider an algorithm that takes 8s for n=50, 14s for n=100 and 20s for n=200. What asymptotic complexity does it likely have.
","?(1)
","?(log n)
","?(n)
","?(n^2)
",,"Time increases by a constant when n is doubled so complexity is?(log n).
","steemboat (dh658 - permission to this course revoked)
"
"Consider an algorithm that takes 8s for n=50, 14s for n=100 and 20s for n=200. What asymptotic complexity does it likely have.
","?(1)
","?(log n)
","?(n)
","?(n^2)
",,"Time increases by a constant when n is doubled so complexity is?(log n).
","steemboat (dh658 - permission to this course revoked)
"
"If an insertion sort takes 10 seconds to sort 10,000 books, how long will it likely take to sort 40,000 books
","40 seconds
","20 seconds
","80 seconds
","160 seconds
",,"As insertion sort is?(n^2) with 4 times as many books to sort we have 10s x 4^2 = 160s
",
"An Open Hash Table...:
","Does not utilise a wraparound like a closed hash table.
","Can store an unlimited number of values.
","Contains linked lists of values at each array index.
","All of the above.
",,"Each array index is referred to as a ""bucket"" and contains a linked list of values for data entries with the same hash.
",
"Cameron has a set of nearly sorted data. Which algorithm would be ideal for sorting a nearly sorted data?
","Quick sort
","Heap sort
","Insertion sort
","Bubble sort
",,"look at how each sort works, particular attention to best case and worst case scenarios
",
"Which of the following is the most efficient time complexity, for a large number of items?
","O(n log n)
","O(log n)
","O(n ^ 2)
","O(1)
","O(n)
","A constant time complexity is most efficient, as it stays the same no matter the number of items, so as the number of items increases, this number will always be overtaken by an algorithm of higher complexity.
",
"David is calculating time complexity for his algorithm. What functions should he look at simplifying to reduce the time complexity?
","Accessing an item
","Evaluating a mathematical expression
","Traversing a reference
","All of the above
",,"from notes:Calculating Time complexity:Determine the number of elementary operations an algorithm performs. They take a fixed amount of time to perform- Accessing an item- Evaluating a mathematical expression- Traversing a referenceUsually the constants/exact algorithm doesn�t matter
",
"How will the following max heap tree be implemented as an array? ie- How should it look like as an array? 10 / \ 8 11/ \ / \7 4 9 5
","__0 |10|1 | 8 |2 |11|3 | 7 |4 |4|5 | 9 |6 | 5 |
","__0 | 8 |1 |11|2 | 7 |3 | 4 |4 | 9 |5 | 5 |6 |10|
","___0 | 7 |1 | 4 |2 | 9 |3 | 5 |4 | 8 |5 | 11|6 | 10|
","__0 |10|1 | 8 |2 | 7 |3 | 4 |4 |11|5 | 9 |6 | 5 |
",,"Just input all the elements into starting from the root at the top, then left to right until the last element in the tree is reached.
",
"For this question we consider the following binary AVL tree: 10 / \ 5 17 / \ / \ 3 7 12 22 / \ / \ 11 13 21 29If we say, inserted an new element 14 to the tree, and any necessary balancing was carried out, which element would be the new root of the tree?
","10
","17
","12
","22
",,"For this tough customer, a double balance is needed.First, we balance the node 17 despite only having a balance of -1, because it's unbalanced parent node 10 has a balance of opposite sign (2).This ends us up with the following: 10 / \ 5 12 / \ / \ 3 7 11 17 / \ 13 22 \ / \ 14 21 29Now, we balance the node that is actually unbalanced, the root 10, with its child node 12. Doing this appropriately grants our final tree: 12 / \ 10 17 / \ / \ 5 11 13 22 / \ \ / \ 3 7 14 21 29And, like magic, we have a balanced AVL tree, with 12 at the root, making that our final answer.
",
"You are going to add an array of numbers to an empty binary tree. It is worse in terms of search time if the input array is:
","Unsorted
","Already sorted
","Searching is the same whether the input array was sorted or unsorted
","The array size is not a multiple of 2.
",,"If a sorted array is put into an empty binary tree, the tree will be completely one sided, and you would have to search through every single element to find a high value, ieT(n).
","bgj22 (bgj22 - permission to this course revoked)
"
"You are going to add an array of numbers to an empty binary tree. It is worse in terms of search time if the input array is:
","Unsorted
","Already sorted
","Searching is the same whether the input array was sorted or unsorted
","The array size is not a multiple of 2.
",,"If a sorted array is put into an empty binary tree, the tree will be completely one sided, and you would have to search through every single element to find a high value, ieT(n).
","bgj22 (bgj22 - permission to this course revoked)
"
"A company wishes to create a Hashtable for all transaction IDs. They will never remove any of the IDs, and want the Hash Table to use minimal memory (and cache). What is the best type of Hashtable to meet these requirements.
","Probabilistic hashing (Hashing that overwrites values in buckets, if there is a collision)
","Closed Hash Table with Linear Probing
","Open Hash Table
","Coalesced hashing (Open Hash, with limited element slots)
",,"A Closed Hash table's main faults are the inability to efficiently delete values, and the handling of collisions. However, it requires the least amount of memory as the hash table, and its elements, are stored in a single array; This is instead of elements pointing to linked lists which causes an increase of memory required, due to linked lists needing to be stored in memory too.'Separate chaining (each bucket is a pointer to a linked list of values) has the disadvantage that you end up searching a linked list with all cache-related issues at hand.' StackExchange
",
"Which set of sorting algorithms have an average time complexity case ofT(n^2)?
","Mergesort, Quicksort, Insertionsort
","Shellsort, Bubblesort, Heapsort
","Bubblesort, Insertionsort, Selectionsort
","Selectionsort, Shellsort, Quicksort
",,"Bubblesort, Insertionsort and Selectionsort have an average case ofT(n^2);Mergesort, Quicksort and Heapsort have an average case ofT(n log(n));Shellsort has an average case ofT(n(log(n))^2).
",
"In terms of n, what is the total number of elementary operations for the line checking that j<i in the code below?public int complexity(int n){int result = 0;for(int i=0; i<n; i++) { for(int j=0; j<i; j++) { result = j; }}return result;}
","
","
","
","
",,"The number from the first for loop i for which we compare j<i will be the numbers 0, 1, � , (n-1). This will result in the number of comparisons being:1+2+....+n comparisons, since each separate i is compared with j (i+1) times. This means that the total number of comparisons is simply
",
"Which of the following algorithms would take thelongest to sort an array that is already ordered?
","Insertion Sort
","Quick Sort
","Bubble Sort
","Merge Sort
",,"For an already ordered array, here are the?(n) complexity times for mentioned algorithms:Bubble Sort -?(n)Insertion Sort -?(n)Merge Sort - ?(n*log2(n))Quick Sort -?(n2)Alas, Quick Sort is usually a good algorithm, but for a pre-ordered list, it does us no favours.
",
"Is the following a valid Binary tree: 1 \ 3 \ 5 \ 7
","Yes this is fine
","No this is not valid
","planation: This is a valid Binary tree, but note that it is not a valid AVL tree as the balance would not fit the criteria.
","gs: Trees
",,,"jp2150 (jp2150 - permission to this course revoked)
"
"Given an algorithm with a time complexity of the format a^(b*n) where a and b are constants, how long would it take to run the algorithm when n = 15?Use the information below to find a and b and hence answer the question. n time 3 3s 6 9s18 729s
","273 seconds
","243 seconds
","32 seconds
","180 seconds
","321 seconds
","a = 3 and b = 1/3 so 3^(15/3) = 243
",
"You are given a list of names that is initially sorted in alphabetical order by their first names. However you now want to change it to be sorted by their last names, and if they are the same then order them by their first names as initially sorted. To achieve this in the quickest way in general, which of the sorting algorithms would be best to use?
","Shell sort
","Merge sort
","Heap sort
","Quick sort
","Insertion sort
","To sort the list in this way, you would need to implement a stable sort algorithm to take into consideration the initial ordering. This means that we may rule out Heap, Shell and Quick sort, as all of these are unstable algorithms for sorting.Now because we want to do this in as fast a way as possible, we want to consider the general runtime of Insertion and Merge. The insertion sort algorithm is O(n^2) in the general case, and the Merge sort algorithm is O(nlogn) in the general case, hence the best algorithm to use in this case is would be Merge.
",
"Which of the following sorting algorithms are STABLE
","Quick Sort
","Insertion Sort
","Selection Sort
","Heap Sort
","Shell Sort
","A stable algorithm is onewhich doesn't change the relative position of same/equal elements.Insertion sort is stable because it maintains the relative order of elements as they occur in the input unlike all the other sorting algorithms above.
",
"What are the definitions of the ""root"" of a tree, the ""child"" of a node and a ""leaf"" node?
","Root: The top node of a treeChild:Any node pointed to by the current nodeLeaf: A node on the outside of the tree
","Root: The bottom node of a treeChild: Any node with a smaller value than the current nodeLeaf:A node with 0 children
","Root: The top node of the treeChild: Any node pointed to by the current nodeLeaf: A node with 0 children
","Root: All nodes below the top level of a treeChild: Any nodeon a level below the current nodeLeaf:A node with 0 children
","None of the above
","C - see lecture notes: Lecture 13 - Trees 1
",
"Which array can use binary search to find a data?
","[1 2 5 79 100 9999]
","[Apple Banana Cat Dog]
","[5 79 5000 1000 300]
","A and B
","A and C
","To use binary search algorithm, a list of data must be sorted into descending or ascending numeric or alphabetic order
",
"Which of the following is not a property of a heap?
","Heap is filled up starting from the left most branches
","It is a binary tree
","Prioritises things in order of importance
","The top N-1 levels of the tree are completely filled with nodes
",,"A heap is a ""Complete Binary Tree"", NOT just a binary tree. This is because a Complete Binary Tree satisfies the following:The Top N-1 leaves of the tree are completely filled with nodesNo empty slots exist between nodes, ie- all nodes on bottom-most level are as far left as possible. Tree is filled from left to right.
",
"What is theCounting Elementary Operations T(n) of the following code?public int totalSum(int[ ] a) { int sum = 0; for (int i=0; i<a.length; i++) { sum=sum + a[i]; } return sum}(a.length = n)T(n)=? ops
","3n+3 ops
","3n+4 ops
","4n+3 ops
","4n+4 ops
","5n+3 ops
","int sum = 0 (Variable assignment:1 op)int i = 0 (Variable assignment:1 op)i<a.length (Comparison: 1 op times a.length+1 = n+1 ops)i++ (Addition: 1 op times a.length = n ops)sum = (Variable assignment: 1 times a.length = n ops)sum + a[i] (Addition: 1 times a.length = n ops)return sum (Returning a value: 1 op)T(n) = 1 + 1+ n+1 + n + n + n + 1 = 4n + 4 ops
",
"The code below can be used to carry out which type of sorting algorithm?void algorithmName(int a[], int n){ for (int i = 0; i < n; i++) { int minIndex = i; for (int j = i+1; j < n; j++) { if (a[j] < a[minIndex]) minIndex = j; } swap(a, i, minIndex); }}
","Insertion Sort
","Selection Sort
","Quick Sort
","Merge Sort
","Bubble Sort
","This code is provided in lecture 10.
",
"Given the set of all multiples of 4 in the range 1 to 10,000 to be inserted to an open hashmap, what type of number should be used as the modulo to reduce the maximum length of linked lists?
","A perfect number
","A square number
","A prime number
","A triangle number
",,"Since prime numbers have no divisors but 1 and themselves, they provide a much better distribution for data sets with potential multiplicity bias (multiples of 4).
",
"Misha has an open Hashtable containing 4 buckets. He hashes a word by:Hashcode = Length of word + index in alphabet of the first letterFor example, ""animal"" = 6 + 1 = 7Or ""boat"" = 4 + 2 = 6The bucket is determined by hashcode % the number of buckets.E.g. ""animal"" would be placed in the bucket with index 3If Misha adds the words:""i"", ""play"", ""pokemon go"", ""everyday""What words are in each of the buckets in the hash table?
","0. ""play""1. ""pokemon go"", ""everyday""2. ""i""3. -
","0. ""play""1. -2. ""i""3. ""everyday"",""pokemon go""
","0. ""play"", ""everyday""1. ""i"", ""pokemon go""2. -3. -
","0. ""i""1. ""play""2. ""pokemon""3. ""go""4. ""everyday""
","0. ""play""1. ""everyday"", ""pokemon go""2. ""i""3. -
","The hash of 'i' = 10 => bucket index 2The hash of 'play' = 20 => bucket index 0The hash of 'pokemongo' = 25 => bucket index 1The hash of 'everyday' = 13 => bucket index 1
",
"In a computing ""tree"", which of these statements are true?
","A leaf is a node that does not have any connections to other nodes
","A binary tree can only store 2 possible values
","A node may have any number of children
","A 'child' node has a smaller value than its parents
",,"nodes may have any number of children unless it is a binary tree, then they can only have up to 2seeLecture13-Trees1
",
"Here is a graph's associated adjacency matrix, A.What is the adjacency matrix for this graph showing which nodes areexactly two edges apart?
","
","
","
","
",,"Using the fact that the adjacency matrix multiplied by itself yields the adjacency matrix showing how the nodes connected by exactly two edges the answer is:To further show this is indeed correct visually, here is the corresponding graph from the question:
",
"Which of these searches is the fastest (assuming the list it's searching is presorted and uniformly distributed)?
","Linear Search
","Binary Search
","Interpolation Search
","Exponential Search
","Jump Search
","Time Complexities (in descending order):1st - Interpolation at O(log(log(n)))Joint 2nd - Exponential and Binary at O(log(n))3rd - Jump at O()4th - Linear at O(n)Thus, Interpolation Search is the fastest.
",
"State from the following list of sorts, all the sorts which are stable.- Selection- Insertion- Bubble- Merge- Heap
","None of the above.
","Insertion, Bubble, Merge
","Selection, Insertion, Merge
","Insertion, Bubble, Merge, Heap
","All of the above.
","Insertion, Bubble and Merge Sort are all stable, whereas Selection and Heap Sort are not.
",
"Given 15, 21, 11, 7, 24, 1, 13, 12, 9 as the input for a AVL tree, select the correct output when using Post-Order Transversal:
","15 11 7 1 9 12 13 21 24
","1 7 9 11 12 13 15 21 24
","15 11 21 7 12 24 1 9 13
","1 9 7 13 12 11 24 21 15
",,"A - pre orderB - in orderC - level orderD - correct answerIn order to get the answer correct, you would need the correct tree. With the inputs in that order, the correct balanced tree on which the transversal should be done is: 15 / \ 11 21 / \ \ 7 12 24/ \ \1 9 13
",
"At what number, x, of linear searches on a list of size n would it be more efficient to quicksort and perform binary searches instead?
","
","
","
","
",,"Start with the following inequality, based on the time complexity of linear search (O(n)), binary search (O(logn)) and quick sort (O(nlogn)):Raise both sides to the power of 2...Tidy it up a little...Take logs again for a meme...Tada!Did you get it? Share the answer by tagging your friends
",
"What is the time complexity of the code below?:int 2bAlgo(int n) { Random random = new Random(); int total = 0; int[] b = new int[n]; for(int i = 0; i < n; i++) { b[i] = random.nextInt(n); } int j = 0; for(int i = 0; i < 200; i++) { j = n; while(j > 0) { total += j; j = j / 2; } } return total + b[j];}
","O(n)
","O(1)
","O(nlog(n))
","O(log(n))
","O(n^2)
","The first loop is O(n), but the second loop consists of a fixed number of iterations, so no matter the complexity of the inner loop, O(n) > O(1) so is O(n).The use of random numbers is considered as constant time
",
"One day Shrek was walking around his swamp and felt like singing. He wanted to sing All Star by Smash Mouth but his thoughts trailed off and he forgot the rest. So to help he decided to make a binary tree with the words he remembered: SOMEBODY / \ ONCE TOLD / MEwhich type of tree traversal will output ""SOMEBODY ONCE TOLD ME...""?
","In ordertree traversal
","Preorder tree traversal
","Postorder tree traversal
","Level order tree traversal
",,"Ah! Now he remembers the rest ""...THE WORLD IS GONNA ROLL ME, I AIN'T THE SHARPEST TOOL IN THE SHED!!!""In order: me, once, somebody, toldPreorder: somebody, once, me, toldPostorder: me , once told, somebodyLevel order: Each node in the tree is visited from left to right level by level, hence ""somebody once told me""
",
"When implementing radix sort, which of the following algorithms would be best to use?
","Selection sort
","Insertion sort
","Shell sort (h > 1)
","Quick sort
","Heap sort
","Radix sort requires a stable sorting algorithm to work.For example the array [10, 13, 05] would become [05, 13, 10] after comparing the first digit using selection sort
","rl836 (rl836 - permission to this course revoked)
"
"When implementing radix sort, which of the following algorithms would be best to use?
","Selection sort
","Insertion sort
","Shell sort (h > 1)
","Quick sort
","Heap sort
","Radix sort requires a stable sorting algorithm to work.For example the array [10, 13, 05] would become [05, 13, 10] after comparing the first digit using selection sort
","rl836 (rl836 - permission to this course revoked)
"
"What is the time complexity of this function?public void func(int n){for (int i=1;i<n;i++) {System.out.println(n);}for (int k=1;k<n;k++) {System.out.println(n);}}
","O(log(n))
","O(n)
","O(n3)
","O(2n)
","O(nlog(n))
","Complexity notes from the lectures.
",
"What is an ""unstable"" sort algorithm?
","A sort algorithm that does not take into account the initial ordering of the items being sorted
","A sort algorithm that has a varying time complexity
","A sort algorithm that does not always sort the items being sorted correctly
","gs: Sorting
",,,"bobobo (arg49 - permission to this course revoked)
"
"If the load factor of a closed hash table is 0.7, which of the following is false?
","The array has 30% more buckets than required.
","Linear probing takes on average > 2 steps.
","In the worst case it takes < 3 steps to find a bucket via linear probing.
","In the best case linear probing takes 1 step.
","None of the above.
","For load factor L, in the worst cast linear probing takes 1/(1-L) steps.Here for L = 0.7 this value is 10/3 which is approximately 3.33C is thus false.The remaining options are true.
",
"What is this array after 2 iterations of Bubble Sort?[""John"",""Bill"",""Elon"",""Mark"",""Amy"",""Curtis""]
","[""Amy"", ""Elon"", ""Bill"", ""Curtis"", ""Mark"", ""John""]
","[""Bill"", ""Elon"", ""Amy"", ""Curtis"", ""John"", ""Mark""]
","[""Mark"", ""John"", ""Elon"", ""Bill"", ""Curtis"", ""Amy""]
","[""Curtis"", ""John"", ""Elon"", ""Bill"", ""Amy"", ""Mark""]
","[""Elon"", ""Mark"", ""Curtis"", ""John"", ""Bill"", ""Amy""]
","Emulate 2 iterations of Bubble Sort to find the correct answer.
",
"Which sorting algorithm is described by the following psuedocode:flag = falsedo for(i = 0; i < n; i++) if (a[i] > a[i+1]) swap(a[i], a[i+1]) flag = truewhile(flag == true)
","Selection sort
","Quicksort
","Shell sort
","Bubble sort
",,"Bubble sort works by swapping adjacent values until the list is sorted, ""bubbling"" small values to the start, and large values to the endseehttps://en.wikipedia.org/wiki/Bubble_sort
",
"Which of the following properties does this tree have?1) Binary2) Balanced3) Complete4) Maxheap
","1, 2
","1, 2, 4
","1, 3, 4
","1, 2, 3, 4
","None
","1) Yes - Each node has at most 2 children2) Yes - Each node�s children have heights that differ by at most 13) No - The bottom layer of nodes is not full starting from the left4) No - The tree is not complete
","rl836 (rl836 - permission to this course revoked)
"
"Which of the following properties does this tree have?1) Binary2) Balanced3) Complete4) Maxheap
","1, 2
","1, 2, 4
","1, 3, 4
","1, 2, 3, 4
","None
","1) Yes - Each node has at most 2 children2) Yes - Each node�s children have heights that differ by at most 13) No - The bottom layer of nodes is not full starting from the left4) No - The tree is not complete
","rl836 (rl836 - permission to this course revoked)
"
"Imagine you're working at company that deals with stocks and your team's current project is develop a page on a website that lists companies on the stock market and allows you to monitor them in real time.A feature of this page is that you can sort the companies in a number of ways (e.g. growth in the last day, total net worth, etc.). As these details are changing in real time, the list will also needed to be re-sorted in real-time too.Your team leader has told you that:1. Consistent speed is the top priority. Every second counts in the stock market and any lag will result in complaints.2. The sort should be stable. It will cause confusion if companies with the same value were to swap seemingly randomly.3. Memory is not an issue. The company is prepared to give you as much space as you need for the sort as long as its effective.Which sort is the most appropriate for this situation?
","Insertion Sort
","Quick Sort
","Bubble Sort
","Merge Sort
","Heap Sort
","The answer is DA - Insertion Sort: Even though it is a stable sort, the average time complexity of this sort is O(n^2). There are quicker sorts available.B - Quick Sort: There are two problems with this sort. Firstly it isn't a consistent sort. It's average time complexity is O(nlog(n)) but it's worse case is O(n^2), meaning it could cause lag. Secondly, it isn't always stable so it doesn't fulfil condition 2.C - Bubble Sort: While easy to implement, it has the same issue as A in the it's average time complexity of O(n^2) and there are quicker sorts available.E - Heap Sort: While this does produce a consistent (Best, Worst and Average case are all the same) complexity of O(nlog(n)), it isn't stable so it doesn't fulfil condition 2.Merge Sort is the correct answer as:- It has a consistent time complexity of O(nlog(n))- It is a stable sortWhile it does have a high space complexity of O(n), we've been told this isn't an issue and that we should just use the most effective sort.
",
"What is the time complexity for the code below? Answer with a lower case letter with no other characters.for (int x=0; x<n; x++){ for (int y=0; y<n; y++){ total = numberArrayOne[x] * numberArrayTwo[y]; }}
","n^2
","log(n)
","sqrt(n)
","nlog(n)
","n
","It is n^2 as there are 2 for loops with a limit of n, one within the other. The pairs of x and y will be (1,1), (1,2), (1,3).....(1,n).....(n,1).....(n,n).
",
"Which of the following statements best describes an undirected graph?
","All edges go from one vertex to another in a specific direction
","There must be no edges, only vertices
","All edges are bi-directional, you can go either way along any edge
","Edges must go back to the node they came from
","None of the above
","In an undirected graph, all edges are bi-directional. You can go either way along any edge.
",
"Which of the following sorting algorithms will be the best choice for a system if a very small sorted array is passed.
","Quick Sort
","Merge Sort
","Insertion Sort
","Selection Sort
",,"A and B are both divide-and-conquer algorithms, which are bad for small sets of data, whether it is sorted or not. This leaves C and D. While they will both perform well if presented with an unsorted array, Insertion Sort is a stable sorting algorithm, meaning it takes into account the initial ordering before sorting, while Selection Sort is unstable, and therefore it doesn't. Hence, Insertion Sort will perform better as the array presented is sorted.
",
"Which statement(s) about heaps is false?
","A heap is one of the most efficient data structures for implementing a priority queue.
","A heap is a complete binary tree.
","There are two types of heaps: max-heaps and min-heaps.
","A heap is a binary search tree (BST).
","All of the above statements are false.
","A - false, a heap is one of the most efficient data structures for implementing a priority queue. (see page 5 inD&A-Lecture16-Trees4.pptx slides)B - false, aheap is a complete binary tree. (see page 6 in D&A-Lecture16-Trees4.pptx slides)C - false, there are two types of heaps: max-heaps and min-heaps. (see page 7 in D&A-Lecture16-Trees4.pptx slides)D - true: a heap is not a binary search tree, as for a given node, the right child may not be larger than the parent, and the left child may not be smaller than the parent.E - false, D is the only false statement.
",
"How many steps to find page 64 in a dictionary which has 100 pages start from page 1 using binary search?
","5
","6
","7
","8
","9
","1. (1+100)/2 = 50.5 = 51,2. 64 is not 51 and greater than 51 ----> reject 1 to 51.3. (52+100)/2 = 76,4. 64 is not 76 and smaller than 76 ----> reject 76 to 100.5. (52+75)/2 = 63.5 = 646. 64 is the correct page
",
"Flann O'Brien is an outlaw. He was attempting to hide out at point A, but realised that life there is too boring. He would like to return to point I as quick as possible. However all boats are being searched in case he's on board. With the exception of north Scotland, since the authorities are English and the Scottish referendum only happened 4 years ago... and well they're little scared to go up there.Given that Flann (if that is even his real name) wants to return as quick as possible, which route should he take?
","A,B,W,L,C,N,I
","A,B,E,L,C,N,I
","A,B,S,N,I
","A,B,W,S,N,I
","None of the above
","A) You were right. Good for you.B) So close but not quite.. you can save time by going to W skipping out E. To get to L it would be 12 instead of 13. tbh if you got this wrong you should really work on your mental arithmetic. There's some pretty good apps.C) The least towns stopped in. However time is of the essence, and this takes 20 days :(D) W-S does not exist... return directly to go, and do not collect 200 Irish francsNone of the above: while this seems a credible answer, as the trip involves going to Scotland. The only alternative is attempting to swim, and no offence but you are doing Java, so the chances of you being able to swim to Ireland are a little slim.And 'no' dying is not better than going to Scotland. It's a lovely place. The people are very nice.. most of them are, but Flann is Irish so he will get on fine.
",
"When traversing a binary tree with the pre-order traversal method, what is the order in which nodes are processed?
","Process current node, process nodes in the left sub-tree, process nodes in the right sub-tree
","Process current node, process nodes in the right sub-tree, process nodes in the left sub-tree
","Process nodes in the left sub-tree, process current node, process nodes in the right sub-tree
","gs: Trees
",,,"bobobo (arg49 - permission to this course revoked)
"
"State the complexity of the following algorithm:for(int i = 0; i < n; i++){ ListNode node = head; for (int j = 0; j < i - 1; j++){ node = node.next; } if(j > 3){ for(int k = 0; k < j; k++){ node.element += k; if(node.element >= 23){ break; } } }}node.next = new ListNode(o, node.next);
","?(n^2)
","?(n^3)
","?(2n^2)
","?(nlog(n))
","?(2nlog(n))
","While there are a lot of if and for loops, it basically is 2 for loops inside a third one, meaning it is n for the first loop, n for the second making it 2n for the inside loops, and n for the outside for loop, giving it a total of 2n^2. However, coefficients are ignored, so?(n^2).
",
"Which of the following sorting algorithms is Stable?
","Shell Sort
","QuickSort
","SelectionSort
","InsertionSort
","Heap Sort
","D insertion sort is Stable
",
"In a Skiplist where p = 1/2 (i.e the probability that the node has 1 lane is 1/2 and the probability that the node has 2 lanes is 1/4 etc...) which has 1024 nodes. How many nodes should we expect to see that have exactly 6 lanes?
","8
","16
","10
","7
","5
","There are 1024 nodes. The probability of having 6 lanes is= .So the expected number of nodes with exactly 6 lanes is: 1024 * = 16.
",
"Which of the following statements is false
","In a room with 23 people there is a 50% chance two people have the same birthday
","Post order traversal involves processing the right node, then the left node, then the current node
","An AVL tree is a BST wherethe heights of the left and right sub-treesof each node differ at most by 1
","Selection sort always has a time complexity of O(n^2)
",,"Post order traversal involves processing the left node, then the right node, then the current node
",
"What are the average and worst case complexities of searching in a binary search tree? (in respective order)
","O(n), O(logn)
","O(n), O(n)
","O(logn), O(n)
","O(logn), O(logn)
",,"The worst case happens if the tree is fully skewed to the left or right where you would have to process all the nodes of the tree giving O(n) complexity. The average case is O(logn) as the search through the tree is often split in half when comparing elements.
",
"Old MacDonald has a farm (eieio), but his farm has been bought by McDonald's for his plump, juicy chickens.Old MacDonald now works for McDonald's under a contract where, at the end of every week, he has to send them his plumpest chicken. Furthermore, if Old MacDonald still has more than 63 chickens in his farm, he must keep sending the next plumpest chicken until he has 63.To perform his job more efficiently, McDonald's promoted ""Old MacDonald"" to ""New MacDonald"" by giving him a fancy new computer, and have told him to create a data structure to assist him in consistently finding the plumpest chicken.New MacDonald is however still very inexperienced with data structures and needs some advice. He was told by McDonald's that his data structure should have the following qualities:- Removing the plumpest chicken from the list should be easy and repeatable and is of the highest priority.- Updating the weight of existing chickens and reordering the structure accordingly should be possible.- Adding newborn chickens should be possible but isn't a priority (Most eggs are used for breakfast McMuffins anyway).Which data structure should New MacDonald use?
","A Heap
","An Open Hash Table
","An AVL Tree
","A Closed Hash Table
","A Linked List
","The answer is A.B - An Open Hash Table: It would be difficult to create an good hash function for putting the plumpest chickens in a single cell, making the plumpest chickens hard to find. Updating weights would also be difficult.C - An AVL Tree: While removing the plumpest chickens would be easy enough (removing the right-most node), updating chicken weights would have to be done by removing them and re-inserting them with their new weight if the order is to be maintained properly. Another good point is that it would be easy to know when to there are more than 63 chickens (2^h - 1 = the max no. of nodes in a tree of height h and 63 = 2^6 - 1; this means that if the height of the tree is more than 6, there are more than 63 chickens).D - A Closed Hash Table: Similarly to B, creating a good hash function would for ordering chickens would be difficult, making it hard to find the plumpest chicken.E - A Linked List: Removing the plumpest chicken would be easy (remove the first or last item and change the head or tail respectively), but updating chicken weights would also have to be done by removing and re-inserting.A heap would be the best structure for New MacDonald as:- Removing the plumpest chicken is simple (you simply remove the root of the heap)- Updating chicken weights is intuitive (you can update weight and then sift up or down accordingly)- It's easy to know when there are more than 63 chickens (when the heap height is more than 6, as max no. of nodes is 2^h - 1 and 63 = 2^6 - 1
",
"1, 3, 2, 6, 5, 4, 15, 20, 17, 13, 7Above is a traversal of the tree below. Which traversal type is it? 7 / \ 4 13 / \ \ 2 5 17 / \ \ / \ 1 3 6 15 20
","Pre-order traversal.
","In-order traversal.
","Level-order traversal.
","Post-order traversal.
",,"Pre-order: 7, 4, 2, 1, 3, 5, 6, 13, 17, 15, 20 ?In-order: 1, 2, 3, 4, 5, 6, 7, 13, 15, 17, 20 ?Level-order: 7, 4, 13, 2, 5, 17, 1, 3, 6, 15, 20 ?Post-order:1, 3, 2, 6, 5, 4, 15, 20, 17, 13, 7 ??
",
"What does the following algorithm do?void algorithm(Node cur) { if (cur == null) { return; } algorithm(cur.left); algorithm(cur.right); System.out.print(cur.value + � �);}
","Level-order traversal
","Pre-order traversal
","In-order traversal
","Post order-traversal
",,"The post order traversal processes nodes in the following order:Left subtree, right subtree, current node.
",
"You are designing the emissions data recording software for a vehicle, the computer has very little ram available. Which of the following sorting algorithms is the most appropriate for you to use?
","Quick sort
","Merge sort
","Shell sort
","Insertion sort
",,"If we look at the complexities of the algorithms we see: Quick sort has O(n log(n)) average run-time and uses O(n) auxiliary memory in the worst case, Merge sort has O(n log(n)) average run-time and uses O(n) auxiliary memory, Shell sort has O(n^1.25) average run-time and uses O(1) auxiliary memory and Insertion sort has O(n^2) average run-time and uses O(1) auxiliary memory. We can see that Shell sort is the best choice as it is the fastest algorithm that uses the least amount of memory.
",
"Given the following AVL tree what would the tree look like after the insertion of ""9"". Note that all results are valid AVL Trees. The correct answer uses the balancing algorithm from the lecture.
","
","
","
","
",,"When ""9"" is inserted the tree needs to undergo a right-left rotation. This is required because the node ""8"" becomes unbalanced (balance becomes +2) due to insertion on the left node of the right subtree of 8 hence a right-left rotation is required. A brilliant explanation of rotations can be found here:https://www.tutorialspoint.com/data_structures_algorithms/avl_tree_algorithm.htm .It is important to note that balancing is done bottom up. So although the node ""7"" becomes unbalanced the balancing on ""8"" takes place first.For a better visual representation see:https://www.cs.usfca.edu/~galles/visualization/AVLtree.html
",
"Which of these statements about AVL trees is untrue?
","An AVL tree is binary
","An AVL tree is always perfectly balanced
","An AVL tree is self-balancing
","An AVL tree is a search tree
",,"An AVL tree is not necessarily perfectly balanced but it is always balanced to within +/-1.
",
"The Load of a hash table is defined as:
","average number of keys to insert
","max number of keys to insert / number of buckets in the array
","number of buckets in the array * number of keys to insert
","max number of items the hash table can store
",,"Definition from Lecture 9 page 12
",
"If a function has the following bounds:- Lower Bound f(x) = 2n2+ log(n) + n- Upper Bound f(x) = 2n2 + 2n + 1what is the Big-Theta of this function?
","2n2 + n
","2n2 + log(n)
","n2
","2n2
",,"Identifying the most significant term of both bound equations and removing constants obtains:- Lower Bound f(x) =n2- Upper Bound f(x) = n2Therefore, the Big-Theta is n2.
",
"Which of the following isnot a primitive data type in Java?
","boolean
","long
","int
","String
","double
","Java has 8 primitive data types:booleanbytecharshortintlongfloatdoubleString, however, is not a primitive data type.
",
"Which of the statements about the functions beloware all true.f(x) = 14x2 + 42x + 5xlog2xg(x) = 5x2 + 7x2log2xh(x) = 144x + 2x + 5x!i(x) = 3 + x2 + log2x
","f = O(g)g = O(h)i = T(f)
","g = O(h)f = O(h)i = T(g)
","g = O(h)h = O(f)f = T(i)
","f = O(i)h = O(g)i = T(h)
",,"Answer A - False: g? O(h)Answer B - False: f ? O(h),i? T(g)Answer C - True: All statements are true.Answer D - False: i ? T(h)
",
"Consider the following tree. (2) / \(1) (6) / \ (4) (7) / \ (3) (5)Which of the following statements are true?
","The tree requires a single rotation to balance. It can't be perfectly balanced.
","The tree requires a single rotation to balance. It will then be perfectly balanced.
","The tree requires a double rotation to balance. It can't be perfectly balanced.
","The tree requires a double rotation to balance. It will then be perfectly balanced.
",,"After first rotation, the tree becomes: (2) / \(1) (4) / \ (3) (6) / \ (5) (7).After second rotation: (4) / \ (2) (6) / \ / \(1) (3) (5) (7). Which is perfectly balanced.
",
"Which of the following is a correct expression for the sumcommonly encountered when evaluating time complexity?
","
","
","
","
","
","Add together..then divide by 2:
",
"Consider the complexities of the following.Which does not match the rest?
","inserting an element at the end of a singly linked list
","removing an element from the end of a doubly linked list
","removing an element from the front of an array list
","removing an element from the end of a singly linked list
",,"Inserting an element at the end of a singly linked list, removing an element from the front of an array list and removing an element from the end of a singly linked list all have runtime?(n)Removing an element from the end of a doubly linked list however has runtime?(1)
",
"Which nodes in the following binary tree have non-zero balance factor? 7 / \ 4 13 / \ \ 2 5 17 / \ \ / \ 1 3 6 15 20
","7, 4, 5, 13, 17
","5, 13
","13
","5, 13, 4
","None.
","BalanceFactor(N) := Height(RightSubtree(N)) � Height(LeftSubtree(N))The node '5' has a balance factor of 1.The node '13' has a balance factor of 2.All other nodes have a balance factor of 0.
",
"All of these algorithms are said to be divide and conquer algorithm except
","MergeSort
","QuickSort
","Binary search
","ShellSort
",,"Lecture 11 Sorting 2
",
"All of these sentences are true except:
","Heap data structure is implemented using a special type of binary tree.
","A heap is a binary search tree.
","A heap is one of the most efficient way to implement a Priority Queue.
","Heaps use a complete binary tree.
",,"A heap is not a binary search tree but it uses one!
",
"In a singly linked list, which of these operations has the best average runtime complexity?
","get()
","add()
","remove()
","insert()
","find()
","All the operations are dependant (on average) on the number of items in the list, apart from add(). As add() just places an item on the tail, it has a worst case runtime complexity, and therefore average, of 1.
",
"Which of these statements about quicksort is true?
","Partitioning always picks the first element in the sub-array (range) to partition
","The worst case time complexity for quicksort is O(nlog(n))
","Quicksort can only be implemented on a single thread/core
","Partitioning has a complexity of O(n)
",,"Partitioning can use other pivot points. Worst case is O(n^2), and due to being recursive can be multi threaded.
",
"What are the best, average and worst case time complexities for inserting an element into an ArrayList, respectively?
","T(1), T(log(n)),T(n)
","T(n),T(n),T(n2)
","T(1), T(n),T(n)
","T(1),T(1),T(n)
",,"Best case is when inserting the last element in ArrayList, as you just add it to the end and so O(1). Aside from this, you will most likely have to shift the ith and all following elements to the right.
",
"Consider the following algorithm:for (int i = 0; i < n; i++) { for (int j = 7; j < n2; j+2) { print i + j; }}Let f(n) be the run-time of this algorithm. Which one of the following statements is false?
","f(n) = (n3)
","f(n) = (n4)
","f(n) = O(n3)
","f(n) = O(n4)
","f(n) = (n2)
","The function f(n) = (n3) since the first loop has order n and the second loop has order n2. This means option A is okay.O represents the Upper Bound, so option C is okay.Same with option D.represents the Lower Bound, so option E is okay.Clearly n4 is not lower than n3so option B is false (the answer).
",
"What is the difference between the accuracy and the precision of a set of values?
","Accuracy is how close to the real value your measurement is while precision is how close your measurements are to each other.
","Precision is how close to the real value your measurement is while accuracy is how close your measurements are to each other.
","Precision is the number of significant figures that the measurement is calculated to while accuracy is how close to the real value your measurement is.
","Precision is how close your measurements are to each other while accuracy is the number of significant figures that the measurement is calculated to.
","None of the above.
","As seen in slide 7 here:https://moodle.bath.ac.uk/pluginfile.php/1116656/mod_resource/content/2/DA-Lecture03-Complexity1.pdf
",
"If a closed hash table uses linear probing, and has a load factor of 0.75, what is the average number of steps required to find the item?
","7/6
","2.5
","2
","3
","5
","As according to lecture 9, the formula for this is 0.5(1 + (1 / (1 - L))). 1 - L = 0.25, 1 / 0.25 = 4, 1 + 4 = 5, 0.5 * 5 = 2.5.
",
"What is the time complexity of the following?for (int i = 0; i < n; i++) { for (int j = 0; j < n/2; j++) { System.out.println(n); }}
","O(n)
","O(n log(n))
","O(log(n))
","O(n2)
","None of the above
","As it is a nested for loop, you would multiply the complexity of each for loop together to work out the overall complexity.The outer loop has complexity O(n) while the inner loop has complexity O(n/2). Therefore the overall time complexity is O(n*(n/2)) = O(n2/2) which we would generalise as O(n2).
",
"What is the difference between an open hash table and a closed hash table? (assuming the closed hash table uses linear probing)
","It's easier to delete an element in a closed hash table
","Open hash tables deal with collisions
","Open hash tables can contain more than one element in a cell
","Closed hash tables are more efficient than open hash tables when they have a higher load
",,"As defined from lecture 9, the other answers show the opposite of what is true
",
"Letf(n) = O(p(n)),g(n) = O(q(n)),h(n) = O(r(n))What is the order of f(n)g(n) + h(n) ?
","O(max{p(n), q(n), r(n)})
","O(max{ p(n)q(n), r(n) })
","O(p(n)q(n)) +O(r(n))
","O(max{ p(n)r(n), q(n)r(n)})
","O(max{ p(n)+r(n), q(n)+r(n)})
","In the case of products, if f1(n) = O(p1(n)) and f2(n) = O(p2(n)),thenf1(n)f2(n) = O(p1(n)p2(n))Sof(n)g(n) = O(p(n)q(n))In the case of sums, iff1(n) = O(p1(n))andf2(n)=O(p2(n)), thenf1(n) + f2(n) = O(max{p1(n), p2(n) })So takingf(n)g(n) = h'(n)and p(n)q(n) = r'(n), h'(n) + h(n) = O(max{r'(n), r(n)} i.e. f (n)g(n) + h(n) = O(max{p(n)q(n), r(n)})
",
"Show the resulting heap after extracting the largest item from the following tree 15 / \ 10 6 / \ / \ 5 8 3 4 / 1
","15 / \ 10 6 / \ / \5 8 3 4
","15 / \ 10 6 / \ / \5 8 1 4
","10 / \ 8 6 / \ / \5 1 3 4
","10 / \ 5 6 / \ / \1 8 3 4
","10 / \ 1 6 / \ / \5 8 3 4
","10 / \ 8 6 / \ / \5 1 3 4Copy the value from the right-most node in the bottom-most row to the root node, delete the right-most node in the bottom-most row and repeatedly swap the just-moved value with the larger of its two children until the value is greater than or equal to both of its children.
",
"What is the space complexity of merge sort?
","O(log(n))
","O(n^2)
","O(nlog(n))
","O(n)
",,"Most merge sort algorithms which use O(n) extra memory, and some may use one clone of the original array to be sorted
",
"For the following tree, what traversal method would be used to form the equation
","Pre-order
","Post-Order
","Re-order
","In-order
","None of the above
","In order traversal processes the nodes left, root, right.
",
"What is the difference between an open and a closed hash table?
","In an open hash table there is a fixed number of places elements can be stored, while in a closed hash table one can hold an arbitrary number of elements.
","In a closed hash table there is a fixed number of places elements can be stored, while in an open hash table one can storean arbitrary number of elements.
","A closed hash table is always faster than an open hash table.
","There is no difference between the two ADTs.
",,"Notes for Lecture 08 and 09.
",
"Which of the following is an example of a semantic search
","Facebook graph search
","Google search
","Binary tree search
","gs: Graphs
",,,"wleeanglin (wla24 - permission to this course revoked)
"
"A graph is an ADT that stores ...
","a set of entities.
","a set of entities and keeps track of their keys.
","a set of entities and keeps track of the relationships between all of them.
","a list of information.
",,"See Lecture 17: Graphs 1 slide 4
",
"What other ADT does the breadth first traversal algorithm use to navigate a graph?
","A List
","An Array
","A Queue
","A Stack
","An AVL Tree
","https://moodle.bath.ac.uk/pluginfile.php/1145721/mod_resource/content/2/DA-Lecture17-Graphs1.pdf - slide 29A breadth first traversal adds each connected non visited node of the current node to a queue and is then de-queued in the order they were added in order to go through the graph one layer away from the start node at a time.
",
"In what real world application would it not be appropriate to use Maxheap as a data structure?
","The severity of a patient's injuries at an emergency ward.
","The length of time the caller has been waiting on the phone at a call centre.
","Amount of shopping a customer has at a supermarket.
","Bandwidth management from a network router.
",,"It would not be appropriate to sort customers by the amount of shopping they have. Instead it is done on a first-come first-served basis.
",
"Accuracy is ...
","Measurements that are close together.
","Measurements that are exactly the same.
","Measurements close to the real value.
","Measurements that are far from the real value.
",,"See lecture 3 - slide 7.
",
"Given the following binary tree: [""I""] / \ [""D""] [""O""] \ \ [""G""] [""Q""] \ [""U""] What would the output be for level-order traversal?
","U Q G O D I
","I D G O Q U
","I O D Q G U
","I D O G Q U
","None of the above
","Level order traversal visits each level's nodes from left to right, starting from the top/root.
",
"An ADT is a coordinated group of ... that is used to solve a particular problem. (fill in the gap)
","data structures and algorithms
","algorithms and interface functions
","interface functions and data structures
","data structures, algorithms and interface functions
",,"See lecture 2 - ADT's slide 18.
",
"Which of these is a post-order traversal?
","Process current node. Process the nodes in the left subtree. Process the nodes in the right subtree.
","Process the nodes in the left subtree. Process the nodes in the right subtree. Process current node.
","Process the nodes in the left subtree.Process current node.Process the nodes in the right subtree.
","Visit each level's nodes, left to right, then move to the next level.
",,"In lecture 13 - Trees 1 the different traversals are defined.
",
"What is the time complexity of the heapsort algorithm?
","O(log(n))
","O(n)
","O(n log(n))
","O(n2)
","None of the above
","Heapsort has complexity O(n log(n)) as the first part of the heapsort (converting a random array into a maxheap) has complexity O(n) while the second part is O(n log(n)) as it takes log(n) steps to remove an item from the maxheap and this extraction operation is performed n times.Therefore the overall complexity is O(n log(n)) + O(n) with, O(n log(n)) being the dominating term.
",
"When searching a closed hash table by linear probing with a load factor of 0.5, what is the average number of steps needed to find the required element?
","1
","1.25
","1.5
","1.05
","2
","To find the average number of steps we can use the formula 0.5(1+1/(1-L)) where L is the load factor. Here this is 0.5 so we have 0.5(1+1/0.5) = 0.5(1+2) = 1.5 steps
",
"When looking at the time complexity of performing a quick sort, what is the best and worst case?
","Best case: O(n)Worst case: O(n2)
","Best case: O(n2)Worst case: O(n!)
","Best case: O(n log(n))Worst case: O(n2)
","Best case: O(1)Worst case: O(n log(n))
",,"The best case is O(n log(n)) as at each sorting level we do n operations and we have log(n) sorting levels. The worst case is O(n2) as the most log(n) can be is n.
",
"For a closed hashtable with linear probing, how many steps will it take, if the table is 70% full
","2.1667 steps
","3 steps
","1.9 steps
","4 steps
",,"The formula is 0.5(1+(1-x)) where x is the load of the table
",
"Which of the following sorts is unstable?
","Insertion sort
","Bubble sort
","Merge sort
","Selection sort
",,"Selection sort is unstable
",
"Which of the following is the correct definition of a maxheap?
","A maxheap is a binary tree which follows these rules:1. The value contained by a node is always GREATER THAN OR EQUAL TO the values of the node�s CHILDREN.2. The tree is a COMPLETE binary tree.
","A maxheap is a binary tree which follows these rules:1. The value contained by a node is always LESS THAN OR EQUAL TO the values of the node�s CHILDREN.2. The tree is a COMPLETE binary tree.
","A maxheap is a binary tree which follows these rules:1. The value contained by a node is always GREATER THAN OR EQUAL TO the values of the node�s CHILDREN.2. The tree is an INCOMPLETE binary tree.
","A maxheap is a binary tree which follows these rules:1. The value contained by a node is always GREATER THAN OR EQUAL TO the values of the node�s PARENT.2. The tree is a COMPLETE binary tree.
","A maxheap is a binary tree which follows these rules:1. The value contained by a node is always LESS THAN OR EQUAL TO the values of the node�s PARENT.2. The tree is a COMPLETE binary tree.
","See lecture 16 slide 8 for the definition of the maxheap.
",
"If you stored a graph with e edges and v vertices as an adjacency matrix, what is the asymptotic memory usage of this matrix?
","?(e*v)
","?(e^2)
","?(v^2)
","?(v+e)
","?(v)
","The conections between edges is simply stored in a v*v matrix, where a connection is denoted by a boolean. So the asymptotic storage is?(v^2). See Lecture 17 slide 18 for more detail.
",
"Given the following numbers: 7, 9, 5, 4, 8, 2, 6, 1, when constructing an AVL Tree, which numbers will be in leaf nodes (in order from left to right)?
","1, 6, 8
","1, 4, 8
","2, 6, 9
","1, 6, 9
",,"7 / \ 5 9/ /4 8/2Then do a right rotation, and add the remaining elements: 7 / \ 4 9 / \ /2 5 8/ \1 6
",
"For a B+ tree, which statement is true.
","For it to be a valid B+ tree, the left and right subtree heights must differ by at most 1.
","Internal nodes can contain any data types.
","All nodes are at least 50% full at all times except the root node.
","none of the above.
",,"The height is always balanced in a B+ tree so no difference in the left and right subtrees.Internal nodes store keys to guide the search which have a pointer to a B+ tree child node. Leaf nodes store the data which can be of any type.All nodes must be at least 50% full for a valid B+ tree
",
"Calculate the total time required to process the code below:for(i = 0; i < n; i++) { for(k = 0; k < i; k++) { System.out.println(i*k); }}
","n2- n
","n2
","nlog2n
","n2 + n
",,"The print statement has a constant complexity, and therefore let us simply refer to it as 'y'So,y * n * (n-1) /2? y/2 * (n2 - n)? n2 - n
",
"Which of the following sorting algorithms are not suitable to be used when the input consists of large data sets?
","Merge Sort
","Insertion Sort
","Shell Sort
","Quick Sort
","Heap Sort
","Insertion sort is more commonly used for sorting smaller elements, as it requires no recursion and sorts in-place
",
"Which of the following is not true about Heap Sort?
","Does not require an extra buffer.
","Requires a large amount of memory.
","It is more efficient than selection sort.
","It does not require recursion.
",,"Heap sort is most commonly used in low-RAM embedded systems due to it requiring low memory.
",
"What is the average run time of the below code:for(int w = 0; w < q; w++) for(int z = w+1; z < q*q; z++) for(int xy = z; xy < q; xy*2) sum++;
","?(log(q3))
","?(q3)
","?(q3log(q))
","?(qlog(q3))
",,"The first for loop has linear run time qThe second for loop has a run time of q^2The third for loop has a run time of log(q) due to xy2 on each iterationAverage run time = q3log(q)
",
"Which of the following AVL tree balancing techniques is used in the example below: D / \ B E / \ \ A C F \ GGoes to: D / \ B F / \ / \ A C E G
","Right Left Case
","Right Right Case
","Left Left Case
","Left Right Case
",,"Right Right because it changes the right subtree of theright subtree. It uses the method on left rotation.
",
"What does Stable mean when referring to a sorting method?
","The elements don't move
","The elements don't move more than 2 spaces to the leftor the right.
","The order of equal valued elements is maintained
","The order of equal valued elements is not maintained
",,"If equal valued elements were to change order it would be unstable.
",
"In Hashtables: After using the Hashfunctionif 2 values correspond to the same bucket, what is this called?
","Spillage
","Collision
","Overflow
","Allocation Error
",,"Lecture 8 Slide 14
",
"What is a tree in computer science?
","A treeis a linked data structure that consists of a set of exactly 5 sequentially linked records
","A tree is a data structure that can map keys to values.
","A tree is a linked list-based data structure that is used to make decisions and simplify the evaluation of mathematical expressions
","A tree is a collection of hashtables bunched together and joined by doubly linked lists in a tree shape.
","A tree is something that grows in a forest
","A tree isa linked list-based data structure that is used to make decisions and simplify the evaluation of mathematical expressions. (from Trees 1 slides)
",
"An AVL tree is created by inserting the numbers 1, 3, 7, 2, 4, 6, and 5. How many of these insertions cause the current tree to become unbalanced?
","0
","1
","2
","3
","4
","The AVL tree becomes unbalanced upon the insertion of numbers 7 and 6, so the answer is C.
",
"If Christof�s average number of steps in his open hashtable is 1.42 and the total number of buckets is 1000. What is the max no. of keys he intends to insert?
","142
","860
","420
","840
","71
","Avg steps(Open) = 1 + L/2L = max. Keys to insert / total buckets in array1.42 - 1 = L/20.84 = Lkeys to insert = 0.84*1000 = 840
",
"Attila the Hun is wanting to ravage Europe. However he is always uncertain which town to lay waste to. The Huns are currently resting.He has a database of towns ranked by GDP per capita. He wants to be able to remove towns once he's burnt every building to the ground, and add towns as refugees camps begin to form. He should be able to do this quickly as he will be tired after a long day of work. If a town with a certain GDP is not found, he should be able to find a town with similar GDP.Which of the following data structures would be most appropriate to store the list of towns?
","Singly linked list
","Sorted ArrayList
","Doubly linked list
","Binary search tree
","Closed hash table
","Singly linked list: To add or delete we have to find the nearest town first so O(n).Sorted ArrayList: we're using a database. If Attila wanted an ArrayList he'd use a scroll. Adding and removing is a lengthy process.Doubly linked list - same as singly linked listBinary search tree: easy to find close sized towns: you just look at the children or parents. May not be the closest, but will be closest in one direction. Fast to add or remove.Closed hash table: Once you remove something, searching becomes rather difficult.
",
"What is the time complexity of the following code?public void look(int a){ int ans[] = int[10]; int n = a; for(int i=0;i<n;i++){ for(int j=n;j>0;j--){ ans[i] = i*j; } } for(int i=0;i<n;i++){ System.out.println(ans[i*2]); }}
","O(n)
","O(n2)
","O(n3)
","O(log n)
","none of the above
","There is a for loop inside a for loop meaning it is n2 complexity. The other for loop does not impact this complexity.
",
"Which of the following is not true about Array lists and linked lists? (you can assume the Array list and linked list are not sorted)
","Linked Lists are faster than array lists when adding elements
","Array Lists are faster than linked lists when accessing an element at a given index
","Array Listsare faster thanLinked Lists when searching the list for a specific value/string
","Linked Lists are faster than array lists when deleting elements
",,"Because the lists are unsorted, binary search cannot be used when searching the array list for a specific value. Therefore the average complexity for a search is(as there are n elements so average number of comparisons is n/2) on both an array list and a linked list.
",
"Which of the following sorting algorithms use h-sorting?
","Shell sort
","Quicksort
","Mergesort
","Insertion sort
",,"H-sorting involves picking a value (labelled by h), for each element in the array if A[i] andA[i + h] are out of order then swaps the two elements.If you swapped any elements during the last pass, then repeat the entire process again(with the same value h) - the h value is reduced until it becomes 1 and this is used to help sort items. Shell sort is based upon this
",
"Which of the following is not a property of merge sort?
","Complexity always?(n log2 n)
","Requires extra memory compared to other sorting algorithms
","Cannot be used to sort linked lists
","It can beparallelised to run across multiple cores
","It is a stable sort
","Merge sort can be used to sort linked lists, so C is not a property of merge sort. Merge sort requires extra memory compared to other sorting algorithms as it requires n slots of extra memory for merging.
",
"Name the fastest sort method and its complexity when sorting an array that has already been sorted.
","Selection Sort
","Quick Sort
","Quick Sort
","Insertion Sort
","Insertion Sort
","If the array is already sorted, Insertion Sort makes only one comparison at each entry of the array.Therefore, the complexity is linear and this is the most efficient sort method when we are sorting something that has already been sorted.
",
"Which of these orders describes post-order traversal of a binary search tree?
","Current nodeTraverse leftTraverse right
","Traverse leftTraverse rightCurrent node
","Traverse leftCurrent nodeTraverse right
","Starting from the top, visit each node from left to right before going down to the next layer
","Starting from the bottom, visit each node from left to right before going down to the next layer
","Post order traversal traverses the left subtree,then the right, before processing the current node.
",
"What is the in-order traversal of the following Binary Search Tree: 25 / \ 17 30 / / 10 20 / \ 8 15
","8, 15, 10, 17, 25, 30, 20
","8, 10, 15, 17, 25, 20, 30
","8, 15, 10, 17, 20, 30, 25
","25, 17, 10, 8, 15, 30, 20
",,"For in-order traversal of a BST, you process the nodes in the left sub-tree first, then process the current node, and finally process the nodes in the right sub-tree. Thus, the correct answer is B.
",
"For the Algorithm and data structure of hash tables, which of the following is recommended?
","It is suitable to search, insert and delete data in a closed hash table.
","For the efficiency, we can substitute all, random type of hash tables to open hash tables with many buckets in a program with extremely limited memory.
","With enough memory space, we can change the pointers of storing array by storing a linked list of values instead of a directly value.
","Any functions can be defined as hash functions for an efficient hash table data structure.
","None of the above.
","A. (D&A-Lecture08-Hashtables1.pptx)Only use Closed/Linear Probing hashtables if you never remove items!B. (D&A-Lecture09-Hashtables2.pptx)Cosidering the memory space, open hashtables with lots ofbuckets still needs memory.C. (D&A-Lecture09-Hashtables2.pptx) Correct, the definition of open hashtable.D.(D&A-Lecture09-Hashtables2.pptx) Hash functions ofan efficient hash table need to give same datathe same bucket, to disperse items throughout the hash array as randomly as possible.
",
"True or False, an Unstable sort reorders items while taking into account their initial order.
","TRUE
","FALSE
","planation: An unstable sort reorders items without taking into account their initial order.
","gs: Sorting
",,,"sammie (sh2389 - permission to this course revoked)
"
"Which of the following statements is false?
","The selection sort is unstable and has ?(n2) complexity for its best case, worst case and average case.
","The heap sort is stable and has ?(n(log(n))) complexity for itsbest case, worst case and average case.
","The shell sort has the time complexity of approximately ?(n1.25). It is unstable.
","The quick sort has?(n(log(n))) best and average case time complexity but has?(n2) time complexity for mostly ordered arrays. It is unstable.
","The merge sort has time complexity?(n(log(n))) for its best case, worst case and average case. It is a stable sort.
","The answer is B because the heap sort is unstable.
",
"Which statement is true?
","Selection sorts cannot be applied to linked lists.
","Insertion sort cannot be applied to linked lists.
","Quick sort can be applied to linked lists.
","Merge sort cannot be applied to linked lists.
",,"All the sorts above can be applied to linked lists.
",
"How many elementary operations does this function have and what is the value of total after the for loop has finished?public void total() { int x = 4; int total = 0; for (int i=0; i<x-1; i++) { total = total + i; }}
","elementary operations: 3x+4total=3
","elementary operations: 4xtotal=2
","elementary operations: 2+3xtotal=4
","elementary operations: 3+4xtotal=3
","None of these options
","int x=4Variable assignment : 1 operationint total=0 Variable assignment : 1 operationint i=0 Variable assignment : 1 operationi<x-1 Comparison: 1 operation carried out x times: x operationsi++ Addition that occurs x times: x operationstotal + i Addition that occurs x times: x operationstotal = ... Assignment that occurs x times: x operationsSo the T(n) is the total of these, which is 1+1+1+x+x+x+x
",
"What is the complexity of the following, given that the methods checkPassword, hackProfessor and openMozilla Firefox are of constant complexity?int n = password.length(); int findPassword = 0; int x=1;for( int j = 0; j < n; j++){ int x=x*10;}for( int i = 0; i < x; i++;){ for(password.checkPassword(findPassword) == false) findPassword++;}}password.hackProfessor(findPassword);for (int i2 = 1; i2 <= n; i2++) { for(int j2 = 1; j2 <= n; j2++) { openMozillaFirefox(https://www.youtube.com/watch?v=oavMtUWDBTM); }}
","O(n)
","O(n^2)
","O(n^10)
","O(10^n)
","None of the above.
","It is a terrible brute force algorithm, but it will work. Or at least I think it will, given a number combination.The password cracking loop will iterate for 10^n, as x=10*10*10 ... *10 = 10^n.Wheras spam link loop is only n^2.
",
"For a list of size n=30,000what would be the average search time for an element in the list using binary search?
","7.44
","11.02
","12.83
","14.87
","22.31
","average search time for binary search is given by O(log2(n)) where n is size of listgiven that n = 30,000:avg search time = log2(30,000) = 14.8726...Ans(D): 14.87
",
"Take the following steps:Select an arbitrary �pivot� element P from the array (typically the first element in the array).If the array contains only 0 or 1 element, return.Move all elements that are = P to the left of the array and all elements > P to the right.Recursively repeat this process on the left sub-array Conquer and then the right sub-array.What sorting algorithm do they describe and what is it's average time complexity?
","Quick sort, N
","Merge sort, N^2
","Quick sort, Nlog(N)
","Insertion sort, N^2
","Merge sort, Nlog(N)
","These steps describe the quick sort algorithm which has an average run-time complexity of Nlog(N).
",
"Order these from quickest to slowest when n is close to infinity:Square root: sqrt(n)n log(n)Cubic: Quadratic: Logarithmic: log(n)Exponential: Linear: nConstant: 1
","Square root: sqrt(n)n log(n)Cubic: Quadratic: Logarithmic: log(n)Exponential: Linear: nConstant: 1
","n log(n)Cubic: Logarithmic: log(n)Square root: sqrt(n)Quadratic: Exponential: Constant: 1Linear: n
","Constant: 1Logarithmic: log(n)Square root: sqrt(n)Linear: nn log(n)Quadratic: Cubic: Exponential:
","Constant: 1Logarithmic: log(n)n log(n)Square root: sqrt(n)Exponential: Linear: nQuadratic: Cubic:
",,,
"What does this formula calculate?And what does represent?
","Standard DeviationReference values
","VarianceElements
","Standard DeviationElements
","VarianceReference Values
",,"The formula calculates the standard deviation which helps quantify precision, using N the number of elements,the list of elements, and the mean of the elements.
","cro26 (cro26 - permission to this course revoked)
"
"What does this formula calculate?And what does represent?
","Standard DeviationReference values
","VarianceElements
","Standard DeviationElements
","VarianceReference Values
",,"The formula calculates the standard deviation which helps quantify precision, using N the number of elements,the list of elements, and the mean of the elements.
","cro26 (cro26 - permission to this course revoked)
"
"If we start on node 7, using depth search, which node would be processed last?When selecting the next node to search, choose the smallest node.For example;7 has the choice of going to node 4 and 5It will search node 4 because 4 is less than 5
","3
","5
","1
","6
",,"The nodes are processed in this order:7, 4, 1, 2, 3, 6, 5
",
"Which of the following sets of sorting algorithms lists all that implement the divide and conquer approach?
","Mergesort, Quicksort and Heapsort
","Mergesort, Insertionsort and Heapsort
","Quicksort and Heapsort
","Mergesort and Heapsort
","Insertionsort, Bubblesort and Quicksort
","Merge Quick and Heap all use divide and conquer, while insertion and bubble use a different approach to sorting.
",
"Which of the taught sorting algorithms would be expected to be the quickest for a mostly-sorted array?
","Bubble Sort
","Shell Sort
","Insertion Sort
","Merge Sort
",,"Insertion sort has complexity O(n) for mostly-sorted/sorted arrays. However, Bubble sort also hascomplexity O(n) for mostly-sorted/sorted arrays but requiresat least 2 passesthrough the data in comparison to insertions sort's required1pass -meaninginsertion sort is fasteron average.Merge SorthasT(n�lg(n))regardless of how sorted the array is, so clearly this isn't the best choice.Shell Sortis dependent on theincrement sequence, but overall cannot be faster thaninsertion sort formostly sorted arrays.Insertion Sort wins overall.
",
"An algorithm takes 2 seconds to run for n items. If we were to increase number of items to 3n, what would we expect the new runtime to be closest to for the following complexities?i)ii)iii)
","i) = 18ii) = 23kiii) = Cant tell without further information.
","i) = 18ii) = 2(3k)iii) = 23n + 1
","i) = 18ii) = 3(2k)iii) = 2(23n)
","i) = 12ii) = 23kiii) = Cant tell without further information.
",,"For i) - increasing n by a factor of 3 would lead to an increase of time taken by a factor of 9: 2 x 9 = 18 seconds (expected).For ii) -increasing n by a factor of 3 would lead to an increase of time taken by a factor of 3k leading to 2(3k) seconds.NOT to be confused with 23k or 3(2k).For iii) -increasing n by a factor of 3 would lead to an increase of time taken by a factor of 23n - this leads to an expected time of 2(23n) = 23n + 1seconds.Meaning the only possible answer is b).
",
"What is the correct definition for the upper bound ?
","
","
","
","
",,"Compare with lecture
",
"The following is an AVL tree. The element 17 is added, and the element 20 is added. Which elements are the root, and the roots children?
","The root: 21The roots left child: 12The roots right child: 33
","The root: 18The roots left child: 12The roots right child: 21
","The root: 21The roots left child: 16The roots right child: 33
","The root: 18The roots left child: 16The roots right child: 21
","None of the above.
","After adding the 17, you do a double rotation to rebalance to form: 21 16 33 12 18 637 17 19Then you add 20 and rebalance with the opposite double rotation to get: 18 16 21 12 17 19 337 20 63Hopefully this is clear. If not write it out. If you can't read above, then I am guessing you are on a phone: don't be.
",
"Say we have a linked list with a tail reference. What would the code look like to add a node to the end of the non-empty list?Nodes have following code:class ListNode { Object element; ListNode next; ListNode(Object e, ListNode n) { element = e; next = n; }}
","ListNode newNode = new ListNode(o, null);tail.next = newNode;tail = newNode;
","ListNode newNode = new ListNode(o, null);tail = newNode;
","ListNode newNode = new ListNode(o, null);tail = newNode;tail.next = newNode;
","head = new ListNode(o, head);
",,"For B: we haven't pointed the old tail node to this new node.For C: We have pointed tail towards new node, then set this new node's next to itself. Also haven't pointed old tail node to this new node.For D: we have added the node to the front, not the end.So A is correct. We have pointed old tail node to the new node and then pointed tail towards the new node.
",
"Say we have a graph where the nodes are based on major cities in England and the edges are the major motorways. We want to get data for where we can get using only 1 motorway, then get data for 2 motorways, 3 motorways and so on. Which traversal strategy should we use?
","Random-edge traversal
","Breadth-first traversal
","Adjacency traversal
","Depth-first traversal
","Quick-leap traversal
","The only 2 real strategies are depth-first and breadth-first. Depth-first goes all the way to a dead end before searching the rest of the graph, this isn't useful as we want only the nodes which are 1 edge away first. Breadth-first gives us what we want.
",
"Say we want to store data in a graph. The data shows which factories, that produce certain resources, supply to some of the other factories. There are 100 factories, each of which deliver resources to approximately 15 other factories each. How shall we store the graph?
","Use a 2D array
","Use a picture of what the graph looks like
","Use an array of linked lists
","Use a skip list
","Use a tree where each node has 15 children
","If we were to use an array there would be 10000 data points, whereas the array of linked lists only has 1500 data points.
",
"Say we have a heap, which is stored in an array, and a node at index n. What are the indexes in the array of the children of this node?
","2n, 2n+1
","2n+1, 3n+1
","2n+1, 2n+2
","2n, 4n
","n+1, n+2
","This means that there is never an overlap in the indexes of children of a node and another node. If we didn't have the +1 then the 0th index node would have a child in the 0th index.
",
"The poles for the 2080 US election are in. However there has been a mistake: they were meant to be sent in by alphabetical ordering of the 3242 county names, but certain counties sent their data in early or late. This has meant that the list is ordered incorrectly, with a positioning error term of at most 4. Jim, whose job is on the line, has very little time to fix the mistake. Given that his reading skills are limited, and his computer is incredibly slow, which sorting method should he use.
","Insertionsort
","Quicksort
","Selectionsort
","Bubblesort
","Can't answer, unless the list is shown.
","Bubblesort: since the list is mostly sorted. Would be O(n) rather than O(nlog(n)). And would take at most 4n comparisons.
",
"Array List:Which of the following statements about Array Lists is false?Note: assume theArray List is unsorted.
","Array Lists support random access, so the element at a given position can be accessed in T(1).
","The average case runtime complexity for inserting into any position in the the array list is T(n).
","The best and worst case runtime complexity for finding an element is the same.
","The best case runtime complexity for removing an element from the array isT(1).
","The best case runtime complexity for adding an element to the end of the array is T(1).
","Statement A is true.The answer is not B because the best case runtime complexity for inserting into the array list and removing from the array list isT(1).The answer is C as the best case runtime complexity for finding an element is T(1) and worst case runtime complexity for finding an element isT(n).The answer is not D because the best case runtime complexity for removing an element from the array is T(1).The answer is not E as the best case runtime complexity for adding an element to the end of the array is T(1).
",
"In the worst case, what is the complexity of insertion sort?
","O(n)
","O(n^2)
","O(n^3)
","O(log(n))
","None of the above.
","During each round of the algorithm we consider a larger set.The first time we may need to compare and shift one element.The second time we may need to compare with and shift up to two elements....The final time we may need to compare and shift up to (n - 1) elements.1 + 2 + ... + (n - 1) = roughly n^2 steps.Therefore, in the worst case, insertion sort is O(n^2).
","rm896 (rm896 - permission to this course revoked)
"
"In the worst case, what is the complexity of insertion sort?
","O(n)
","O(n^2)
","O(n^3)
","O(log(n))
","None of the above.
","During each round of the algorithm we consider a larger set.The first time we may need to compare and shift one element.The second time we may need to compare with and shift up to two elements....The final time we may need to compare and shift up to (n - 1) elements.1 + 2 + ... + (n - 1) = roughly n^2 steps.Therefore, in the worst case, insertion sort is O(n^2).
","rm896 (rm896 - permission to this course revoked)
"
"The following is a binary search tree (BST) where we have just inserted the node '13':We are trying to maintain a valid AVL tree. In this case, at what node (if any) is this tree unbalanced and what type of rotation(s) are necessary to balance the tree?
","Node '14' is unbalanced. Right rotation (i.e. a right rotation about node '14').
","Node '14' is unbalanced. Left-right rotation (i.e. a left rotation about node '12' followed by a right rotation about node '14').
","Node '12' is unbalanced. Left rotation (i.e. a left rotation about node '12')
","Node '12' is unbalanced. Right rotation (i.e. a right rotation about node '12')
","No node is unbalanced. No rotation(s) necessary.
","The balance of a node in an AVL tree is defined as the height of the left sub-tree minus the height of the right sub-tree. An AVL tree is unbalanced if the balance of a node is greater than 1 or less than -1.Therefore, we see that the node '14' is unbalanced with a balance of -2.We now want to apply a rotation (or two) to balance the tree.Clearly this will involve a right rotation at some point (as it is the left sub-tree which has the greater height). However, if we apply a right rotation straight away we will have a tree that is still unbalanced. The balance will be +2 at node '12' which has replaced node '14' as nodes '13' and '14' will both be in the right sub-tree.Therefore, we want to apply a left-right rotation which firstly does a left rotation about node '12' followed by a right rotation around node '14'.We will then end up with the following AVL tree (which is not only balanced, but perfectly balanced in fact!):
",
"What is the average number of steps to find a bucket in and open and closed hash table with a load factor of 0.99?
","Closed: 1.495 StepsOpen: 50.5Steps
","Closed: 12 StepsOpen: 1.4 Steps
","Closed: 50.5StepsOpen: 1.495Steps
","Closed: 1.4 StepsOpen: 12 Steps
",,"Open no of steps = 1 + L/2Closed no of steps = 1/2(1+1/(1-L))
",
"What is the definition of an AVL tree?
","Any tree thathas a difference of the number of nodes between any node's left and right sub-trees of at most one.
","A binary search tree that has adifference of the number of nodes between any node's left and right sub-trees of at most one.
","A heap tree in which the height of the left and right sub-trees of each node differ by at most one.
","A binary search tree in which the height of the left and right sub-trees of each node differ by at most one.
","Any tree in which the height of the left and right sub-trees of each node differ by at most one.
","https://moodle.bath.ac.uk/pluginfile.php/1144766/mod_resource/content/3/DA-Lecture15-Trees3.pdf - Definition stated on page 5
",
"What is(n)?
","The upper bound of complexity.
","The average complexity.
","The lower bound of complexity.
","The exact bound of complexity.
","The amortised average of complexity.
","https://moodle.bath.ac.uk/pluginfile.php/1117431/mod_resource/content/4/DA-Lecture04-Complexity2.pdf - page 6
",
"Which of the following statements is false?
","Divide and conquer sorting algorithms work recursively via:1. dividing the elements to be sorted into two equal sizes2. sort each of these smaller groups of elements3. combine the two groups into one large sorted list
","Unstable sorting re-orders items without taking into account their initial ordering
","Insertion Sort is useful for small already sorted datasets
","Selection Sort is astable sort
","Merge Sort works equally well regardless of the ordering of the data
","In selection sorts,the relative order of elements with the same value is not maintained.
",
"Which of the following statements are true?
","Selection Sort and Insertion Sort, are both stable.
","Merge Sort and Shell Sort are Stable and Unstable respectively.
","Heap Sort, Quick Sort and Bubble Sort are Unstable, Unstable and stable respectively.
","B and C.
","None of the above.
","Selection Sort - UnstableInsertion Sort - StableBubble Sort - StableShell Sort - UnstableQuick Sort - UnstableMerge Sort - StableHeap Sort - Unstable
",
"For ?(n2), which of the following is true.
","When n is doubled, time is increased by a factor of 8.
","Doubling n increases T by factor 4
","When doubling n, T increases only by a constant
","A constant increment of n leads to increase of T by factor
","none of the above
","For ?(n2) when n is doubled, the Time is increased by a factor 2, which is also the exponent value in the Big ? expression.
",
"How many iterations will it take to sort the following array into ascending order using a selection sort?2,5,1,3,4,6
","1
","2
","3
","4
","None of the above
","It will take 4 iterations to sort the array.
",
"Which of the following statements about linked lists and arrays is false?
","Returning an item at a particular index is faster with an Array than it is with a linked list
","Inserting a new item at the front of a linked list is faster than inserting an item at the front of an array
","Removing an item from the middle of an array is faster than removing an item from the middle of a linked list
","Arrays are easier to program and debug than linked lists
","None of the above are false
","It is faster to remove an item from the middle of a linked list as you simply update the pointers of the previous and next nodes. With an array you must shift all items to the left.
",
"A tree node which has zero children is called ___?
","a root
","a child
","a leaf
","a parent
","None of the above
","A leaf node is a tree node which has zero children.
",
"Given the following incomplete Java code for selection sort, which code must go at the place marked with X?public static void selectionSort(String[] array) { for(int i = 0; i < array.length; i ++) { int minimumIndex = i; X }}
","for(int j = i; j < array.length; j ++) { if(array[j].compareTo(array[minimumIndex]) < 0) { minimumIndex = j; } String temporaryValue = array[i]; array[i] = array[minimumIndex]; array[minimumIndex] = temporaryValue;}
","for(int j = i + 1; j < array.length; j ++) { if(array[j].compareTo(array[minimumIndex]) < 0) { minimumIndex = j; } String temporaryValue = array[i]; array[i] = array[minimumIndex]; array[minimumIndex] = temporaryValue;}
","for(int j = i + 1; j < array.length; j ++) { if(array[j].compareTo(array[minimumIndex]) < 0) { minimumIndex = j; } String temporaryValue = array[i]; array[minimumIndex] = temporaryValue;}
","for(int j = i + 1; j < array.length; j ++) { if(array[j + 1].compareTo(array[minimumIndex]) < 0) { minimumIndex = j; } String temporaryValue = array[i]; array[i] = array[minimumIndex]; array[minimumIndex] = temporaryValue;}
","for(int j = i; j < array.length; j ++) { if(array[j].compareTo(array[minimumIndex]) < 0) { minimumIndex = j; } String temporaryValue = array[i]; array[minimumIndex] = temporaryValue;}
","A - incorrect due to the for loop initialising j to i and not i + 1.B - correctC - incorrect due to swapping at the end being incompleteD - incorrect due to the if statement comparing the array[j + 1] element and not element array[j] to the array[minimumIndex] elementE - incorrect due tothe for loop initialising j to i and not i + 1, and theswapping at the end being incomplete
",
"Which of the following sorting algorithms is the fastest for an input array of integers, int[] array, which in fact is already sorted?
","void A(int[] array) { for (int i=2; i<=array.length; i++){ int j = array[i-1]; int k = i-2; while (k >= 0 && j < array[k]){ array[k+1] = array[k]; k--; } array[k+1] = j; }}
","void B(int[] array) { int i = array.length; int j = 0; for(int k=0; k < i; k++){ for(int l=1; l < (i-k); l++){ if(array[l-1] > arr[l]){ j = array[l-1]; array[l-1] = arr[l]; arr[l] = j; } } }}
","void C(int[] array) { int n = array.length; for (int i=0; i < n; i++){ int k = i; for (int j=i+1; j < n; j++){ if (array[j] < a[k]) k = j; } int l = array[i]; array[i] = array[k]; array[k] = l; }}
","A and B
","B and C
","The algorithm A is the insertion sort, B corresponds to a bubble sort and C to a selection sort. For an array which is already sorted, the insertion array is the fastest, as its time complexity is given by?(n) because the second condition in the while loop is never met (j < array[k]). Meanwhile, the time complexity of the selection sort is always?(n^2), and the time complexity of the bubble sort in this case is also?(n^2).
",
"Which of the following options is the correct output for the post-order traversal of this tree?
","4, 8, 9, 10, 12, 14, 18
","4, 9, 8, 18, 14, 12, 10
","10, 8, 4, 9, 12 ,14 18
","10, 8, 12, 4, 9, 14, 18
","None of these outputs
","The post-order traversal processes the nodes in the left subtree first. Then it processes the nodes in the right subtree. Finally, it processes the current node.
",
"How many nodes does a full binary tree of depth d have?
","2^d
","2^d - 1
","2^(d+1) - 1
","2^(d+1)
",,"The number of nodes on depth level n is 2^n, so in total a full binary tree of depth d will have 2^(d+1) - 1 nodes.
",
"Is it allowed to remove elements from a closed hash-table that uses linear probing, and why?
","Yes, if the load factor (alpha) is kept low. Otherwise, no.
","Yes, because a closed hash-table does not need to be full at all times.
","Yes, because each index in the hash-table points to a linked-list in which it is possible to freely add and remove elements.
","No, because there may be other elements with the same hash value coming after the given element.
","No, because removing an element means that another element cannot be placed at the given index afterwards by the hash function.
","A - this is false, because the load factor does not have a role to play in this answer. Even if it is kept low, the situation described in answer D may still occur.B - this is false, because this answer disregards the situation explained in answer D, below.C - this is false, because this answer refers to open hash-tables which have linked lists at each bucket/index.D - this is correct, because removing an element in a closed hash table using linear probing may lead to a premature search abortion at the empty slot, even though there may be elements with the same hash value coming after the given element being removed.E - this is false, because when an element is removed from a given index, another element can be placed there afterwards. However, it does not explain why we cannot remove an element from a closed hash-table which uses linear probing.
",
"In big O notation which of the following best describes the function f(n) = 2n + nlog(n) + 0.5^(0.5n)?
","O(n)
","O(0.5^(0.5n))
","O(log^2(n))
","O(n^2)
",,"For large enough n, 0.5^(0.5n) becomes the domination term, and is greater than the others.
",
"Which boolean expression indicates whether the objects in two linked list nodes (l and m) are the same?[using the code from the problem sheet:class ListNode { Object element; ListNode next = null; ListNode(Object e, ListNode n) { element = e; next = n; }}]
","l == m
","l.next == m.next
","l.element == m.element
","l.element.equals(m.element)
","None of the above
","class ListNode { Object element; ListNode next = null; ListNode(Object e, ListNode n) { element = e; next = n; }}In our ListNode construction, the objects of each node are stored in element.l == m would not work, as Java cannot test whether two of our ListNodes are the same in this way (by default).l.next == m.next checks whether the nodes that l and m are pointing to are the same (which would always be false by our construction).l.element == m.element can only be used for numbers.
",
"What is the runtime when using Counting Sort for sorting n numbers with maximum d digits with basis k based on their digits?
","?(n2)
","?(log n)
","?(n)
","?(dn2)
","?(k log n)
","Given that for counting sort the runtime is ?(n) to count occurrences and ?(k+n) to scan the count array andbuild the output then the runtime is?(d*(k+n)) where d and k are constants so?(n).(Lecture 12)
",
"Given an array of elements 5, 3, 6, 2, 1, 4, 7, how many iterations of h-sorting with h=2 would be required before we need to move on to h=1?
","1
","2
","3
","4
","None of the above
","1st iteration gives us: 5, 2, 1, 3, 6, 4, 72nd iteration gives us: 1, 2, 5, 3, 6, 4, 73rd iteration to check: 1, 2, 5, 3, 6, 4, 7No swaps occurred in our 3rd iteration so we are done.
",
"Which of the following statements is/are true?When using a classical binary tree node with links to implement a heap:1) It is hard to find a node's parents to do reheapification swaps2) It is hard to find the bottom-most, left-most node during extraction3) It is hard to find the bottom-most, right-most open spot to insert a new node during insertion
","Only 1
","Only 2
","Only 3
","Only 1 and 2
","All of the above
","""1) It is hard to find a node's parents to do reheapification swaps"" is correct""2) It is hard to find the bottom-most, left-most node during extraction"" is incorrect: It is hard to find the bottom-most, right-most node during extraction""3) It is hard to find the bottom-most, right-most open spot to insert a new node during insertion"" is incorrect: It is hard to find the bottom-most, left-most open spot to insert a new node during insertion(Lecture 16)
",
"What will be the output of a pre-order traversal of the following tree if each node processed is printed out? 10 / \ 4 12 / \ \ 2 6 16
","2, 4, 6, 10, 12, 16
","2, 6, 4, 12, 16, 10
","10, 4, 2, 6, 12, 16
","10, 4, 12, 2, 6, 16
","10, 12, 16, 4, 6, 2
","The pre-order traversal algorithm is as follows:void preOrder(Node cur) { if (cur == null) { return; } System.out.print(cur.value + � �); preOrder(cur.left); preOrder(cur.right);}Thus, we start at the root and print out the value 10. Then we recursively process the nodes in the left sub-tree, printing out 4, then 2.At this point the 'cur' node will be null, and thus return. Then the algorithm works its way 'upwards' printing out the values of the right sub-trees.The resulting output is:10, 4, 2, 6, 12, 16
",
"For this function what is the complexity class of Big theta (?)?for ( int i = 0; i < q * 100; i++ ) { for ( int j = 0; j < q; j++ ) { sum++; }}
","?(q)
","?(q3)
","?(q2)
","?(log(q))
",,"Lecture 5 slide 7
",
"Which of the following options is true for this tree? 8 / \ 4 12 / \ / \ 3 5 10 17 / \ / \ 2 11 15 18 / \ 14 16
","The tree is balanced and has a balance of +1
","The tree is unbalanced and has a balance of +2
","The tree is balanced and has a balance of -1
","The tree is unbalanced and has a balance of -2
",,"The tree is right-heavy. The maximum depth of left hand side of the tree is 3 (8-4-3-2) and the maximum depth of the right hand side of the tree is 4 (8-17-15-16(or-14). This means the overall balance is -3 + 4 = 1
",
"An h-sort with an h-value of 1 is equivalent to what other sorting algorithm?
","Quicksort
","Insertion Sort
","Selection Sort
","Bubble Sort
",,"Bubble sort: go through array A and if A[i]>A[i+1] swap themShell sort: go through array A and if A[i]>A[i+h] swap themHence when h=1 they're the same
",
"Which traversal is being used when you find the numbers 4, 2, 6, 1, 3, 5, 7 (in that order) for the given tree:
","In-Order Traversal
","Pre-Order Traversal
","Post-Order Traversal
","Level-Order Traversal
",,"Level-Order Traversal goes through each level of nodes at a time from left to right, therefore, it will start at the top with 4, then 2 and 6 on the 2nd row of nodes, followed by 1, 3 ,5 and 7 on the final row.
",
"How many operations does the following code take?var x = 0;for(var i = 0; i < 2; i++) { x++;}
","8
","11
","15
","9
","13
","var x = 0;This is 2 operations (declaring a variable, and assigning it a value).var i = 0;This is 2 operations (declaring a variable, and assigning it a value).i < 2; This is 1 operation (happens 3 times).i++; This is 1 operation (happens 2 times).x++; This is 1 operation (happens 2 times).Therefore, 2 + 2 + (3 x 1) + (2 x 1) + (2 x 1) = 11
","ajb258 (ajb258 - permission to this course revoked)
"
"How many operations does the following code take?var x = 0;for(var i = 0; i < 2; i++) { x++;}
","8
","11
","15
","9
","13
","var x = 0;This is 2 operations (declaring a variable, and assigning it a value).var i = 0;This is 2 operations (declaring a variable, and assigning it a value).i < 2; This is 1 operation (happens 3 times).i++; This is 1 operation (happens 2 times).x++; This is 1 operation (happens 2 times).Therefore, 2 + 2 + (3 x 1) + (2 x 1) + (2 x 1) = 11
","ajb258 (ajb258 - permission to this course revoked)
"
"When representing a graph with a very large number of nodes, is it more efficient to use a adjacency matrix oradjacency list?
","adjacency matrix
","adjacency list
","planation: Imagine a large number of nodes which may have any number of relationships with each other, a matrix requires n2 array entries, while an adjacency list contains n + ai, where i is the index of the node, and ai is the number of edges coming from that node.
","gs: Graphs
",,,"awh28 (awh28 - permission to this course revoked)
"
"If g(n) = O(f1(n)) & h(n) = O(f2(n)) then g(n) + h(n) =O(f1(n)) + O(f2(n))
","TRUE
","FALSE
","planation: g(n) + h(n) = O(Max{f1(n), f2(n)})
","gs: Complexity
",,,"gtr25 (gtr25 - permission to this course revoked)
"
"What is the worst case time complexity of insertion sort?
","
","
","
","
","
","Best case of insertion sort, when an array is nearly ordered, is , but in all other cases it is .
",
"What is the time complexity of searching an AVL tree?
","O(log n)
","O(n)
","0(n log n)
","None of the above
",,"The number of nodes left to search is halved after each element is traversed.
",
"Given the following directed graph:what is the corresponding adjacency matrix?
","
","
","
","
",,"As this is a directed graph, for every edge from i to j, [i][j] in the matrix is filled.
",
"Which Representation of a graph should you use for a dense graph?
","AnAdjacency list
","An Adjacency matrix
","planation: A graph that has many edges between the vertices is called a �dense graph�.You should use anAdjacency matrix if you have lots of edges between vertices
","gs: Graphs
",,,"guy (grmb20 - permission to this course revoked)
"
"What does it mean for a Binary Tree to be 'perfectly balanced'?
","For each node, the number of nodes in its left and right subtrees are equal.
","For each node, the number of nodes in its left and right subtrees differ by at most one.
","For each node, the values stored in the nodes of its left and right subtrees are the same.
","The height of the binary tree is less than 7.
","There are no leaf nodes in the binary tree.
","""A binary tree is �perfectly balanced� if for each node, the number of nodes in its left and right subtrees differ by at most one."" - Lecture 14 slides.
",
"What is the 'Big-Oh' time complexity of traversing a binary tree?
","O(n log n)
","O(n2)
","O(log n)
","O(n)
","O(1)
","When traversing a binary tree, each node is visitedexactly once. Therefore, for a binary tree withnnodes, the 'Big-Oh' time complexity isO(n).
",
"Which Binary Tree traversal method uses the following algorithm?Process the current nodeProcess the nodes in the left subtreeProcess the nodes in the right subtree
","Post-order
","Pre-order
","In-order
","Level-order
",,"This is the algorithm for the pre-order method.For post-order:Process the nodes in the left subtreeProcess the nodes in the right subtreeProcess the current nodeFor in-order:Process the nodes in the left subtreeProcess the current nodeProcess the nodes in the right subtreeFor level-order:Use a temp pointer variable and a queue of node pointersInsert the root node pointer into the queueWhile the queue isnot empty:Dequeue the top node pointer and store it intempProcess the nodeAdd the node's children to the queueif they arenotNULL
",
"What is the time complexity of this function?int bigSnack(int n) { int hi = 0; for (int x=0;x<n;x++) { for (int b=0;b<n;b++) { hi = hi + 5; } }return hi;}
","O(n^2)
","O(log n)
","O(n)
","O(1)
",,"each loop is run n times, so O(log n)
",
"Which of these sorts has the average time complexity of T(n log(n))
","Merge Sort
","Insertion Sort
","Selection Sort
","Bubble Sort
","None of the Above
","Merge sort has average time complexity of T(n log(n)) whereas each of the others have the time complexity ofT(n^2).
","dtfl20 (dtfl20 - permission to this course revoked)
"
"Which of these sorts has the average time complexity of T(n log(n))
","Merge Sort
","Insertion Sort
","Selection Sort
","Bubble Sort
","None of the Above
","Merge sort has average time complexity of T(n log(n)) whereas each of the others have the time complexity ofT(n^2).
","dtfl20 (dtfl20 - permission to this course revoked)
"
"Given the following tree: 13 / \ 10 16 / \ / \ 7 11 15 24what is the order of traversal when doing a pre-order traversal?
","13, 10, 16, 7, 11, 15, 24
","7, 10, 11, 13, 15, 16, 24
","13, 10, 7, 11, 16, 15, 24
","7, 11, 10, 15, 24, 16, 13
",,"A is a level-order traversal. B is an in-order traversal. C is a pre-order traversal. D is a post-order traversal.
",
"What is the big theta notation for this code:for(int i = 0; i < (1000n + 5)n; i++) { for(int j = 0; j < n2+ 7n + 2; j++ ) { acc ++; }}for(int k = 0; k < n3 + n2; k++) { sum++;}
","?(n3)
","?(n5)
","?(n4)
","?(n2)
",,"Two for loops nested within each other means that the conditions are added together so n2+ n2 is n4 .
",
"Given the matrix:0 1 0 00 0 1 00 0 0 10 0 0 0Which matrix is this the output dictating nodes which are three edges apart?
","0 1 0 00 0 1 00 0 0 10 0 0 0
","0 0 1 00 0 0 10 0 0 00 0 0 0
","0 0 0 10 0 0 00 0 0 00 0 0 0
","1 0 0 00 1 0 00 0 1 00 0 0 1
","1 0 0 00 0 0 00 0 0 00 0 0 0
","If you times the original matrix by itself three times, you get that answer.
",
"What additional property must an AVL tree have over a generic Binary Search Tree?
","The values of the children of any node differ by at most 1
","The balance of the children of any node differ by at most 1
","The height of the left and right sub-trees of any node differ by at most 1
","The root node must contain the maximum value
","The height of the left sub-tree must be less than or equal to the height of the right sub-tree
","An AVL tree is a BST in which the heights of the left and right sub-trees of each node differ at most by 1See: D&A-Lecture15-Trees3.pptx (slide 5)
",
"Which of the following ADTs is the best way to store data for a social network like Facebook?
","B- Trees.
","Hashtables.
","Undirected graphs with an adjacency matrix.
","Undirected graphs with an adjacency list.
",,"Undirected graphs are best because it is easy to visualise relationships between vertices thanks to edges. An adjacency list is the better option because of memory efficiency and the ease of adding new vertices.
",
"Which type(s) of sorting use recursion?i. Mergesort.ii. Quicksort.iii. Heapsort.
","i only.
","ii only.
","i and ii.
","All of the above.
","None of the above.
","Only mergesort and quicksort use recursion in the given options.
",
"An algorithm has runtime complexity T(n) = 4n2+16n+4. Which of the following answers describes the asymptotic time complexity of the algorithm?
","O(4n2+16n)
","O(4n2)
","O(n2)
","4 * O(n2+4n+1)
",,"We ignore all constants and only consider the highest power when trying to find the asymptotic time complexity of an algorithm.
",
"Consider two hash tables: a closed hash table with 750 buckets, 235 of which are empty; and an open hash table with 500 buckets and 275 keys inserted. What is the ratio of the average number of steps it will take to insert/find an item in the open hash table with respect to the closed hash table?
","0.603
","1.657
","0.961
","1.041
","0.215
","Start off by calculating the load factors of both hash tables, which is given by the formula L=(max # of keys to insert)/(total buckets in the array). So for closed hash table: L=(750-235)/750 =~0.69. For open hash table: L=275/500=~0.55. Now, the average number of steps to insert/find an item in closed hash table is given by #=0.5*[1+1/(1-L)], so that #=0.5*[1+1/(1-0.69)]=~2.113. For an open hash table, the average number of steps is simply given by A#=1+0.5*L, then A#=1+0.5*0.55=~1.275. Now, the ratio is #(open hash table)/#(closed hash table)=1.275/2.113=~0.603.
",
"Given the following array of a maxheap: [42,37,24,18,21,23,12,17,10,13,6,8]; what is the value of the right child of the right child of the node with value 37?
","8
","10
","13
","6
","None of the above.
","The formula for calculating the slot of the right child node is given by: rightChild(i)=2*i+2, where i is the index of the parent array. Therefore, the node with value 37 is located at index 1, then its right child is located at slot 2*1+2=4, which corresponds to 21. The right child of the node 21 is similarly found at 2*4+2=10, which corresponds to the node with value of 6.
",
"Which statement about Tree nodes is false.
","A node with 0 children is called a �leaf� node.
","Every tree has a ""root"" pointer, that points to the ""root"" node.
","Every node may have zero or more �children� nodes.
","A tree node can have one or more next pointers.
","The top node of a tree is called its ""root"" node.
","The tree node can't have one next pointer, as it needs to be able to point to at least both it's right and left child.
",
"What does a load factor of 0.9 mean?
","Your array has 10% more buckets than you need (you�ll fill 90% of the buckets).
","Your array has 90% more buckets than you need (you�ll fill 10% of the buckets).
","Your array has 10% less buckets than you need (you�ll fill 90% of the buckets).
","Your array has 90% less buckets than you need (you�ll fill 10% of the buckets).
","Your array has 90% more buckets than you need (you�ll fill 90% of the buckets).
","The �load� of a hash table is the maximum number of values (�keys�) you intend to add divided by number of buckets in the array.In simpler terms, when L = 0.9, your array is 10% bigger than required.
",
"Out of the input arrays below, which one would make the sorting algorithm, Quick Sort, most efficient.The numbers must be ordered from smallest to largest.
","[1,2,3,4,5,6]
","[1,2,3,2,2,2]
","[1,2,4,3,5,6]
","[5,2,3,1,6,4]
","[6,5,4,3,2,1]
","The run time for Quick Sort is ?(n^2) for already/mostly/reverse ordered arrays or arrays with the same value repeated many times.Quick Sort is most efficient when the array is not at all ordered, where its run time isnlog2(n).
",
"Which of the following functions has the greatest asymptotic growth? I.e. which function is the least efficient one in terms of time! (Think of O-Notation!)
","
","
","
","
",,"It is easy to see that is just a constant times n, i.e. linear growth. which is inNow differ between
",
"Is the following statement TRUE or FALSE?Quicksort is always faster than insertion sort.
","TRUE
","FALSE
","planation: If the array is sorted in ascending order, selection sort requires comparisons but quicksort requires comparisons.
","gs: Sorting
",,,"nathalie (nl586 - permission to this course revoked)
"
"What is the definition of the ""load"" of a hash table?
","Maximum number of values you intend to add divided bynumber of buckets in the array
","Total number of buckets in the array
","Maximum number of values you intend to add multiplied by number of buckets in the array
","Maximum number of values you intend to add
","None of the above
","A -Maximum number of values you intend to add divided by number of buckets in the array.(Lecture slides)
",
"Using the breadth-first graph traversal algorithm, what would the order of nodes processed be?
","1 - 2 - 3 - 4 - 5 - 8 - 9 - 6 - 7 - 10 - 11
","1 - 2 - 5 - 6 - 7 - 11 - 3 - 8 - 10 - 4 - 9
","1 - 2 - 5 - 7 - 11 - 6 - 3 - 8 - 10 - 4 -9
","1 - 2 - 3 - 4 - 9 - 8 - 10 - 5 - 7 - 6 - 11
",,,
"which of the adjacency matricesrepresent the following code:// undirected graphboolean[][] graph = new boolean[6][6]graph[3][0] = true;graph[2][1] = true;graph[4][1] = true;graph[5][2] = true;graph[0][3] = true;graph[0][5] = true;
","0 1 2 3 4 50 _ _ _ T _ _1 _ _ T _ T _2 _ _ _ _ _ T3 T _ _ _ _ _4 _ _ _ _ _ _5 T _ _ _ _ _
","0 1 2 3 4 50 _ _ _ T _ T1 _ _ _ _ _ _2 _ T _ _ _ _3 T _ _ _ _ _4 _ T _ _ _ _5 _ _ T _ _ _
","0 1 2 3 4 50 _ _ _ T _ _1 _ _ _ _ _ _2 _ T _ _ _ T3 T _ _ _ _ _4 _ T _ _ _ _5 T _ _ _ _ _
","0 1 2 3 4 50 _ _ _ T _ T1 _ _ _ _ T _2 _ T _ _ _ _3 T _ _ _ _ _4 _ _ _ _ _ _5 _ _ T _ _ _
","None of the above.
","can be found on Lecture 17 - Graphs 1 - Page 8""array[i][j] == true representsdirected edge from i to j.""where i is the columnand j is the rowgraph[0][5] = true;corresponds to the top right position in the matrix
",
"In time complexity O(log n), by what factor does T increase when n is doubled?
","Log-1(n).
","4.
","Constant.
","1.
",,"In logarithmic complexity, the doubling of n increases T by a constant factor k.
",
"Given the array representing a max heap [30,25,28,7,19,12,22], which index is the parent of 12
","0
","1
","2
","3
","4
","parent = (child - 1) / 2 index, so in this case parent = (5 - 1) / 2 = 2. The second index which is the value 28.
",
"Which tree traversal algorithm is described by the following?Visit each level's nodes from left to right before visiting nodes in the next level.
","Post-Order
","Pre-Order
","In-Order
","Level-Order
","None of the above
","Given in Lecture 13.
",
"Which of the following sorts are stable?
","Quicksort
","Selection Sort
","Insertion Sort
","Shell Sort
","None of the above
","Covered in lectures 10 & 11.
",
"In graph theory, the handshaking lemma states that ""In any finite undirected graph, the number of vertices with odd degree is even"".The lemma is a consequence of thedegree sum formula: for a graph with vertex set and edge set .Work out the sum of degrees of the vertices for the following undirected graph:
","20
","24
","26
","10
","13
","EXPECTED METHOD:If we follow thedegree sum formula = number of edges = 13 = 26ALTERNATIVE METHOD:Degree of each node:A = 3 B = 3 C = 1 D = 3 E = 5 F = 1 G =3 H = 1 I = 5 J = 1Sum of degrees:3 + 3 + 1 + 3 + 5 + 1 + 3 + 1 + 5 + 1= 26 = 26More information found here:- https://en.wikipedia.org/wiki/Degree_(graph_theory)-https://en.wikipedia.org/wiki/Handshaking_lemma
",
"In an open Hashtable, we want to store 2000 elements and be able to find any in around 1.40 steps. How many buckets should our Hashtable have?
","4000
","2500
","2000
","5600
","None of the above
","Using the following formula for an open Hashtable:ave. number of steps = 1 + L/2,we find L = 0.8.Then using the formula for the load L:0.8 = max. number of elements to insert / total buckets,we get 0.8 = 2000 / total buckets, and thus total buckets = 2500.
",
"What happens if you multiply an adjacency matrix by itself?
","Nothing
","The result now represents vertices that are two edges apart
","The result now represents vertices that are three edges apart
","It reverses the direction of edges in the graph
",,"If you multiply an adjacency matrix by itself, the result shows vertices that are two edges apart. If you then mulitply this result by the original adjacency matrix again, that result will then show vertices that are three edges apart, and so on.
",
"What is the average time complexity of Interpolation Search, an improved Binary Search algorithm, on a sorted array of N uniformly distributed elements?
","?(N)
","?(log(N))
","?(vN)
","?(log(log(N)))
","?(N^1.25)
","Given in lecture 2.
",
"Which of the following can you NOT use to represent a directed graph?
","A diagram with circles representing vertices, and lines connecting these circles, representing edges.
","A two-dimensional array, with the vertices represented by the indices of array, and edges represented by the values in the cells of the array
","A stack, where each vertex is pushed to the stack and edges are represented by the order that the vertices are pushed to the stack.
","An array of linked lists, where there is a linked list for every vertex, and the linked list represents the edges of that particular vertex.
",,"A stack can be used in the implementation of traversing a graph, but not for representing the graph.
",
"What is the time complexity of insertion and look up when using hash tables?
","constant
","n
","nlogn
","n^2
",,"It is constant
",
"What makes a sorting algorithm 'stable'?
","The algorithm ensures that the sorted order is from small to large.
","The algorithm sorts in a complexity of log(N).
","The algorithm maintains the order of all items as they were originally entered.
","The algorithm keeps the entered order of items of equal value.
","The algorithm uses the same number of iterations for each sort.
","The algorithm is called a stable algorithm if the original order of equal value items is maintained rather than any additional sorting being performed. This is helpful when order of item entry is relevant to the task.
",
"What is the main condition of a mixed graph (ADT) in terms ofn and m?n = number of directed edgesm = number of undirected edges
","
","
","
","
","
","A mixed graph consists of a set of vertices (or nodes) V, a set of undirected edges, and a set of directed edges.Hence for a mixed graph to exist, the number of directed and undirected edges does not matter as long as .Example:More information found here:https://en.wikipedia.org/wiki/Mixed_graph
",
"How will the list 9, 4, 7, 5, 8, 6, 1, 2 look after the first pass of 3-sort (shellsort h=3) and after all passes are complete.
","First Pass: 5, 4, 6, 9, 8, 7, 1, 2Complete:1, 2, 6, 5, 4, 7, 9, 8
","First Pass: 5, 4, 6, 9, 8, 7, 1, 2Complete: 5, 4, 6, 1, 2, 7, 9, 8
","First Pass: 5, 4, 6, 1, 2, 7, 9, 8Complete: 1, 2, 6, 5, 4, 7, 9, 8
","First Pass: 5, 4, 6, 1, 2, 7, 9, 8Complete: 1, 2, 4, 5, 6, 7, 8, 9
","First Pass: 9, 4, 1, 2, 8, 6, 7, 5Complete:9, 4, 1, 2, 8, 6, 7, 5
","H-sort algorithm:Pick a value of h (for example = 3)For each element in the array if A[i] and A[i+h] are out of order then swap.So for9, 4, 7, 5, 8, 6, 1, 2Consider 9 and 5 (which is 3 places along from 5), they are out of place so swap5, 4, 7, 9, 8, 6, 1, 2Consider 4 and 8 - in order so dont swapConsider 7 and 6 - out of order so swap5, 4, 6, 9, 8, 7, 1, 2Consider 9 and 1 - out of order so swap5, 4, 6, 1, 8, 7, 9, 2Consider 8 and 2 - out of order so swap5, 4, 6, 1, 2, 7, 9, 8No more elements to consider so this is the first passSince there were swaps we must repeat againConsider 5 and 1 - out of order so swap1, 4, 6, 5, 2, 7, 9, 8Consider 4 and 2, out of order so swap1, 2, 6, 5, 4, 7, 9, 8Consider 6 and 7 - in order no swapConsider 5 and 9 - in order no swapConsider 4 and 8 - in order no swapSince there was a swap consider from start again1, 2, 6, 5, 4, 7, 9, 8Consider 1 and 5 - in order no swapConsider 2 and 4 - in order no swapConsider 6 and 7 - in order no swapConsider 5 and 9 - in order no swapConsider 4 and 8 - in order no swapComplete so after final pass it is 1, 2, 6, 5, 4, 7, 9, 8
",
"For the given AVL Tree, if 5 is inserted what rotation will be required to re-balance the tree?
","Left rotation about node 4.
","Right Rotation about node 6, then left rotation about node 4.
","Left Rotation about node 6, then right rotation about node 4.
","Right rotation about node 4, then left rotation about node 3.
","Left rotation about node 3.
","From the given figure you can see what the tree will look like after inserting 5. 4 is the first node we approach when rebalancing the tree after inserting 5 that has a balance value <=-2 or >= 2. So we have to rotate about 4. As the rightchild of 4 has a balance of -1, this is the case for a double rotation, right rotate the rightchild (node 6), then left rotate on node 4.
",
"If we take an Adjacency Matrix, A, that represents a graph, and multiply it by itself n times, we find out:
","which edges are n vertices apart
","which vertices are n edges apart
","which vertices are 2^n edges apart
","which edges are 2^n vertices apart
","nothing useful
","From the lecture notes we have:A^2 gives us the number of vertices that are 2 edges awayA^3 gives us the number of vertices that are 3 edges awayGeneralising this gives:A^n gives us the number of vertices that are n edges away
",
"Which of the following sorting algorithms are stable?
","Insertion sort
","Shell sort
","Heap Sort
","Quick sort
","All of the above
","Shell, heap and quick sort all involve 'swapping' elements, and so order of equal elements may change during the sorting process.
",
"In a SkipList of n elements, how many elements are expected in lane 1 and lane 3?
","n in lane 1, and n/2 in lane 3
","n/2 in lane 1, and n/8 in lane 3
","n in lane 1, and n/4 in lane 3
","n in lane 1, and n/8 in lane 3
","n/2 in lane 1, and n/4 in lane 3
","For each lane in a skip list, the expected number of elements in each lane halves:Lane 1: n (contains all elements)Lane 2: n/2Lane 3: n/4 (n/2 divided by 2)Lane 4: n/8 (n/4 divided by 2)
",
"Below is a description of a tree traversal, which type of traversal is it?1. Process the nodes in the left sub-tree.2. Process the nodes in the right sub-tree.3. Process the current node.
","Pre-Order Traversal
","Post-Order Traversal
","In-Order Traversal
","Level-Order Traversal
",,"[Taken From Lecture Notes]Pre-Order Traversal:1. Process the current node.2. Process the nodes in the left sub-tree.3. Process the nodes in the right sub-tree.Post-Order Traversal:1. Process the nodes in the left sub-tree.2. Process the nodes in the right sub-tree.3. Process the current node.In-Order Traversal:1. Process the nodes in the left sub-tree.2. Process the current node.3. Process the nodes in the right sub-tree.Level-Order Traversal:1. Use a temp pointer variable and a queue of node pointers.2. Insert the root node pointer into the queue.3. While the queue is not empty:� Dequeue the top node pointer and put it in temp.� Process the node.� Add the node�s children to queue if they are not NULL.
",
"What is an adjacency matrix?
","An array of elements indicating whether a node is directed
","An array of elements indicating whether there is an edge between vertex i and vertex j
","The matrix used to apply a convolution
","An array to store the nodes in a depth first traversal
",,"Graph lecture
",
"How many of the following sort methods are stable:Selection SortShell SortBubble SortHeap SortMerge Sort
","1
","2
","3
","All of them!
","None of them!
","From the given sort methods only Bubble sort and Merge sort are stable.
",
"Which of the following is a valid maxheap? (Assuminglexicographic order)
","
","
","
","
","
","A) Not correct as Zenith>Moss, and Quazar>MossB) Each node is greater than or equal to it's children and is a complete treeC) Arthur > AaronD) Wilson > JerryE) Not a complete tree. (Level 3 missing the left child of Jerry)
",
"Given the elements [14, 18, 3, 2, 1, -1, -4, 5, 20], find the final balanced AVL Tree.
","3 2 14 -1 1 5 18-4 20
","3 -1 14-4 1 5 18 2 20
","5 1 18 -1 2 14 20-4 3
","2 -1 14-4 1 3 18 5 20
","14 2 18 -1 3 20-4 1 5
","Insert 14, 18, 3, 2, 1: 14 3 18 21Rebalance at ""3"": 14 2 181 3Insert ""-1"": 14 2 18 1 3-1Rebalance at ""14"": 2 1 14-1 3 8Insert ""-4"": 2 1 14 -1 3 18-4Rebalance at ""1"": 2 -1 14-4 1 3 18Insert ""5"" & ""20"": 2 -1 14-4 1 3 18 5 20
",
"Insert the elements -3, -5, -1, 5, 0, 4, into a standard closed hashtable (of size 6) with linear probing (to the right) in that order.The hash function has the form h(x) = ((x+1)2-3) % 6.What does the final hashtable look like?
","4, -3, -5, -1, 5, 0
","-5, -3, 5, -1, 0, 4
","0, -3, -5, 4, -1, 5
","4, -3, -5, 5, -1, 0
","0, -5, -3, 4, -1, 5
","h(-3) = 1. Insert into slot 1.h(-5) = 1. Slot 1 is taken so insert into slot 2.h(-1) = 3. Insert into slot 3.h(5) = 3. Slot 3 is taken so insert into slot 4.h(0) = 4. Slot 4 is taken so insert into slot 5.h(4) = 4. Slot 4 is taken and so is slot 5. So insert into slot 0. (Also last free slot).If you chose B then you probed in the wrong direction.
","jma52 (jma52 - permission to this course revoked)
"
"Insert the elements -3, -5, -1, 5, 0, 4, into a standard closed hashtable (of size 6) with linear probing (to the right) in that order.The hash function has the form h(x) = ((x+1)2-3) % 6.What does the final hashtable look like?
","4, -3, -5, -1, 5, 0
","-5, -3, 5, -1, 0, 4
","0, -3, -5, 4, -1, 5
","4, -3, -5, 5, -1, 0
","0, -5, -3, 4, -1, 5
","h(-3) = 1. Insert into slot 1.h(-5) = 1. Slot 1 is taken so insert into slot 2.h(-1) = 3. Insert into slot 3.h(5) = 3. Slot 3 is taken so insert into slot 4.h(0) = 4. Slot 4 is taken so insert into slot 5.h(4) = 4. Slot 4 is taken and so is slot 5. So insert into slot 0. (Also last free slot).If you chose B then you probed in the wrong direction.
","jma52 (jma52 - permission to this course revoked)
"
"The runtime for the following code fragment is?(f(m,n)). What is f(m,n)?int a;for (int i = -5; i < n; i++) for (int j = 1; j < 2i+1; 2*j) for (int k = 1; k < n-1; 3*k) a=a+1; for (int l = 0; l < m; 5*l) a=a+j;return a;
","?(m2log(n2))
","?(n2log(nm))
","?(n log(log(nm)))
","?(nlog(n)log(nm))
","?(n2(n+m))
","First loop has?(n) operations.Second loop has?(n) operations.Third loop has?(log(n)) operations.Fourth loop has?(log(m)) operations.In the second loop we have the sum of the third and fourth loops which have different bases. So we get?(log(n) + log(m)) operations. Bases of logarithms do not matter so we can use logarithmic laws to get?(log(n) + log(m)) =?(log(nm)).Then multiply these loops together to get?(n*log(n)*log(nm)) =?(n log(n) log(nm)).
",
"How do you extract the biggest item from a Maxheap?
","Replace the root with the lowest right node and then swap the moved value with the larger of it�s children until it is the greatest.
","Replace the root with the lowest left node and then swap the moved value with the larger of it�s children until it is the greatest.
","Replace the root with the lowest right node.
","Replace the root with the lowest right node.
",,"This ensures the highest value is at the top
",
"Which value would signify that a re-balance is needed in an AVL tree?
","0
","1
","2
","-1
",,"Any value greater than 1 or smaller than -1 means that a re-balance is needed.
",
"Which is not a form of tree traversal
","Pre-order
","Post-order
","In-order
","By-order
","Level-order traversal
","By-order is not a traversal method.
",
"Which sort uses h-sorting?
","Merge Sort
","Shell Sort
","Bubble Sort
","Insertion Sort
","Quick Sort
","Shell sort uses h sort multiple times with a range of values, always ending in 1.
",
"See the incomplete java code below for the classes ListNode and LinkedList:class ListNode { Object element; ListNode next; ListNode(Object e, ListNode n) { element = e; next = n; }}class LinkedList { private ListNode head = null; private int n = 0; // n is the list size public Object get(int i) { if (i<0 || i>=n) { // �error! } ListNode node = head; X return node.element; }}The method get finds nodeiin the linked list and outputs its element (get(0) outputs head.element). Which code should go at the place marked X for the method to work correctly?
","for (int j=0; j<i-1; j++) { node = node.next;}
","for (int j=0; j<i; j++) { node = node.next;}
","for (int j=0; j<i+1; j++) { node = node.next;}
","for (int j=0; j<i+1; j++) { node.next = node;}
","for (int j=0; j<i; j++) { node.next = node;}
","(d) and (e) are wrong because the assignment ""node.next = node"" is incorrect - this line would repeatedly make the assignment head.next = head.To find node i, the line ""node = node.next"" needs to be executed itimes. Examples:If i=0, the line ""node = node.next"" should not be executed because get(0) should outputhead.elementIf i=2, the line ""node = node.next"" should be executed 2 times so that node=head.next.next, which is node 2 in the listWe are left with (a), (b) and (c).(a) executes the line ""node = node.next"" (i-1) times(b) executes the line ""node = node.next"" i times(c) executes the line ""node = node.next"" (i+1) timesTherefore the answer is (b).
",
"What type of rotation is needed to balance the following unbalanced AVL tree? 5 / \ 2 7 / \ 1 3 \ 4
","Right (Clockwise) rotation
","Left(Anti-Clockwise) rotation
","Right-Left (Clockwise Anti-Clockwise) rotation
","Left-Right (Anti-Clockwise Clockwise) rotation
",,"Starting Tree: Left(Anti-clockwise) rotation on the sub-tree root 2: Then a right (clockwise) rotation on the root of the tree: 5 5 3 / \ / \ / \ 2 7 3 7 2 5 / \ / \ / / \ 1 3 2 4 1 4 7 \ / 4 1
",
"Using selection sort, which of the following permutations of [1,2,3,4,5] takes 5 swaps? (Ascending order)
","[4,1,2,5,3]
","[5,1,2,4,3]
","[4,5,1,3,2]
","[5,4,1,2,3]
","[2,3,4,1,5]
","[5,1,2,4,3][1,5,2,4,3] (1)[1,2,5,4,3] (2)[1,2,4,5,3] (3)[1,2,3,5,4] (4)[1,2,3,4,5] (5)
",
"What is the Big-O of the code below for a random value of j?if( j>=0 && j<=5) a+=5;else if( j<0){ for(int i = 0; i<=n; i++){ a+=3; }}else{ for(int i = 0; i<n*n; i++){ a+=8; }}
","1
","n^2
","n
","log(n)
","2^n
","For Big-O we need to look at only the worst case which is the last else for the given code. The complexity then is 4n^2 +2 which means that the Big-O is n^2.
",
"What is the complexity of the worst-case scenario for quicksort?
","n log?(n)
","n
","n3
","n2
","log(n)
","The worst-case scenario for quick sort is if it repeatedly selects an extreme end of the dataset, meaning that each recurse only reduces the problem by one step, thus n2.
",
"A skip list containing lanes from 0 to 12 is used to organise 262000 elements.On average, what will the combined sum of pointers in lanes 3, 8 and 11 be closest to?
","28000
","34000
","41000
","45000
","16000
","~ 34000
",
"Provided that the load factor is limited, what is the runtime complexity of insert, find and remove for a hashtable?
","?(n) for all.
","?(n) for find and remove,?(log n) for insert
","?(1) for all
","?(log n) for find and remove,?(n) for insert
","?(n) for find,?(n2) for insert and remove.
","Summary of Hashtables Lecture 2 - provided a limited load factor (max number of keys to insert / total buckets in the array) complexity is linear for find, remove and insert!
",
"Which of the following statements are true?
","Selection sort, Insertion sort and Quick sort are all stable.
","Insertion sort, Quick sort and Merge sort are all stable.
","Insertion sort, Shell sort and Quick sort are all unstable.
","Selection sort, Shell sort and Quick sort are all unstable.
",,"Selection: UnstableInsertion: StableQuick: UnstableMerge: StableShell: Unstable
",
"Which of the below is the correct order of asymptotic complexity, from fastest to slowest
","1, n, log(n), 2n, n2
","1, log(n), n, n2, 2n
","n, log(n), 2n, n2, 1
","log(n), n, n2, 2n, 1
","log(n), 1, n, n2, 2n
","1 (linear) is fastest, followed by log(n), n, n2 and 2n.
",
"Binary Search Trees, Binary Trees and AVL Trees are all types of Tree, but which is a special type of which?
","AVL Tree is a type of Binary Tree which is a type of Binary Search Tree
","Binary Tree is a type of AVL Tree which is a type of Binary Search Tree
","AVL Tree is a type of Binary Search Tree which is a type of Binary Tree
","Binary Search Tree is a type of Binary Tree which is a type of AVL Tree
","Binary Search Tree is a type of AVL Tree which is a type of Binary Tree
","An AVL Tree is a type of balanced Binary Search Tree, and a Binary Search Tree is a type of Binary Tree where all nodes in the left subtree are less than the node's value, and all nodes in the right subtree are greater than the node's value.
",
"Which of the following sorting algorithms use a 'Divide & Conquer' strategy?
","Insertion Sort & Shell Sort
","Quick Sort & Shell Sort
","Merge Sort, Insertion Sort & Quick Sort
","Quick Sort & Merge Sort
","Merge Sort & Insertion Sort
","Both merge and quick sorts split a given list into smaller lists and then sort those - this is what is meant by 'Divide & Conquer'.
",
"In which order (from first to last) are nodes processed by an In-Order traversal of a binary tree?
","Right Sub-Tree, Current Node, Left Sub-Tree
","Left Sub-Tree, Current Node, Right Sub-Tree
","Current Node, Left Sub-Tree, Right Sub-Tree
","Current Node, Right Sub-Tree, Left Sub-Tree
","Left Sub-Tree, Current Node, Left Sub-Tree
","In-Order processes left nodes before the current node and then finishes with right nodes.
",
"What is the worst case run time of a BST search for a tree with N values?
","?(log N)
","?(N^2)
","?(N)
","?(1)
",,"In the worst case, every node in the tree will have at most 1 child, and the desired node will be at the bottom of the tree - requiring you to pass through every other node in order to reach it.
",
"How many different orders of the characters 'B', 'A', 'T', 'H' can be inserted into the AVL tree described in lectures, such that preorder traversal will return ""BATH""?
","2
","4
","6
","8
","None of the above
","'B', 'A', 'T', 'H''B', 'T', 'A', 'H''A', 'B', 'T', 'H''A', 'T', 'B', 'H''T', 'A', 'B', 'H''T', 'B', 'A', 'H'
",
"What is the definition of precision?
","When you take repeated measurements and get similar values
","When you measure to a high number of decimal points
","When you average out your measurements
","When the average of your measurements is close to the true value
",,"Precision= when measuring repeatedly,we get very similar resultsfrom lecture 3, slide 5.
","cdm57 (cdm57 - permission to this course revoked)
"
"What is the definition of precision?
","When you take repeated measurements and get similar values
","When you measure to a high number of decimal points
","When you average out your measurements
","When the average of your measurements is close to the true value
",,"Precision= when measuring repeatedly,we get very similar resultsfrom lecture 3, slide 5.
","cdm57 (cdm57 - permission to this course revoked)
"
"Which of the following is false about a complete binary tree?
","The top N-1 levels are all completely filled with nodes.
","All nodes on the bottom row are as far right as possible with no empty slots in between.
","It is a useful data structure for implementing heaps.
","The maximum number of nodes in a binary tree of height �h� is 2h � 1, h > 1.
",,"Content found in lecture 16 which was about heaps and using complete binary trees for minheaps and maxheaps.
",
"Insert the following elements into a standard closed hashtable with linear probing (to the right): 22, 9, 3, 16, 6, 29, 12, 26, in that order. The hash function has the form h(x) = x % 8 (with slots 0,...,7). What does the hashtable look like?
","3, 6, 9, 12, 16, 22, 26, 29
","16, 9, 12, 3, 29, 6, 22, 26
","16, 9, 26, 3, 12, 29, 22, 6
","None of the above.
",,"Find x mod 8 and then insert it into the right slot. If that slot is already occupied then move to the next available slot on the right.
",
"Which of the following sorting algorithms is always stable?
","Selection sort
","Bubble sort
","Shell sort
","Quick sort
","None of the above
","A sort is considered to be stable if the original order of the input is preserved, i.e. if there is a comparison between two equal items, the one that appeared first in the input will appear before the second item in the sorted output too.Bubble sort is stable because it only swaps elements if one is strictly less than the other.However, selection sort is unstable, for example, because it swaps the least value with the first value - but what if they are the same?
",
"In an AVL Tree, what is the maximum balance factor a node can have before it needs re-balancing?
","-1
","2
","0
","1
","None of the above
","In an balanced AVL Tree, all nodes should have a balance factor of -1, 0 or 1. This means that the maximum balance factor a node can have before needing to be re-balanced is 1. -1 is the minimum balance factor accepted.
",
"Which of the following is the worst complexity?
","O(1)
","On^2)
","O(2^n)
","O(n log n)
",,"Exponential increase.
",
"What is a ADT?
","Abstract Data Type
","Additional Data Type
","Algorithms and Data Types
","None of the above.
",,"Abstract Data Type - A collection of algorithms, data types and interface methods.
",
"Using binary search with a data set with 1,048,576 elements, what is the maximum number of iterations would it take to find a specific element?
","20
","15
","25
","50
","None of the above.
","20 iterations. Binary search is log2(n) - so log2(1048576) = 20.
",
"Which of the following data structures is it difficult to remove data from?
","Closed Hash Table (with linear probing)
","Skip List
","AVL Tree
","Open Hash Table
",,"Closed hash table, as removing items will create gaps before the rest of the data. This gap will prematurely abort the linear probing/search, meaning you wont be able to find any items after it.
",
"What would be the resultant maxheap after adding the number ""15"" to the maxheap (All images created using draw.io):
","
","
","
","
",,"Here, D is the correct answer, as 15 is first added as the right child of 4, in order to maintain a complete binary tree, and then it is ""sifted up"", until it becomes the root node.
",
"What is meant by the the Load Factor (L) for an Open Hash Table?
","The average amount of values stored in each bucket.
","The ratio of the amount of values stored in the bucket with most values stored, to the bucket with the least values stored.
","The maximum amount of values a bucket is allowed to store.
","The maximum number of keys to insert, divided by the number of buckets in the array.
",,"See: Lecture 9, Page 12
",
"What is the Big-O time complexity of Level Order Traversal for a tree structure with n nodes? (Pick the smallest upper bound which applies.)
","O(n)
","O(log(n))
","O(n2)
","O(nlog(n))
",,"Each node of the tree is visited exactly once, and there are n nodes. Hence O(n) time complexity. (This is true for any of the tree traversals.)See: Lecture 13, Slide 29
",
"Select the correct statement about time complexity (Big-O notation).
","If given the exact time complexity?(f(n)) of an algorithm, you can work out exactly how much time it will take to complete the algorithm for a given n.
","If given the exact time complexity ?(f(n)) of an algorithm, you can work out exactly how many operations it will take to complete the algorithm for a given n.
","?(log2(n)) time complexity is the same as?(log10(n)) time complexity.
","An algorithm with ?(1) time complexity will always take less operations to complete than an algorithm with ?(n2) time complexity.
",,"log2(n) is equal to log10(n)/log10(2). Constant factors can be disregarded in Big-O notation, so?(log2(n)) complexity is the same as ?(log10(n)) complexity. (1/log10(2) is the constant factor in this case.)Providing a counterexample for A and B: an algorithm that always takes 1 operation to complete and an algorithm that always takes 100 operations to complete would both be?(1) time complexity. So given only the time complexity you would not be able to work out which of these cases it would be (or if it was another case altogether). So you would not be able to work out the number of operations it would take to complete, and hence would not be able to work out how much time it would take to complete.A counterexample for D: Consider an algorithm f(n) which always takes 1,000,000 operations to complete and therefore has?(1) time complexity. Now also consider an algorithm g(n) which always takes n2 operations to completeand therefore has ?(n2) time complexity. But for all n < 1,000, g(n) will take less operations to complete than f(n).
",
"Which sorting algorithms are used in some low RAM embedded systems?
","Quick sort & merge sort
","Merge sort & shell sort
","Heap sort & shell sort
","Heap sort & merge sort
",,"Slide 19 in the Sorting 3 lecture says:Shell sort:Used in some embedded systems (eg, in a car) instead of quicksort due to fixed RAM usageHeap sort:Sometimes used in low-RAM embedded systems because of its performance/low memory req�ts.
",
"What is the O (worst case), ? (average case), and O (best case) complexities of this method:void foo(int sum) { if(sum == 0) { return; } for (int i = 0 ; i < n*n ; i++) { sum += i + n; } if(sum == 5000) { for (int i = 0 ; i < n*n*n ; i++) { sum += i; } }}
","O(n): n2, ?(n): n, O(n): n
","O(n): n2, ?(n): n, O(n): 1
","O(n): n3, ?(n): n2, O(n): n
","O(n): n3, ?(n): n2, O(n): 1
",,"Best case is when sum= 0 and the method returnsAverage case is whensum!= 0 &&sum!= 5000 so only goes through the for loop n2timesWorst case is whensum= 5000 and has to go through the final for loop n3 times
",
"Inserting the values 1, 2, 3, 4, 5, 6, 7 into a binary search tree, how many singular rotations occur and what is the direction of the final rotation in order for it to be perfectly balanced?
","4, left
","4, right
","3, left
","3, right
",,"rotation 1: 1 -> 2 2 1 3 3rotation 2: 2 -> 2 1 3 1 4 4 3 5 5rotation 3: 2 -> 2 1 4 1 4 3 5 3 6 6 5 7 7rotation 4: 2 -> 4 1 4 2 6 3 6 1 3 5 7 5 7All rotations are left rotations and the final rotation is in the left direction too.
",
"With the BST below, what is the maximum number of elements which can be inserted into the root's left sub-tree until the tree is not an AVL tree (include the insertion which causes the unbalance as part of your answer)?5 \ 6
","2
","3
","4
","5
","none of the above
","3 insertions will cause the tree to look like: 5 / \ b 6 / \a cwhich is balanced, then the next insertion has to be below a or c. Hence the 4th insertion causes the tree to not be an AVL tree.
",
"Which is a valid comparison between open and closed hash tables?
","Open hash table:- Faster run time- Smaller memory consumption
","Closed hash table:- Faster run time- Smaller memory consumption
","Closed hash table:- Smaller memory consumptionOpen hash table:- Faster run time
","Open hash table:- Smaller memory consumptionClosed hash table:- Faster run time
","They both have the same run time efficiencies and memory consumptions
","An open hash table is going to take up more space since it allows for adding unlimited elements to its buckets, and in order to speed it up, it should purposefully be made too large.A closed hash table takes up a static amount of memory, less than an open hash table would, but will in comparison run slower.
",
"Which of the following statements is false?
","The top node of a tree is called the 'root'
","A node with 0 children is called a leaf
","In a binary tree, every node has at least 2 children
","In a full binary tree, every non-leaf has exactly 2 children
","In a full binary tree, the number of nodes on depth level d is 2^d
","In a binary tree, every node has at MOST 2 children nodes
",
"Which is faster (linked list or array) when1) inserting a new item at front?2) removing an item from the middle?
","1) linked list 2) linked list
","1) array 2) linked list
","1) linked list 2) array
","1) array 2) array
","1) same 2) linked list
","1) linked list done in a few steps where as with an array we would have to shift all n items right first2)Once we�ve found the item we want to delete, we can remove it in a few steps. With an array, we�d have to shift all the following items left one slot.
",
"What is the time complexity of adding and deleting items in a priority queue
","Add: O(logn)Remove O(log2n)
","Add: O(logn)Remove O(logn)
","Add: O(n)Remove O(logn)
","Add: O(logn)Remove O(ln)
","Add: O(n)Remove O(n)
","google heaps geeks for geeks
","iwonderwhothisislol (eg574 - permission to this course revoked)
"
"What is the time complexity of adding and deleting items in a priority queue
","Add: O(logn)Remove O(log2n)
","Add: O(logn)Remove O(logn)
","Add: O(n)Remove O(logn)
","Add: O(logn)Remove O(ln)
","Add: O(n)Remove O(n)
","google heaps geeks for geeks
","iwonderwhothisislol (eg574 - permission to this course revoked)
"
"What is the average case run-time of heap sort?
","O(n^2)
","O(log(n))
","O(n * log(n))
","O(1)
","O(log(n)^2)
","Time complexity of heap sort is O(n * log(n))http://bigocheatsheet.com/
",
"Assuming 0 indexed array representation of a heapwhat is the index of the right child of the node at index 5
","12
","11
","10
","13
","9
","formula is:public int getRightChild(int i) { if(2 * (i + 1) >= pointer) return -1; return 2 * (i + 1);}
","iwonderwhothisislol (eg574 - permission to this course revoked)
"
"Assuming 0 indexed array representation of a heapwhat is the index of the right child of the node at index 5
","12
","11
","10
","13
","9
","formula is:public int getRightChild(int i) { if(2 * (i + 1) >= pointer) return -1; return 2 * (i + 1);}
","iwonderwhothisislol (eg574 - permission to this course revoked)
"
"Assume a heap stored at an 0 indexed array.What is the index of the parent of the item in index 5.
","2
","1
","3
","0
","4
","Formula is :public int getParent(int i) { if (i == 0) return -1; return (i + 1) / 2 - 1;}
","iwonderwhothisislol (eg574 - permission to this course revoked)
"
"Assume a heap stored at an 0 indexed array.What is the index of the parent of the item in index 5.
","2
","1
","3
","0
","4
","Formula is :public int getParent(int i) { if (i == 0) return -1; return (i + 1) / 2 - 1;}
","iwonderwhothisislol (eg574 - permission to this course revoked)
"
"Below is an incorrect implementation of Selection Sort for sorting items in ascending order. What is wrong with the code? You may assume the swap function is correct.void selectionSort(int a[], int n){ for (int i = 0; i < n-1; i++){ int minIndex = i; for (int j = i + 1; j < n-1; j++){ if (a[j] < a[minIndex]){ minIndex = j; } } swap(a, i, minIndex); }}
","The code sorts the items into descending order.
","The algorithm only sorts the first n-1 items in the list.
","The code is wrongly typed.
","The inner for-loop should start from j = i.
","In the inner for-loop it should be ++j and not j++.
","The for-loop's should compare up to index n-1 i.e. the last element. This code only compares the first n-2 elements i.e. the second to last element.
",
"Why is is not possible to remove an entry from a Closed Hash Table with Linear Probing?
","Because the hash value of a key is not unique we don't know which entry to remove.
","Because Hash Functions are not injective.
","Removing an entry from a Closed Hash Table with Linear Probing destroys the ""structure"" of linear probing when searching for an entry.
","It is possible to remove an entry from a Closed Hash Table with Linear Probing.
","Because the Hash Function does not necessarily have an inverse.
","If a key has the same hash value as an entry already in the hash table then we insert it in the next available space below the hash value. Now when searching we compute the hash value of the entry which we wish to find then beginning at the hash value we search through the hash table until we either reach the entry or a blank space. If we were to remove an item from the hash table then if we were to search for an entry with the same hash value which came after the removed entry our search would come back false even though the entry is in the hash table.
",
"what will the following list of numbers look like at different layers of Quick Sort? (where the pivot used is thefirst element)6, 5, 3, 4, 1, 8, 7, 2, 9
","5, 3, 4, 1, 2, 6, 8, 7, 93, 4, 1, 2, 5, 6, 7, 8, 91, 2,3, 4,5,6,7,8,91, 2, 3,4,5, 6, 7, 8, 91,2,3,4, 5, 6, 7, 8, 9
","5, 3, 4, 1, 2, 6, 8, 7, 93, 4, 1, 2, 5, 6, 7, 8, 92, 1, 3, 4, 5, 6, 7, 8, 91, 2, 3, 4, 5, 6, 7, 8, 91, 2, 3, 4, 5, 6, 7, 8, 9
","1, 6, 5, 3, 4, 8, 7, 2, 91, 3, 2,4, 6, 5, 8, 7, 91, 2,3,4, 6, 5, 7,8, 91, 2, 3, 4,5, 6, 7,8, 91, 2, 3, 4, 5, 6, 7,8, 91, 2, 3, 4, 5, 6, 7, 8, 9
","1, 6, 5, 3, 4, 8, 7, 2, 91, 6, 5, 3, 4, 7, 2,8, 91, 3, 2,4, 6, 5, 7,8, 91, 2, 3,4, 5, 6, 7, 8, 9,1, 2, 3, 4, 5, 6, 7, 8, 9,1, 2, 3, 4, 5, 6, 7, 8, 9,
",,"Make sure you keep them in the order they were before, just moved to one side of the pivot.Also, remember the first element of each section and must keep going till all points are pivots.
",
"A quadratic time algorithm uses 27 elementary operations when given an input n=10. What is the (most likely) amount of elementary operations for n=1000?
","54,000
","27,000
","729,000
","270,000
","540,000
","We can represent this problem as an equation; let f(x) = cx^2 where c is a constant to be calculated. We know that 27 = c * 10^2, so c = 27/100.Now lets look at the case where n=1000; f(x) = 27/100 * 1000^2. This equates to 270,000
",
"From the diagram (above), what would the balance value of the node with value ""Ronda"" be? Is this an AVL tree?
","2 & an AVL tree
","-2 & an AVL tree
","2 & NOT an AVL tree
","-2 & NOT an AVL tree
","0 & NOT an AVL tree
","The balance value of a node is calculated by calculating the heights of the nodes left and right subtrees; balance = rightSubtree.height - leftSubtree.height.This is NOT an AVL tree, the definition of an AVL tree is as follows: ""a BST (binary search tree) in which the heights of the left and right sub-treesof each node differ at most by 1."" As we have a balance factor not in the range [-1,1], it is not an AVL tree.
",
"What is the average runtime of these sorting algorithms? (in Big O notation)InsertionSortQuickSortMergeSort
","InsertSort - N2QuickSort - N*log(N)MergeSort - log(N)
","InsertionSort - N2QuickSort - N*log(N)MergeSort N*log(N)
","InsertSort - N2QuickSort - log(N)MergeSort - N*log(N)
","InsertSort - N2QuickSort - N2MergeSort - log(N)
",,"Insertion sort is O(N2) because, for each element, it needs to compare to up to n other elements.Quick Sort is O(N*log(N)) because it will have on average log(N) layers because it halves it each time, and each layer has up to n comparisons.Merge Sort is alsoO(N*log(N)) because it also halves the array each time, and in each of these cases will be doing up to n comparisons.
",
"What is the complexity of the following function?for (int i=0 ; i < n ; i++){ int k = n; while (k > 1){ sum++; k = k/2; }}
","T(logn)
","T(n)
","T(nlogn)
","T(n^2)
","T(n^3)
","Our code has 2 loops involved; 1 for loop and 1 while loop. The for loop loops n times, so our answer is going to be n multiplied by the order of the while loop.The order of the while loop is log(n), as with each loop we keep halving k (If you imagine a graph with y=n at x=0, it will show a logarithmic relationship if for each increase in x you halve n.)This gives us the resulting answer of O(nlogn)
",
"Let g, h, f1 and f2 be functions. If g(n) = O( f1(n) ) and h(n) = O( f2(n) ), what is the big-O complexity of (g(n)+h(n))?
","O(f1(n) + f2(n))
","O(max{ f1(n), f2(n) })
","O(f1(n)*f2(n))
","None of the above
",,"If we are given two functions, the complexity of their sum is determined by the ""larger"" function. I.e if f(n) = n^3 and g(n) = 4n^2, then their sum f(n) + g(n) = n^3 + 4n^2 still has complexity O(n^3) (the larger of the two functions).
",
"Given 67, 54, 3, 98, 34, which is the root node and which are leaf nodes if it were a balanced AVL tree
","Root: 54Leaves: 3, 98
","Root: 54Leaves 3, 67, 98
","None, it cannot be a balanced AVL tree
","planation: Heights of left and right subtrees differ by only 1
",,,"bgc (ac2291 - permission to this course revoked)
"
"On average, how many nodes would you expect to be in the fourth lane of a skip-list with 64 elements (Assuming the first lane contains all elements)?
","64
","12
","16
","8
","None of the above
","As we move up to the next lane, we expect the number of nodes to be half the number that were in the previous lane. In this exampleLANE 1: 64 nodesLANE 2: 32 nodesLANE 3: 16 nodesLANE 4: 8 nodes
",
"Which of these algorithms should be the fastest to sort a randomly ordered linked-list?
","Bubble sort
","Quick sort
","Insertion sort
","Merge sort
",,"While quicksort and mergesort are comparable in the best and average case, the worst case scenario of quick sort is n2, while merge sort's still n log(n)
",
"What is the best, worst, and average/amortised runtime of adding an element to an arraylist?
","Best: 1Worst: nAmortised: 1
","Best: 1Worst: 1Amortised: 1
","Best: 1Worst: nAmortised: n+1
","Best: nWorst: nAmortised: 1
","Best: nWorst: 1Amortised: n
","Amortized analysis doesn't naively multiply the number of invocations with the worst case for one invocation.
",
"Which of these statements about hash tables is FALSE?
","Open hash table searching is almost always MORE runtime efficient than linear probing
","Only use a linear probing search if no items will be removed from the hash table
","The load factor is the maximum number of values divided by the number of 'buckets'
","A hash function is a function that creates an array
",,"A hash function computes the index of a key in an array. In a hash table, there are fewer array positions than the keys, so the position of the key in the array has to be computed, this is done using the hash function.
",
"Which of the following sets of sorting algorithms are all stable?
","Selection, Bubble, Merge
","Merge, Insertion, Heap
","Bubble, Merge, Insertion
","Shell, Quick, Insertion
","Selection, Shell, Quick
","Out of Selection, Insertion, Bubble, Shell, Quick, Merge and Heap sorts, only Insertion, Bubble and Merge sorts are stable.
",
"What will the following list of numbers look like after 2 iterations of a bubble sort:6, 5, 3, 4, 1, 8, 7, 2, 9
","3, 4, 1, 5, 6, 2, 7, 8, 9
","1, 2, 3, 4, 5, 6, 7, 8, 9
","4, 1, 3, 5, 6, 2, 7, 8, 9
","3, 4, 1, 5, 6, 2, 7, 9, 8
","3, 4, 5, 1, 6, 2, 7, 8, 9
","After the first iteration:5, 3, 4, 1, 6, 7, 2, 8, 9After the second iteration:3, 4, 1, 5, 6, 2, 7, 8, 9
",
"If I was to add the number 8 to the following tree, what type of balancing algorithm will be required: (4) / \ (2) (6) \ (9)
","Anticlockwise with (9) and (8) then Clockwise with (6), (9) and (8)
","Clockwise with (9) and (8) and then Clockwise with (6), (9) and (8)
","Clockwise with (9) and (8) and then Anticlockwise with (6), (9) and (8)
","Anticlockwise with (9) and (8) and then Anticlockwise with (6), (9) and (8)
","It cannot be balanced
","After the first Clockwise the tree looks like: (4) / \ (2) (6) \ (8) \ (9)And then after the Clockwise rotation it becomes: (4) / \ (2) (8) / \ (6) (9)which is now balanced
",
"Which of the following definitions correctly describes the meaning of ""accuracy""?
","How close a measured value is to the real value being measured.
","The ""closeness"" with which repeated measurements of the same value occur.
","planation: A describes accuracy, while B describes the precision of an instrument, see Lecture Notes ""Complexity 1"".
","gs: Applications
",,,"liampugh (ljp67 - permission to this course revoked)
"
"In the following skip list, which elements would be compared with ""d"", including the lane that the program is in at that moment, before ""d"" is found:Lane 1: ""a"" ""e""Lane 2: ""a"" ""c"" ""e""Lane 3: ""a"" ""b"" ""c"" ""d"" ""e""
","""a"" and ""e"" in lane 1""a"", ""c"" and ""e"" in lane 2""a"", ""b"", ""c"" and ""d"" in lane 3
","""a"" and ""e"" in lane 1""c"" and ""e"" in lane 2""d"" in lane 3
","""a"" and ""e"" in lane 1""a"", ""c"" and ""e"" in lane 2""a"", ""b"", ""c"" and ""d"" in lane 3
","""a"" and ""e"" in lane 1""a"", ""c"" and ""e"" in lane 2""c"" and ""d"" in lane 3
",,"In the first lane it will see that ""d"" is greater than ""a"" and less than ""e""In the second lane it will start at ""a"", but it won't compare it with ""a"" again, and see it is greater than ""c"" and less than ""e""As it knows it is greater than ""c"" it will start from ""c"" in the third lane and find it immediately
",
"Merge sort algorithm takes 69s to sort an array of 1000 items. How long would it take (approximately) to sort an array of 10000 items?
","690
","921
","69
","None of the above
",,"Merge sort has an average complexityT(n log(n)), so for a 10x increase in items, ballpark estimate would be 10 times and a bit.
",
"Which of these is NOTa characteristic of a B+ tree?
","Leaves have the same depth
","All nodes are always more than 50% full, except for root node
","It is often used for database storage
","Data is stored in the leaves
",,"B+ tree is very streamlined and leaves only contain pointers to the data (ie where it is stored on the disk).
",
"If this is an unbalanced AVL tree, what are the new leaf nodes of the tree once it has been balanced? (7) / \ (5) (10) / \ (4) (9) / (1)
","Root 5: leaf nodes 1, 9, 10.
","Root 9: leaf nodes 1, 7, 10.
","Root 4: leaf nodes 5, 9, 10.
","The tree cannot be balanced.
","None of the above/other implementation.
","Use of the re-balancing and rotation algorithms to create a tree that looks like this: (5) / \ (4) (7) / \ \ (1) (9) (10)However other implementations using the right sub-tree instead is also valid, as long as all balance factors are -1, 0, or 1.
",
"In an implementation of an AVL Tree, why would you want to rebalance the tree after insertion?
","In order to ensure that inserting the node is as fast as possible.
","To make the tree more space efficient.
","So that searching through the tree will always be in O(log n) time.
","You don�t rebalance the tree in AVL implementation
",,"The purpose of balancing the tree is to ensure that all the nodes are as evenly distributed as necessary for the search to remain in O(log n) time. If there was no re-balancing, then it is possible to end up with a tree that has a height of N, which would make searching through it linear (O(n)). As such, we re-balance after every insertion in order to ensure this.
",
"Which of these statements are true?
","Quicksort is the fastest search algorithm in every case.
","Insertion sort in unstable and easy to implement.
","Merge sort requires extra memory space in order to be implemented properly.
","Shell sort is inappropriate for use in embedded systems due to its memory handling properties.
",,"Merge sort requires extra RAM than other algorithms because during the splitting functions it needs to create new arrays to store the split arrays at different sorting levels, whereas other sorting algorithms mainly operate on the array that already exists.
",
"What kind of traversal does this describe?1)process nodes in left subtree2)process current node3)process nodes in right subtree
","Pre-order
","Post-order
","In-order
","Level Order
",,"pre-order = current, LST, RSTpost-order = LST,RST, currentlevel order = level 1, level 2 etc...
",
"Which of these statements is FALSE
","The average case (i.e. the average number of steps) of a linear search is N/2
","The worst case (i.e. the average number of steps) of a linear search is N
","The average runtime of interpolation search is loglog(N)
","The average case (i.e. the average number of steps) of binary search is N
",,"The estimated total steps is log_2(N)We know that log_2(N) is equal to the number of times you can divide N by 2 before you reach a value of 1.
","bgc (ac2291 - permission to this course revoked)
"
"Which of these statements is FALSE
","The average case (i.e. the average number of steps) of a linear search is N/2
","The worst case (i.e. the average number of steps) of a linear search is N
","The average runtime of interpolation search is loglog(N)
","The average case (i.e. the average number of steps) of binary search is N
",,"The estimated total steps is log_2(N)We know that log_2(N) is equal to the number of times you can divide N by 2 before you reach a value of 1.
","bgc (ac2291 - permission to this course revoked)
"
"When constructing a perfectly balanced binary tree given the following numbers: 40, 5, 37, 9, 100, 28, 59Which will be leaf nodes? (left to right)
","8, 37, 59, 100
","9, 37, 59
","5, 28, 40, 100
","8, 9, 37, 40
",,"Tree lecture 2 37 9 59 5 28 40 100
",
"Who invented AVL trees?
","Georgy Adelson-Velsky & Evgenii Landis
","Gregory Aitchison-Vanstone & Eimear Lakner
","Gerald Anderton-Veale & Edmond Latham
","Gilbert Amstead-Vernon & Eamon Ledgard
","George Ainsley-Vallins & Ellison Lockey
","Trees 3rd lecture
",
"Which sorting algorithm has the fastest average case?
","Quick sort
","Selection sort
","Merge sort
","Insertion sort
","Shell sort
","The time complexity of Quicksort is O(n log n) in the best case, O(n log n) in the average case, and O(n^2) in the worst case. This is the fastest average case for sorting algorithms.
",
"Given the sorted list: 10, 16, 25, 33, 52, 58, 61, 70, 100, 140How many steps would a binary search take to find 10 in the list?
","2
","3
","4
","5
",,"Step 1: midpoint is 52 so list is now:10, 16, 25, 33Step 2: midpoint is 16 so list is now:10, 16Step 3: midpoint is 10, therefore element found!So takes 3 steps :)
",
"In the given array, how many steps would it take to find the value '20' when using binary search?__________________________________| 6 | 10 | 13 | 15 | 19 | 20 | 27 | 39 | 41 | 48 |
","2
","3
","4
","5
","6
","In the binary search algorithm we keep on dividing our search in half until we finally arrive at our value.Therefore each step of the algorithm would divide the array as follows:__________________________________| 6 | 10 | 13 | 15 | 19 | 20 | 27 | 39 | 41 | 48 | L M H__________________________________| 6 | 10 | 13 | 15 | 19 | 20 | 27 | 39 | 41 | 48 | L M H__________________________________| 6 | 10 | 13 | 15 | 19 | 20 | 27 | 39 | 41 | 48 | L H ^ Found in 3 steps
",
"int[] arr;for ( int i = 0; i < n; i++ )arr[i] = 0;What is T(n), the number of elementary operations, that this algorithm performs
","3n+3
","3n2+2
","2n+2
","3n+2
",,"Initialise the variable i once1Perform n+1 comparisons between 0 and n n+1Increment the variable i, n times nSet value in array n times n(Lecture 3)
",
"For a dictionary with 10,000,000 words in it, how many steps does the binary search algorithm take to find a particular word?
","~17
","~20
","~23
","~1000
",,"log2(10,000,000) = 23.25
",
"Which of these statements is the Big-Oh transitivity rule?
","if g(n) = O(f1(n)) and h(n)=O(f2(n)) then g(n)+h(n)=O(max{f1(n),f2(n)})
","if f(n)=O(g(n)) and g(n)=O(h(n)) then f(n)=O(h(n))
","if g(n)=O(f(n)) and h(n)=O(f(n)) then g(n)=O(h(n))
","if g(n)=O(f1(n)) and h(n)=O(f2(n) then g(n)h(n)=O(f1(n)f2(n))
","if f(n)=O(g(n)) and g(n)=O(h(n)) then h(n)=O(f(n))
","if f(n)=O(g(n)) and g(n)=O(h(n)) then f(n)=O(h(n))i.e if A<B & B<C then A<C
",
"Which of the following sorting algorithms has the same best-case and worst-case time complexities?
","Bubble sort
","Merge sort
","Quick sort
","Shell sort
",,"Merge sort has worst case n log (n) and best case n log(n)
",
"What is the max number of comparisons needed to find a name with binary search in the following list:AaronAndreaBenBryceEmmaJamesJohnVictoria
","2
","3
","4
","5
","6
","log(n)
",
"A tree is a type of ....
","Array
","Hashtable
","Sorting Algorithm
","Linked List
","Algorithm
","In the first trees lecture
",
"Suppose we have the following AVLTree. If we remove the root node 4 correctly, how could the binary treelook like after? (4) / \ / \ / \ / \ (2) (6) / \ / \ / \ / \ (1) (3) (5) (7) / \ / \ (0) (8)
","3 is the root, 0, 1, 5, and 8 are leaves
","5 is the root, 0, 3, 6, and 8 are leaves
","6 is the root, 0, 1, 5, and 8 are leaves
","The root node cannot be removed
","None of the above
","The lecture slide states to replace the removal node's value by the greatest value of the left branchor the lowest value on the right branch.So if we chose 5 on the right branch, we would then need to balance the tree by rotating left on(6) \ (7) after rotate right = (7) \ / \ (8) (6) (8)then leave the left branch untouched to obtain leave nodes: 0, 3, 6, 8We can also choose 3 on the left branch, however, the leave nodes are balanced incorrectly.
",
"Which of the following statements is true?
","Merge Sort is not stable and has O(nlog(n)) complexity
","Quick Sort is stable and has O(log(n)) complexity
","Selection Sort has an unstable default implementation and has O(n^2) complexity
","Insertion Sort is unstable and has O(n) complexity
","None of the above
","Merge Sort is stable and has O(nlog(n)) complexity.Quick Sort is not stable and has O(n^2) complexity.Insertion Sort is stable and has O(n^2) complexity.
",
"Which of these properties do not apply to big-Oh notation?
","Scaling:For all c>0: cf(n) = O(f(n))
","Summation:If g(n) = O(f1(n)) and h(n) = O(f2(n)),then g(n)+h(n) = O(max{f1(n), f2(n)})
","Transitivity:If f(n) = O(g(n)), and g(n) = O(h(n)),then f(n) = O(h(n))
","Proportionality:For all c>0: f(cn) = O(cf(n))
","Products:If g1(n) = O(f1(n)) and g2(n) = O(f2(n)),then g1(n)g2(n) = O(f1(n)f2(n))
","You have Proportionality:For all c>0: f(cn) = O(cf(n))confused withScaling:For all c>0: cf(n) = O(f(n)).Multiplying the n-value it acts on does not affect the order of the whole function
",
"Let c,N be real numbers, and f(n), g(n) be time complexity functions.The function f(n) is said to be O(g(n)) if:
","For some value of c, f(n) > c*g(n), for all n>N.
","For some value of c, f(n) < g(n), for all n>N.
","For some value of c, f(n) < c*g(n), for all n<N.
","For some value of c, f(n) < c*g(n), for all n>N.
","None of the above.
","A) This is the definition of big-omegaB) This lacks the constant c in the definitionC) This is for all n<N (inequality is wrong way round) i.e. the statement is true before N, rather than after ND) This is the correct choice
",
"Which of these is the exact bound of asymptotic complexity?
","Big-Omega, O(f(n))
","Big-Theta, ?(f(n))
","Big-O, (f(n))
","Big-Theta, T(f(n))
",,"Big-Theta, T(f(n)), if the correct notation.
",
"Which of the following sorting algorithms is the fastest for nearly sorted data?
","Heap sort
","Quick sort
","Insertion sort
","Merge sort
","Bogosort
","Insertion sort only needs a few cycles in order to fully sort a nearly sorted list but becomes slower when the data is more out of order
",
"Which statement is incorrect?
","Linear search finds the element in O(n) time.
","Binary search finds an element in O(log n) time.
","Interpolation search finds an element in O(log log N) time.
","None of the above, all statements are correct.
",,"All statements are correct as there corresponding runtimes are correct.
",
"How many buckets would you need in your open hash table If you wish to store 10,000 items in an average of 1.45 steps? (To the nearest integer)
","6,897
","11,111
","3,448
","13,793
","9,000
","# steps = 1 + L/2 = 1.45therefore L = 0.9L = max keys to insert / total # of buckets in arrayso total # buckets in array = max keys to insert / L = 10,000 / 0.9 = 11,111
",
"Given the following selection of integers,2,5,11,14,17,24,51Which of the following would be valid AVL trees:1: 14 11 17 2 5 24 512: 24 14 51 5 17 2 11 3: 14 5 24 2 11 17 514: 51 17 24 2 5 11 14
","1
","1 and 4
","2 and 3
","3
","None of the above are valid AVL trees.
","3 is the only valid AVL tree, as it is the only BSTin which the heights of the left and right sub-trees of each node differ at most by 1.
",
"The following image represents which option in regards to its precision and accuracy.
","Low AccuracyLow Precision
","Low AccuracyHigh Precision
","High AccuracyLow Precision
","High AccuracyHigh Precision
",,"Accuracy determines how close you are to the real value, in the case of the image, it is clearly far off from the intended target! Thus a low accuracy.Precision determines how close measurements are together, in the case of the image, it is clear that all shots are close together! Thus a high precision.
",
"Which of the following unbalanced AVL trees are impossible to balance? (NOTE: For these trees, elements that have the same value as the current node are placed to the left of the current node)1) 4 4 42) 9 8 83) 2 2 14) 5 1 7 1 1
","2, 3 and 4
","Only 4
","1 and 3
","Only 1
","2 and 3
","1) cannot be balanced because same elements go the left of each other and therefore you cannot have 4 4 42) can be balanced to 8 using right rotation. 8 93) cannot be balanced because neither 2 nor 1 are allowed due to the same elements to the left consistency rule. 1 2 2 24) can be balanced to 1 using right rotation on the root node (5). 1 5 1 7
",
"what is the meaning of precision
","when measuring repeatedly we get similar results
","when measuring repeatedly we don't get similar results
","when measuring repeatedly we get correct results
","planation: lecture notes 3 slide 5
",,,"rab82 (rab82 - permission to this course revoked)
"
"how do you calculate the balance of a tree or sub-tree
","number of nodes on the right side - the number of nodes on the left side
","the depth of nodes on the right side - the depth of nodes on the left side
","planation: lecture notes 15 -slide 11
","gs: Trees
",,,"rab82 (rab82 - permission to this course revoked)
"
"What is in the ""root"" object of an empty tree?
","A 'null' node (i.e.with 'null' children and 'null' as it's value)
","Some dirt and some foliage
","""Null""
","Null
","0
","The root is a pointer and so will point to the first element, if it exists.If the tree is empty, there is no such first element and so it will point to Null - the pointer doesn't point to anything.""Null"" is incorrect as it is a stringA 'null' node is incorrect as it is a node and so an element of the tree exists, making it non-empty.
",
"Which of these are stable?
","Quick Sort
","Heap Sort
","Shell Sort
","Merge Sort
","Selection Sort
","Merge sort is stable - there are no jumps when the list is merged
",
"What is the exact bound complexity for the following code:for ( int i= 0; I < n; i++ ) for ( int j = 99; j < n*n; j++ ) sum++;
","n^2
","n^3
","log(n)
","None of the above
",,"First loop is run n times,Second loop is run n^2 times,n * n^2 = n^3
",
"Is quicksort stable? What is its worst case complexity?
","Stable, n^2
","Stable,n*log(n)
","Unstable, n^2
","Unstable,n*log(n)
",,"https://moodle.bath.ac.uk/pluginfile.php/1138973/mod_resource/content/3/DA-Lecture11-Sorting2.pdf - See slide 16 onwards for full explanation
",
"In an AVL Tree, what does it mean if a node has a balance value of -1 ?
","The node�s right subtree is 1 higher than the left
","The node�s left and right subtrees have the same height
","The node has no children
","The node�s left subtree is 1 higher than the right
",,"https://moodle.bath.ac.uk/pluginfile.php/1144766/mod_resource/content/2/DA-Lecture15-Trees3.pdf - see slide 6 and onwards for full explanation :)
",
"True or False - Transitivity applies when using Big O, Theta and Omega?
","True
","False
","planation: It is true. One of the Big O rules (and for Theta and Omega) is that if A = B, and B = C, then also A = C. If f(n) = O(g(n)), and g(n) = O(h(n)), then f(n) = O(h(n))
","gs: Complexity
",,,"mb24 (mb2412 - permission to this course revoked)
"
"When using QuickSelect, we use the k-th smallest element to simplify quick sort. On average, how many levels will there be?
","log(n^2)
","log(n)
","n
","n^2
","n^3
","The answer is log(n) levels. It takes on average log(n) levels of partitions in order to get down to single elements to sort.
",
"Calculate the average number of steps needed to find an empty space in a hash table when the table is intended to have 57 keys and has 145 buckets in the array.
","1.01 steps
","1.32 steps
","1.5 steps
","2.2 steps
",,"Load Factor = Max intended keys / total bucketsLF = 57/145 = 0.393...Average Steps =for L < 1.0Steps == 1.323...
",
"If an algorithm takes 1 second to process 1,000 elements and takes 8,000 seconds to process 20,000 results, what is its complexity?
","O(n)
","O(n2)
","O(n3)
","O(log n)
","O(n log n)
","For O(n3), doubling the value of n increases T by a factor of 8.20,000 / 1,000 = 20 - the factor increase of n203 = 8,000 seconds, so the complexity is O(n3)
",
"Which of the following statements comparing linked lists with arrays are true:A) In a Linked List, it would be faster to get to the 110th item.B) In a Linked List, it would be faster to remove an item from the middle of it.C) In an Array, it would be be faster to insert an item in the front of it.D) Arrays use less memory since they do not use storage for pointers.
","Only A and C
","Only B and C
","Only B and D
","Only D
","Only A and D
","A) Arrays are faster in this case, since in a Linked List you need to go through 109 positions in this case to reach the 100th position, where as you can access the 110th item in an Array in one go.B) In a Linked List, there is no shifting of elements when removing an item, where as in an Array you need to shift all the elements left one slot.C) In an Array, you need to shift all the items to the right one slot in order to insert the new item, where as in a Linked List you can add a new element in a few steps. (involving updating pointers)D) A Linked List uses pointers, so it needs extra storage for the pointers, where as an Array does not.
",
"Given a closed hash table with 50 buckets, what is the average number of steps it will take to insert/find an item if the maximum number of keys to insert is 40?
","3
","2.5
","6
","0.8
","4
","Load = 40/50 = 0.8Average number of steps = 1/2(1 + 1/(1-load)) = 1/2(1+ 1/0.2)) = 3
",
"What is the Time Complexity for Binary Search?
","O(n^k)
","O(n log n)
","O(log n)
","O(2^n)
",,"Imagine you try to find page 30 in a book of 100 pages:You first take the half of 100, which is 50. Then you ask yourself, is 30 < 50? The answer is yes, so you take the half of the pages on the LEFT of 50.You reach page 25.Then ask yourself again, is 30 < 25? The answer is no, so you take the half of the pages on the RIGHT of 25.Then you reach page 38. You keep repeating this process until you reach page 30.Thus by doing 1/2 every time, the time complexity of Binary Search is found to be O(log n).
",
"If f(n) = 2^n+ 10, g(n) = 5nlog(n), and h(n) = n^2 + log(n), which of the following statements is true?
","h(n) = O(g(n)), h(n) = O(f(n)), f(n) = O(h(n))
","g(n) = ?(h(n)), f(n) = O(g(n)), f(n) = ?(h(n))
","f(n) = ?(h(n)), g(n) = O(h(n)), h(n) = O(f(n))
","h(n) = O(f(n)), g(n) = ?(h(n)), h(n) = O(g(n))
","None are true
","In order of increasing complexity, the functions go g(n), h(n), f(n).So h(n) is a lower bound for f(n), h(n) is an upper bound for g(n), and f(n) is an upper bound for h(n).
",
"Complete this sentence:To sort N books, the runtime for _________ is ___ .
","Selection Sort -?(N)
","Insertion Sort -?(N^3)
","Insertion Sort -?(NlogN)
","Selection Sort -?(N^2)
",,"For Selection Sort: it will take N swap steps, plus N + N-1 + N-2 + ... + 2 + 1 steps to find the smallest book. So for N books, you will need N^2 steps to sort them.For Insertion Sort: the runtime is also?(N^2) in average, 1 step in round 1 + 2 steps in round 2 + ... + N-1 steps in the last round, so N^2.
",
"Open hash tables are almost always less runtime efficient than closed hash tables
","True
","False
","planation: They are almost always MORE efficient. Indeed, for .10 loads, both of the hash tables are going to take an average of 1.05 steps, but when it comes to .90 loads, the closed hash tables will take an average of 5.50 steps compared to the open hash tables, which will only take an average of 1.45 steps.
","gs: Hashtables
",,,"leabaviere (lcyb20 - permission to this course revoked)
"
"Which of these sorts are ALL Stable?
","Selection sort, Merge sort, Bubble Sort.
","Insertion sort, Heap sort, Merge sort.
","Merge sort, Insertion sort, Bubble sort.
","Selection sort, Shell Sort, Quick Sort.
","only Quick sort
","Insertion sort:T(n) for already or nearly-ordered arrays. T(n2) otherwise.Bubble sort:T(n) for already or nearly-ordered arrays (with a good implementation). T(n2) otherwiseMerge sort:T(n log2n) always. Used for sorting large amounts of data on disk (aka �external sorting�).
",
"How do you compute the Big-O of an algorithm?
","Count the number of ""n"" in an algorithm and add them. This is the Big-O of the algorithm.
","Determine how many steps f(n) an algorithm requires to solve the problem in terms of number of items n.For example: 3n^2 + 2n +1Solve for 0 and find two possible complexities.
","Determine how many steps f(n) an algorithm requires to solve the problem in terms of number of items n.For example: 3n^2 + 2n +1Keep the most significant term: 3n^2This is your Big-0: O(3n^2)
","Determine how many steps f(n) an algorithm requires to solve the problem in terms of number of items n.For example: 3n^2 + 2n +1Keep the most significant term: 3n^2Remove any constant multiplier -> n^2This is your Big-0: O(n^2)
",,"Find Big-oh:Determine how many steps f(n) an algorithm requires to solve the problem in terms of number of items n.For example: 3n^2 + 2n +1Keep the most significant term: 3n^2Remove any constant multiplier -> n^2This is your Big-0: O(n^2)
",
"Doubly Linked lists can only travel in one direction: down.
","True
","False
","planation: Simple linked lists can only travel in one direction (down),with Doubly Linked List we can move both directions.
","gs: Lists
",,,"kiaraplds (kgp22 - permission to this course revoked)
"
"What tree traversal algorithm was used on the binary tree to get the output of:
","Pre-order
","Post-order
","In-order
","Level-order
",,"Post-order algorithm:1. Process the nodes in the left sub-tree2. Process the nodes in the right sub-tree3. Process the current node
",
"What would the output be for the given tree when using post-order traversal? A / \ B C / \ / \ D E F G
","A B C D E F G
","D B E A F C G
","A B D E C F G
","D E B F G C A
",,"Post-order traversal requires us to first process nodes in the left sub-tree, then nodes in the right sub-tree, and finally the current node.
",
"What is the definition of a 'stable' sort?
","Stable sorting takes into account the initial ordering when sorting, maintaining the order of equal-valued items.
","Stable sorting takes exactly the same amount of time to run, given a constant number of items.
","Stable sorting sorts both the initial and final items symmetrically.
","Stable sorting does not sort already sorted items.
",,"The correct answer is A. A stable sort maintains the order of equal valued items. If two equal valued items were compared in a stable sort they would not switch positions.
",
"What is the complexity of the following code?int searchArray(int arr[], int n, int forValue) { for ( int i = 0; i < n; i++ ) { if (arr[i] == forValue) { return i*2; } }}
","T(n^2)
","T(nlog(n))
","T(2^n)
","T(n)
","T(1)
","The correct answer is T(n). This is the correct answer as the for loop is cycled through n times. If the value is found then it is returned.
",
"Which type of traversal follows the following steps?1. Process nodes in the left sub-tree2. Process nodes in the right sub-tree3. Process the current node
","In-Order Traversal
","Post-Order Traversal
","Pre-Order Traversal
","Mid-Order Traversal
",,"The correct answer is Post-Order traversal. This is because the current node is processed after(post) both the left and right subtrees have been processed. The current node will therefore be the last node to be processed using Post-Order traversal.
",
"What is a stable sorting algorithm?
","Algorithms which take into account the initial ordering when sorting � maintaining the order of equal-valued items.
","An algorithm which has elements which change state.
","Algorithms which re-order items without taking into account their initial ordering.
","Algorithms which use an abstract data type with dynamic space.
","None of the above.
","A stable sorting algorithms are algorithms which take into account the initial ordering when sorting � maintaining the order of equal-valued items.
",
"Which List structure is the quickest to traverse?
","Skip List
","Linked List
","Doubly Linked List
","Queue
","Stack
","A skip list has more pointers in the list nodes to traverse it quicker.
",
"Which statement about the trade-offs of having a big hash tables is true?
","Big hash tables have fast search time and an efficient use of memory.
","Big hash tables have fast search time and an inefficient use of memory.
","Big hash tables have slow search time and an efficient use of memory.
","Big hash tables have slow search time and an inefficient use of memory.
","None of the above.
","Big hash tables with too many buckets which ensures really fast searches because the hash functions map to more unique indexes but waste a lot memory.
",
"What is the worst-cast runtime-complexity of Bubblesort?
","O(1)
","O(n)
","O(n log n)
","O(n2)
","O(n!)
","Worst-Case is when the list is sorted in order backwards.In this case BubbleSort iterates through the list n times, and swaps the position of every pair it goes over for every iteration
",
"What is the best-case runtime-complexity ofBubble Sort?
","O(n2)
","O(n)
","O(n log n)
","O( log n)
","O (1)
","Best case scenario is where the list is already sorted.In this instance, bubblesort goes over every element once, and makes no changes
",
"For which operation performed on a singly linked list are the run time complexities NOT best case = 1, worst case = n, average case = n? (When you are not given a reference to the previous element)
","Removing an element
","Adding an element to the list at the start
","Inserting an element in the list
","Finding an element in the list
",,"When adding an element at the start of the list, the head pointer always lets you add the element without having to do any searching, so the best, worst and average case complexity for this operation is always 1.
",
"What is the best definition for a data structure?
","It is the data that is being operated on by an algorithm to solve a problem.
","It is a way in which we organise data on a computer.
","It is how elements of a collection of data are related to each other.
","It is how fast we can sort that data.
",,"As stated on slide 12 of Lecture 2. A data structure is the data that is operated on by an algorithm to solve a problem.
",
"Why is a Skip List a probabilistic data structure?
","Because the number of lanes every node has is determined randomly.
","Because the number of lanes the head has is determined randomly.
","Because the node that the head points to is determined randomly.
","Because there is no tail reference.
",,"When we create a skip list node we keep flipping a coin to decide if its number of lanes is increased by one, that is why its random and has a time complexity of log(n).
",
"Which of the options are the correct definitions for a data structure and a secondary data structure in the context of ADTs and Algorithms?
","Data Structure: A class in Java containing methods, variables and constructorsSecondary Data Structure: A class in Java which extends or implements an existing class
","Data Structure: A collection of variables in a structure definition in CSecondary Data Structure: A class in Java which extends or implements an existing class
","Data Structure: The data that is operated on by an algorithm to solve a problemSecondary Data Structure: An additional set of data created by an algorithm in the process of solving a problem
","Data Structure: The layout of a table of dataSecondary Data Structure: A sub-table of data that is referenced from the initial table
",,"In the lecture on ADTs, data structures were generically defined as a set of data that is operated on by an algorithm to solve a problem. Sometimes algorithms need to create or store extra bits of data, these are secondary data structures.
",
"Which of the following are Carey�s 2 Rules of Sorting?
","Don�t choose a sorting algorithm until you understand the requirements of your problem.andAlways choose the simplest sorting algorithm possible that meets your requirements.
","Don�t choose a sorting algorithm until you understand the requirements of your problem.andAlways choose the sorting algorithm which will be the simplest to implement even if it's less efficient.
","Always choose the algorithm with the lowest space complexity.andAlways choose the simplest sorting algorithm possible that meets your requirements.
","Always choose the sorting algorithm which will be the simplest to implement even if it's less efficient.andAlways choose the algorithm with the lowest space complexity.
","Always choose the algorithm with the lowest space complexity.andAlways choose the sorting algorithm which will sort the items correctly.
","You should use the requirements of the problem to inform your choice of algorithm. Once you have a choice of algorithm that fits these requirements you should always choose the simplest, most efficient option.
","ac2424 (ac2424 - permission to this course revoked)
"
"Which of the following are Carey�s 2 Rules of Sorting?
","Don�t choose a sorting algorithm until you understand the requirements of your problem.andAlways choose the simplest sorting algorithm possible that meets your requirements.
","Don�t choose a sorting algorithm until you understand the requirements of your problem.andAlways choose the sorting algorithm which will be the simplest to implement even if it's less efficient.
","Always choose the algorithm with the lowest space complexity.andAlways choose the simplest sorting algorithm possible that meets your requirements.
","Always choose the sorting algorithm which will be the simplest to implement even if it's less efficient.andAlways choose the algorithm with the lowest space complexity.
","Always choose the algorithm with the lowest space complexity.andAlways choose the sorting algorithm which will sort the items correctly.
","You should use the requirements of the problem to inform your choice of algorithm. Once you have a choice of algorithm that fits these requirements you should always choose the simplest, most efficient option.
","ac2424 (ac2424 - permission to this course revoked)
"
"What makes a binary tree balanced
","Given any node: | # of nodes in left sub tree - # of nodes in right sub tree| = {0, 1}
","It rarely falls over
","New nodes cannot be added to level L of the tree if level L - 1 is not full
","For all nodes, left child <= parent <= right child
","For all nodes, left child < parent < right child
","https://www.geeksforgeeks.org/avl-tree-set-1-insertion/
",
"in a linked list which of these methods has a guaranteed complexity of 1?
","get(i)
","add(o)
","remove(i)
","find(o)
","insert(o,i)
","all methods other than add have an average complexity of n, adding will always take a guaranteed time as it is always adding at a set location so doesn't need to traverse the list
","ac2424 (ac2424 - permission to this course revoked)
"
"in a linked list which of these methods has a guaranteed complexity of 1?
","get(i)
","add(o)
","remove(i)
","find(o)
","insert(o,i)
","all methods other than add have an average complexity of n, adding will always take a guaranteed time as it is always adding at a set location so doesn't need to traverse the list
","ac2424 (ac2424 - permission to this course revoked)
"
"What doesBig-Omega O(f(n)) refer to?
","lower bound of f(n)
","upper bound of f(n)
","middle Bound of f(n)
","planation: Lower Bound: g(n) = O(f(n)) (""g(n) is Big- Omega of f(n)"") iff there are constants c>0and n0>0 so that for all n>n0: g(n) = c f(n)it is used for underestimating eg.�it must be at least n�
",,,"ac2424 (ac2424 - permission to this course revoked)
"
"What is linear probing?
","a method of searching a tree for an item, one node at a time
","scanning through a hash table to find empty space
","the term for any search algorithm of linear complexity
","a link list with only one lane
",,"To avoid collisions in a hash table, linear probing is used to scan for the next available empty space if a bucket is full.
","ac2424 (ac2424 - permission to this course revoked)
"
"What is linear probing?
","a method of searching a tree for an item, one node at a time
","scanning through a hash table to find empty space
","the term for any search algorithm of linear complexity
","a link list with only one lane
",,"To avoid collisions in a hash table, linear probing is used to scan for the next available empty space if a bucket is full.
","ac2424 (ac2424 - permission to this course revoked)
"
"How do you delete an item from an open hash table?
","By adding a null value over the item in the hash table
","By removing the value from the Linked list
","You can't, as it is an open hash table and not a closed one
","Both A and B are valid answers
",,"Unlike a closed hash table, you can easily delete items from an open hash table
",
"What is the worst case time complexity of Insertion Sort?
","n
","n^2
","log(n)
","n^3
",,"We have to compare and shift up to N-1 books to find the right spot for the last element. The sum of all of the steps before that and this adds up to roughly N^2 steps
",
"For a list of n sorted items, what is the time complexity of Binary search?
","n*n
","n
","1
","log(n)
",,"In Binary Search, we keep on dividing our search area in half until we arrive at our item.
",
"A search engine 'Bugle' uses a system called PageRank to determine the order it shows results in.This involves solving a large matrix problem using an algorithm of order N2log(N) where the size of the matrix is N x N.Which one of the following statements is false?
","The order of the algorithm isO(N2)
","The order of the algorithm is O(2N)
","As N becomes larger, so will the runtime
","The algorithm will always run faster than another algorithm of order N4
","None of the above
","A & B) N2=O(N2log(N)) = O(N3) = O(2N),i.e for some real, non-negative constants w,x,y,z and N sufficiently large: w*(N2) < x*(N2log(N)) < y*N3 < z*2NC) Trivially trueD) For small N this is not necessarily true as the constant in front of the second algorithm could be very small compared to a large constant infront of the N2log(N) algorithm e.g.for (a) being the first algorithm, (b) the N4algorithm, and T being the actual run-time,we could have: T(a) = 0.00000001*N4, T(b) = 100000000*N2log(N), and so for N=10, T(a)>T(b).
",
"Which of the following is the output of In-order traversal on this tree: a / \ b e / \c d(Where the processing is simply printing the node value)
","c d b e a
","c b a d e
","a d c e b
","c b d a e
","e a b d c
","Using the notes from lecture 13:1. Process the nodes in the left sub-tree.2. Process the current node.3. Process the nodes in the right sub-tree.
",
"For the following tree, which traversal algorithm will print the following sequence : a b c d e f a / \ b c / d / \e f
","Pre-Order
","In-Order
","Post-Order
","Level-Order
",,"Pre-Order will print a b d e f cIn-Order will print e d f b a cPost-Order will print e f d b c aLevel-Order will print a b c d e f
",
"Consider a binary tree with numeric nodes where the left sub-tree consists of numbers less than the node, and the right sub-tree consists of numbers greater than the node.This tree is empty other than the root value: 10.The following numbers are inserted into the tree in order from left to right (i.e. 15 is inserted first):15, 6, 12, 4, 9, 11, 7, 8What is the height (number of levels) of the tree?
","3
","4
","5
","6
","7
","The tree should look like: 10 (1) / \ 6 15 (2) / \ / 4 9 12 (3) / / 7 11 (4) \ 8 (5)There are 5 levels, hence the height of the tree is 5
",
"Which of these is a valid shell sort sequence of h values?
","27 - 9 - 3
","16 - 8 - 4 - 2
","10 - 9 - 8 - 7 - 6 - 5 - 4 - 3
","12 - 8 - 4 - 1
",,"A Shell sort must end with a h-sort of 1 to ensure the sort is complete.
",
"An implementation of selection sort runs for 2s to sort a list of 1,000 records. How long will it likely run to sort 10,000 records?
","20s
","100s
","200s
","1000s
","2000s
","Selection sort has a runtime complexity of?(n2), so increasing the number of records by a factor of 10 increases the time taken to sort by a factor of 102 = 100.100 x 2s = 200s, therefore we would expect it to take 200s to sort 10,000 records.
",
"An algorithm takes 1s for n = 100. Given that its asymptotic time complexity is?(n2), how many seconds do you expect it to take for n = 800?
","4s
","8s
","16s
","64s
","128s
","?(n2) means that doubling n increases T by factor 4 (slide 14 on lecture 4).We start at n = 100, taking 1s.So n = 200, would take 4 x 1s = 4s.n = 400 would take 4 x 4s = 16s.n = 800 takes 4 x 16s = 64s.Therefore the answer is 64s.
",
"You wish to use a standard closed hashtable with linear probing (to the right, i.e. in the direction of higher indices). The hash function has the form h(x) = (x*x) % 5 , and the hash table has slots 0, ... , 4. If you insert the elements 3, 2, 4, 1, 5 in that order, what does the hashtable look like at the end?
","5, 4, 1, 2, 3
","4, 16, 1, 25, 9
","25, 16, 1, 4, 9
","2, 4, 1, 5, 3
","None of the others
","The correct answer is 2, 4, 1, 5, 3.We first insert 3: (3*3) % 5 = 9 % 5 = 4, so 3 goes in slot 4 (last one).Next insert 2: (2*2) % 5 = 4 % 5 = 4. However slot 4 is full, so we move one to the right, which loops us back to the front of the hashtable so we insert 2 in slot 0.Next insert 4: (4*4) % 5 = 16 % 5 = 1, so 4 goes in slot 1.Next insert 1: (1*1) % 5 = 1 % 5 = 1. Slot 1 is full so move one to the right and insert in slot 2, which is empty.Finally insert 5: (5*5) % 5 = 25 % 5 = 0. Slot 0 is full so move to the right. Slot 1 is also full so move right. Slot 2 is also full so move right. We find slot 3 is empty so we insert 5 into slot 3.
",
"What is the main advantage of considering an amortised runtime?
","The user does not need to see the exact workings of the code.
","Worst-case runtime per operation can be too pessimistic.
","It can give the user a greater bound for the worst-case runtime than when considering asympotitc complexity.
","Worst-case runtime per algorithm can be too pessimistic.
","None of the above.
","Worst-case runtime per operation can be too pessimistic. Operations may usually be quick, and only sometimes slow. So the average may not be so bad.
",
"When for loops are nested, the asymptotic time complexity can be found by multiplying the order of each loop. If the for loops are not nested, big-O complexity is given by...
","the highest order of one of the loops.
","the sum of the orders of the loops.
","the product of the orders of the loops.
","the average of the orders of the loops.
","the fastest performing loop.
","The highest order of one of the loops corresponds to the slowest performing loop, which gives us our upper bound.
",
"You are using a standard closed hashtable with linear probing (to the right). The hash function has the form h(x) = x % 5 and the hash table has slots 0,1,2,3,4. If you insert the elements 9,3,14,7,1 in this order, what does the hashtable look like at the end?
","1,3,7,9,14
","14,1,7,3,9
","3, 1, 14, 7, 9
","14, 7, 1, 3, 9
","None of the above.
","We first insert 9, which goes into slot 4: _,_,_,_,9We then insert 3, which goes into slot 3: _,_,_,3,9We then insert 14, which should go in slot 4. As slot 4 is full, we move to the next free slot which is slot 0: 14,_,_,3,9We then insert 7, which goes into slot 2: 14,_,7,3,9We finally insert 1, which goes into the remaining slot 1: 14,1,7,3,9 (which is answer B).
",
"If we insert a new node into the middle of a doubly linked list, which combination of the following sets of references must we update?a) The new node�s next and previous pointersb) The tail referencec) The previous node�s next pointerd) The following node�s previous pointere) The previous node�s previous pointer
","A, C & D
","A, D & E
","A
","B & C
",,"This can be taken from lecture slide 12 in Lecture 07
",
"Given a particular load L for an Open Hash Table, what is the average number of steps to insert or find an item?
","
","
","
","
","None of the above
","Answer given in lecture 9
",
"In which of the following cases is a linked list preferable to an array?1) Inserting a new element at the front of either2) Removing an element in the middle of either3) Getting the 200th element of either
","1 only
","1 and 2
","1 and 3
","1, 2 and 3
","None of the options
","Clearly reasoned in lecture 7
","chrisdix (csd31 - permission to this course revoked)
"
"In which of the following cases is a linked list preferable to an array?1) Inserting a new element at the front of either2) Removing an element in the middle of either3) Getting the 200th element of either
","1 only
","1 and 2
","1 and 3
","1, 2 and 3
","None of the options
","Clearly reasoned in lecture 7
","chrisdix (csd31 - permission to this course revoked)
"
"What binary tree traversal algorithm is described by the pseudocodebelow?1. Process the nodes in the left sub-tree.2. Process the current node.3. Process the nodes in the right sub tree.
","Pre-order traversal
","In-order traversal
","Post-order traversal
","Level-order traversal
",,"Definition can be seen in lecture 13
",
"What is the theta time complexity of the following algorithm fragment (f(a,b))?for (int i=0; i<a+b; i++) {System.out.println(i);}for (int i=0; i<a*a*a; i++) {System.out.println(i);}
","
","
","
","
","None of the above
","From lecture 5, we must take into account both independant input sizes. Considering both loops, the first is order exactly a+band the second is a^3. Combining these leaves only a^3 + b
",
"Given the numbers [1,4,6,3,7,2,10]. What would be the final balanced AVL Tree?
","
","
","
","
","None of the above
",,
"Which are the following statements are false?
","Selection sort has an average time complexity of O(n), is stable and is hard to implement in comparison with other sorting algorithms
","Merge sort has an average time complexity of O(n log n), is stable and can be parallelized across multiple cores
","Bubble sort is good for sorting nearly-sorted data, is stable and can be used with a linked list
","Insertion sort has an average time complexity of O(n), is stable and can be used with a linked list
","None of the above
","Selection sort is easy to implement, always has a time complexity of O(n2) and is unstable
",
"Does the following code result in a stable sort?void Sort(int[] a){ for(int s = 2; s <= a.length; s++) { int SortNum = a[ s - 1 ]; int i = s - 2; while (i >= 0 && SortNum <= a[i]) { a[i+1] = a[i]; i--; } a[i+1] = SortNum;}}
","Yes
","No (Neigh!!)
","planation: This code is almost identical to code for insertion sort, which is stable, but has one key differenceInstead of ""while (i >= 0 && SortNum < a[i])""we have ""while (i >= 0 && SortNum <= a[i])""This means when two items have the same value, the one that started off further back will actually move in front of the first one.E.g. in an array [10, 10, 1], the end result would be [1, 10, 10]
","gs: Sorting
",,,"dr474 (dr474 - permission to this course revoked)
"
"For what value of h is h-sorting essentially a bubble sort?
","0
","1
","Never
","Always
",,"When h = 1, h-sorting behaves exactly the same as a bubble sort.
",
"Given the following sorted list of numbers: 5, 14, 67, 146, 874, 946.How many iterations does linear search go through to find the number 146?
","3
","4
","6
","146
",,"Linear searchsequentially checks each element of the list until a match is found.So, it checks (5), which isn't a match (Iteration 1)Then, it checks (14), which is isn't a match (Iteration 2)Then, it checks (67), which isn't a match (Iteration 3)Then, it checks (146), which is a match (Iteration 4).Therefore, 4 iterations.
",
"Which of these algorithms uses divide and conquer?
","Quicksort and Mergesort
","Mergesort only
","Bubble Sort
","Sorting Sort
",,"Quicksort and Mergesort use divide and conquer.
",
"Given the int array 6, 5, 1, 4, 7, 8, 2, how many steps will it take to sort it in ascending order using bubble sort?
","3
","4
","5
","6
","None of the above
","Initial array: 6 5 1 4 7 8 2Iteration 1: 5 1 4 6 7 2 8Iteration 2: 1 4 5 6 2 7 8Iteration 3: 1 4 5 2 6 7 8Iteration 4: 1 4 2 5 6 7 8Iteration 5: 1 2 4 5 6 7 8Final iteration to check (iteration 6): 1 2 4 5 6 7 8
",
"What is the time complexity of Binary Search?
","O(Log(n))
","O(nLog(n))
","O(Nog(L))
","O()
",,"The time complexity for a binary search is O(Log(n))
",
"which of these sorts is stable
","none of the options bellow
","Shell sort
","Merge sort
","Quick sort
","horse sort (because it's in a stable hahahahah I am funny and no I did not copy this joke)
","Merge sorts will not rearrange elements already in the correct order
",
"What is the definition of Abstraction?
","Talking about things in an abstract manner
","The Hiding of unnecessary detail
","Space-Time Complexity
","Like Distraction, but with an A
",,"Abstraction is the hiding of unnecessary detail.
",
"Which of the following images represents low accuracy and high precision?
","
","
","
","
",,"Accuracy:Average difference between measurements and reference value r. (""How far away is each measurement from the 'true value'?"")Precision:Standard deviation s of the measurements (""How close is each measurement to each other?"")From these definitions, it is clear that the second imagerepresents low accuracy and high precision.(Other Images: Image 1: Low Accuracy, Low Precision Image 3: High Accuracy, Low Precision Image 4: High Accuracy, High Precision)
",
"What is the average time complexity of finding one element in a hash table (Assuming more slots are available than elements)?
","O(n)
","O(r)
","O(O(n))
","O(1)
",,"Searching a hash table is done in constant time so its complexity is O(1)
",
"When do you use Big-Theta notation when calculating time complexity?
","For over-estimation
","For under-estimation
","For exact estimation
","Whenever possible
","None of the above
","Big O is used for over-estimatingBig Omega is used for under-estimatingBig Theta is used for exact estimation
",
"Which of these describes the worst case performance time complexity for an algorithm?
","Big-O
","Big-?
","Big-O
","None of the Above
",,"Big-O describes the worse case scenario, this is the upper bound for an algorithm (i.e. It can never be slower than Big-O) Big Theta describes average performance and Big Gamma describes the best case performance.
",
"An empty closed hashtable which uses linear probing (to the right).The hashtable can store up to 6 data in 6 buckets (from 0-5).Data is inserted using the function:Where x is the data to be stored and the result is the bucket to insert it in.What would the resulting hashtable be, if we were to insert the following integers?18,33,9,3,27,21
","33,21,9,27,3,18
","18,33,21,9,27,3
","18,33,9,3,27,21
","18,33,3,9,27,21
",,"f(18) = 0Current result: 18, , , , ,f(33) = 1Current result: 18,33, , , ,f(9) = 3Current result: 18,33, ,9, ,f(3) = 5Current result: 18,33, ,9, ,3f(27) = 39 has already been put in this slot, so 27 is inserted in the next open slot.Current result: 18,33, ,9,27,3f(21) = 53 has already been put in this slot, so 21 is inserted in the next open slot.Current result: 18,33,21,9,27,3Finished result:18,33,21,9,27,3
",
"Whats the average number of steps to find any items in anopen hash table of 1213 buckets with 1000 elements in the table?
","1.29
","1.35
","1.41
","1.47
","1.53
","First calculate the load factor:L = max element / total buckets= 1000 / 1213=0.82 (2 sf)Then the expected steps = 1 + L/2 = 1.41 (3 sf)
",
"which of the following questions is unanswerable given only that for functions f and gf(n) = ?(1)g(n) = O(n)but would be answerable given more information
","?(g(n)) >?(f(n))
","O(g(n)) > O(f(n))
","f(n) > O(g(n))
","?(g(n)) =O(g(n))
","O(g(n)) > O(f(n))
","A is true,B is false and does not really make sense as there exists h such that ?(h(n)) >?(g(n) then h(n) = O(g(n)) andh(n) = O(f(n)) hence O(g(n)) = h(n) = O(f(n)) which impliesO(g(n)) = O(f(n)),C is false,D could be true or false depending on what?(g(n)) is,E is true
",
"If an algorithm has a complexity of, does it matter what k is? Why?
","Yes, because a logarithm with a different base could result in the complexity being a slower/ faster growing function.
","No, because we can change the base of the logarithm using the change of base formula and it would only result in multiplication by a constant.
","No, because k is a constant.
","Yes, because we can change the base of the logarithm using the change of base formula and it would result in multiplication by a linear factor.
",,"No, it doesn't matter.This is because we can change the base using the change of base formula :As you can see, the logarithm with our new base, b, is multiplied by , which is a constant.
",
"Why we need to a binary tree which is height balanced?
","to avoid formation of skew trees
","to save memory
","to attain faster memory access
","to simplify storing
","none of then
","In real world dealing with random values is often not possible, the probability that you are dealing with non random values(like sequential) leads to mostly skew trees, which leads to worst case. hence we make height balance.
",
"Which of the following code performs the partition operation correctly in QuickSort?
","private static int partition(int[] arr, int low, int high){int left, right, pivot_item = arr[low];left = low;right = high;while(left > right){while(arr[left] <= pivot_item){left++;}while(arr[right] > pivot_item){right--;}if(left < right){swap(arr, left, right);}}arr[low] = arr[right];arr[right] = pivot_item;return right;}
","private static int partition(int[] arr, int low, int high){int left, right, pivot_item = arr[low];left = low;right = high;while(left <= right){while(arr[left] <= pivot_item){left++;}while(arr[right] > pivot_item){right--;}if(left < right){swap(arr, left, right);}}arr[low] = arr[right];arr[right] = pivot_item;return right;}
","private static int partition(int[] arr, int low, int high){int left, right, pivot_item = arr[low];left = low;right = high;while(left <= right){while(arr[left] > pivot_item){left++;}while(arr[right] <= pivot_item){right--;}if(left < right){swap(arr, left, right);}}arr[low] = arr[right];arr[right] = pivot_item;return right;}
","private static int partition(int[] arr, int low, int high){int left, right, pivot_item = arr[low];left = low;right = high;while(left > right){while(arr[left] > pivot_item){left++;}while(arr[right] <= pivot_item){right--;}if(left < right){swap(arr, left, right);}}arr[low] = arr[right];arr[right] = pivot_item;return right;}
","private static int partition(int[] arr, int low, int high){int left, right, pivot_item = arr[low];left = low;right = high;while(left <= right){while(arr[left] <= pivot_item){left++;}while(arr[right] > pivot_item){right--;}if(left < right){swap(arr, left, right);}}arr[right] = pivot_item;arr[low] = arr[right];return right;}
","The array is partitioned such that the elements left to the pivot are lesser than the pivot while the elements right of the pivot are greater than the pivot.
",
"which of the following data structure are similar to skipList?
","stack
","hash table
","binary search tree
","balanced binary search tree
","DoublyLinked list
","all elements lesser than the top line elements are placed infront of it and greater ones after it. And skip lists have the same time complexities as balanced binary search trees.
",
"Select the option where the given data structure andcomplexity for search time (check that it contains an object) do not match.
","Array has search time complexity O(n)
","Linked List has search time complexity O(n)
","Doubly Linked List has search time complexity O(Log(n))
","Skip List has time search time complexity O(Log(n))
","None of the above
","A doubly linked list is simply a linked list with pointers to the previous element as well as the next element hence it has the same search complexity as a linked list, n. This is as the best way to search it is by using a linear search algorithm as it is an unordered list
",
"Which of the following statements about open hash tables is false
","Open hash tables can store more objects when compared to a closed hash table with the same sized hash.
","If an object is hashed to a slot that is already full then the object will be put in the next available slot after the slot mapped to in an open hash table.
","The time tocheck if the hash table holds an object is affected by the load.
","Open hash tables allow objects to be removed easily.
","It becomes slower to check if the hash table holds an object when it contains more objects.
","Remember that an open hash table will put objects into linked lists and closed hash tables will put objects into the first available slots.Even though linked lists can hold multiple objects they will take longer to see if it contains an object if there are more objects to check.The load is the fullness of the hash table, hence if it is bigger it will take longer to do things.
",
"When implementing a singly linked list, which of the following statements is true?
","The head pointer should always point to the most recently added element
","The tail pointer allows you to traverse the linked list backwards
","Finding an element has worst case time complexity of
","Inserting an element has worst case time complexity of
","You remove any element by changing the head pointer to point to the element after the one you want removed
","When an element is added that comes anywhere other than first in the list, then the head pointer should stay the same, as the first element in the list has not changed.In a singly linked list, their is only one pointer for each element which allows forwards traversal of the list, there is no way to travel backwards.In cases where the element you are searching for is not the first one in the list, then more than 1 comparisons have to be made.When inserting an element at the end of a linked list (worst case), then the time complexity is theta(n).To remove the first element in a linked list, then you would do so by updating the head pointer to the element after it.
",
"What is the big O complexity f(n) of the following code?(A) for( int i = 0; i < n; i++){(B) for( int j = i; j < n; j++){(C) for( int k = 0; k < 4; k++){ System.out.println(""Hello World!""); } } }
","n
","n2
","n3
","nlog(n)
","None of the above
","Let K be the constant operation time for the Loop (C).As the loop (C) always performs 4 print statements.Now, for i = 0: (B) performs (n) Loops of K. i = 1: (B) ... (n-1) ... i = 2: (B) ... (n-2) ... ... ... ... i = n: (B) ... (0) ...Then the loop (A) & (B) can be seen as this(n) * K + (n-1) * K + (n-2) * K + ... + (1) * K + (0) * KFor every increase in i, the loop (B) decreases.This can be simplified by the summation formulawhich yields:(n)(n+1)/2 * K = (K/2)(n^2 + n)Hence, the Big O complexity of ( n^2 )
",
"Which of the following is not included in an Abstract Data Type (ADT)?
","A set of data structures
","A set of algorithms
","An interface
","None of the above - they are all included
",,"An ADT consists of a set of data structures, set of algorithms and an interface all working together, and therefore they are all necessary.
",
"Which of these is not an example of a stable sort?
","Insertion Sort
","Merge Sort
","Selection Sort
","Bubble Sort
","None of the above
","Selection Sort is unstable, the rest are stable.
",
"Which of these is the correct order for the runtime complexity classes - from fastest to slowest, for large values of n?
","constant, log(n), sqrt(n), n, nlog(n), n^2, n^3, 2^n
","log(n), n, constant, sqrt(n), nlog(n), n^2, 2^n, n^3
","constant, log(n), sqrt(n), n, nlog(n), n^2, 2^n, n^3
","constant, log(n), n, sqrt(n), nlog(n), n^2, n^3, 2^n
","None of the above
","For large values of n, this answer shows the fastest running first and ends in the slowest
",
"what is the theta complexity of this algorithm f(n)function int f(int n){ int c = 0; for (int i=1 i<n; i=i*2){ for (int j=0; j<i; j++){ c++; } } return c;}
","n log (n)
","( log (n) ) ^2
","n^2
","n
","log (n)
","The function outputs its complexity as c is incremented in the inner most loop so f(n) approximately equivalent to the number of operations. Try running this code yourself :public class complex { public static void main(String[] args) { double n = 128; //try changing n for yourself double c = 0; for (int i=1; i<n; i=i*2){ for (int j=0; j<i; j++){ c++; } } System.out.print((c - n)/n); }}If you try the code f(8) it will output 1 + 2 + 4 = 7or f(32) it will output 1 + 2 + 4 + 8 + 16 = 31or f(30) it will output 1 + 2 + 4 + 8 + 16 = 31As you can see the complexity is always take x - 1 (where x is n rounded up to the next power of 2And rounding does not affect the complexity and neither does subtracting oneHence the complexity is n
",
"Given the following sorted list of numbers:1, 2, 34, 45, 104, 287, 287, 299Using the binary search algorithm; how many comparisons would it take to determine if the number 0 is in the list (when using the floor function for finding the middle element of the list)?
","2
","3
","4
","5
","None of the above.
","Compare 45 with 0; take the lower half of the list: 1, 2, 34Compare 2 with 0; take the lower half of the list: 1Compare 1 with 0; this was the last element.So it takes 3 comparisons to determine 0 is not in the list.
",
"What is a stable sort?
","A sort which has a space complexity of O(n).
","A strong sort which is very quick.
","A sort which takes into account the initial ordering.
","A sorting algorithm often used on horses.
","A sort which has an average time complexity of O(n log n).
","A stable sort is a sorting algorithm which takes into account the initial ordering, and maintains the order of equal-valued items. Examples include: merge sort, bubble sort and insertion sort.
",
"When inserting a node in a doubly linked list, we must update:
","The new node's next pointerThe previous node's next pointerThe following node's previous pointer
","The new node's next and previous pointerThe previous node's next pointerThe following node's previous pointer
","The new node's next and previous pointerThe previous node's previous pointerThe following node's next pointer
","The new node's next and previous pointerThe previous node's next pointerThe following node's next pointer
","The new node's next and previous pointerThe previous node's next and previous pointerThe following node's next and previous pointer
","We update the new node's next pointer to point to the following node, the new node's previous pointer to point to the previous node, the previous node's next pointer to the new node and the following node's previous pointer to the new node. The list has been updated.
",
"How is the time complexity function determined?
","Count how many lines of code the algorithm requires.
","Record the time at the start of the algorithm, record the time afterwards and take the difference.
","Measure how much space, at any point in the algorithm, is required.
","The number of elementary operations an algorithm performs is determined.
",,"Elementary operations take a fixed amount of time. Therefore by measuring how many of these elementary operations (eg. accessing an item from an array) we can determine the time complexity of an algorithm.
",
"Which of the following sorting algorithms is stable?
","ShellSort
","QuickSort
","SelectionSort
","InsertionSort
","None of the above
","Insertion sort works by shifting elements rather than swapping them, so the original order of equivalent values is preserved after sorting.See lectures 10 and 11 for full details
",
"In which of the following data structures is it difficult (not recommended) to remove values from?
","Linked lists
","Open hash tables
","Doubly linked lists
","Closed hash tables (with Linear probing)
","Arrays
","For Linked lists, and Doubly linked lists it is easy to remove values by just adjusting the next (and prev) pointers.For Arrays, it is easy to remove values by just assigning the position a null value.Open hash tables are essentially just arrays where the elements are linked lists, so values can be easily removed in the same way that you would for a linked list.Closed hash tables (with Linear probing) cause an issue though, as when you remove a value from a closed hash table, it creates a gap which can break your linear probing search algorithm.See Lecture 7 and 9 for full details.
",
"Given a particular load L for a Closed Hash Table w LP, what is the maximum number of steps to find the bucket?
","�(1+ 1/(1-L))
","L
","Total Buckets in Array/L
","1/(1-L)
","1
","Average # of steps = �(1+ 1/(1-L)) for L < 1.0. ""1"" and ""1/(1-L)"" represent the minimum and maximum# steps to find a bucket, respectively.
",
"Which of the following sorting algorithms does not have a worst case time complexity of O(n2)?
","Quick sort
","Bubble sort
","Merge sort
","Insertion sort
","None of the above
","Merge sort has worst time complexityO(n log(n))
",
"Which of the following bounds are correct for the run time of the following code?for ( int i = 0; i < n; i++) for ( int j = 0; j < n; j++) out.println(�Hapax Legomenon�)A)O( n2 )B)?( n2 )C) O(log n)D)O( n3)
","A, B & C are correct, D is wrong
","B & C are correct, A & D are wrong
","A & D are correct, B & C are wrong
","A & B are correct, C & D are wrong
","All four are wrong
","The code has run time that would be bounded by?(n2). Thus, B is correct. A is also correct because?(n2) implies bothO(n2) and O(n2).C and D are wrong; the code has higher complexity than log n so for large enough n, there would be no constant large enough to be an upper bound for this. Conversely, n3 increases much faster than n2 so for large n could not be a lower bound.Thus, D is the correct answer to the question.
",
"Suppose you are given that an element is definitely in the Hash Table. You search for this element in the Hash Table with linear probing. You calculate the bucket for the element's key using the hash function. However, when you check the appropriate bucket it contains a different key. Which of the following are possible reasons for this?A) The element was inserted in the Hash Table but then got over-written by another element with the same bucket number.B) The element is placed below it's bucket calculated by the hash function.C) The other key had the same bucket calculated by the hash function.D) The other key was forced to move down to the bucket because it's own bucket was already filled.
","A C D
","C D
","B C D
","B C
","B D
","A contradicts the definition of a closed hash table with linear probing.B is a direct consequence of C or D, i.e. if the key's bucket is full it is placed in the first empty bucket that is found.Note that B could have also said the key is placed in a bucket above it's hash function bucket.
",
"For a Hash Table with T slots already containing n elements how likely are there going to be collisions in the Hash Table?
","
","
","
","
","
","This was approximated in Lecture 9 based on the Birthday Problem.
",
"Suppose you are searching for an element in a sorted list of size x using binary search.In how many steps no matter what element we are looking for can we find it?
","x
","2x
","x+5
","log2(x)
","x2
","The binary search works in the following way:1)Compare to the middle element2)If equals the middle element - searching is done2)If not either - get rid of the second half of the list if element should come before the middle element or get rid of the first half of the list if element should come after the middle element4)Repeat with the new shortened listWe are interested in the number of times we need to halve the size of the list (i.e. x) until we are unable to keep halving the list (i.e. reach 1). This can be done in precisely log2(x) steps. Therefore, we are guaranteed to either find the element or conclude element not in the list in log2(x) steps.
",
"Which of these are problems one might face working with Array-based Lists?A) Slow to add an element at the endB) Limited capacityC) Slow to insert/remove anywhere in the listD) Slow random access
","D
","B and D
","B and C
","A and D
","C
","In Lecture 6 the problems with an Array based List were discussed. Namely, we run into problems if an array gets full and it is more troublesome to insert/remove an element anywhere in the list.
",
"How many iterations of the bubble sort algorithm would it take to sort the following list in ascending order?3, 1, 4, 5, 9 ,2, 6
","3
","4
","5
","6
","None of the above.
","initial: 3, 1, 4, 5, 9 ,2, 6pass 1: 1, 3, 4, 5, 2, 6, 9pass 2: 1, 3, 4, 2, 5, 6, 9pass 3: 1, 3, 2, 4, 5, 6, 9pass 4: 1, 2, 3, 4, 5, 6, 9and one final iteration to check if the list is sorted= 5 iterations.
",
"Out of the following options, which is the most problematic when using a closed hash table with linear probing?
","Inserting elements
","Retrieving elements
","Removing elements
","None are problematic
",,"Removing elements with linear probing in closed hash tables is most problematic as deleting one element could lead to other elements never being found when searched for, for example.Inserting elements is easier as long as we have space in the hash table, and retrieving elements is relatively simple with hash tables.
",
"Below is a function, how many elementary operations, in terms of n, are there in the body of the function?public int examQ(int num, int n){ int result = 0; for(int i=0; i<n; i++) { result = result + num; } return result;}
","3n + 3
","4n + 3
","3n + 4
","4n + 4
","None of the above.
","int result = 0; is 1 elementary operationint i = 0; is 1 elementary operationi < n; is n+1 elementary operationsi++; is n elementary operationsresult = ; is n elementary operations(including the fact it is in a loop)result + num; is n elementary operations(including the fact it is in a loop)return result; is 1 elementary operationSo overall, there are 1+1+n+1+n+n+n+1 = 4n+4 elementary operations
",
"Which sorting method has the potential to be faster (improving from O(n^2) time complexity to O(n)) if the list is already sorted in the first place?
","Selection
","Insertion
","Selection and Insertion
","Neither selection nor insertion
",,"B is the correct answerAs explained in Lecture 10,selection sort takes just as many steps either way, but insertion sort can be sped up to O(n) if the list is already in the correct order initially
",
"What is an Abstract Data Type?
","A coordinated group of personal data, algorithms and interface functions
","A coordinated group of data structures, algorithms and interface functions
","A coordinated group of dummy methods and inherited classes
","A coordinated group of sorting and searching algorithms
","A coordinated group of stacks, queues and linked lists
","B is the correct definition, as given in Lecture 2
",
"Imagine an empty closed hashtable that uses linear probing (to the right) to counter collisions.This closed hashtable can store a maximum of 5 data in 5 buckets labelled 0-4 in ascending order. It uses the hashing function f where:Where x is the data to be stored and f(x) is the bucket to store it in.If you were to insert the following data (from left to right) into this hashtable:6, 3, 2, 1, 5What order would the data be stored after insertion?
","2, 1, 6, 3, 5
","5, 6, 3, 2, 1
","5, 1, 6, 3, 2
","1, 5, 6, 3, 2
","None of the above.
","f(6) = 2 so place 6 in slot 2f(3) = 3 so place 3 in slot 3f(2) = 3 so place 3 in slot 4 as slot 3 is fullf(1) = 2 so place 1 in slot 0 as slots 2, 3 and 4 are fullf(5) = 0 so place 5 in slot 1 as slot 0 is full, , , , , , 6, , , , 6, 3, , , 6, 3, 21, , 6, 3, 21, 5, 6, 3, 2
",
"Consider the following runtimes for a list-sorting algorithm, with n as the size of the list and t as the time taken in seconds:n = 2000, t = 57n = 4000, t = 456n = 8000, t = 3648Which is the best approximation of the runtime complexity of the algorithm?
","?()
","?()
","?()
","?()
","None of the above.
","The answer is?() because, as n doubles in size, the time taken is increasing by a factor of 8 which is .
",
"What does it mean for a sort to be stable?
","Elements that would be sorted as the same value keep their initial relative order
","It doesn't crash.
","It has a small run-time.
","It does its swaps over large distances.
",,"Stable sorts were defined in lecture 10.
",
"2 functions refer to the run-times of 2 algorithms:f(n)>0, g(n)>0a>0, A>0g(n) = A f(n) for all n>aWhich of the following is definitely true?
","g(n) = O(f(n))
","g(n) = O(f(n))
","g(n) = ?(f(n))
","f(n) = ?(g(n))
","f(n) = g(n)
","this is the definition forg(n) = O(f(n)) as seen in lecture 4
",
"Which of the following sorts has the quickest run-time (on average) for large amounts of data?
","Insertion sort
","Merge sort
","Shell sort
","Bubble sort
",,"for n unsorted objects:Insertion sort has complexity Merge sort has complexity Shell sort has complexity Bubble sort has complexity of these merge sort grows the slowest for large n so is quickest for large n on average
",
"You plan to store data in a closed hash table with linear probing to the right. The hash function you are using is h(x) = x % 8, meaning there are 8 slots in your hash table; 0,1,2,3,4,5,6,7. If you insert the elements 14, 21, 13, 10, 6, 9, 1, 18 into the hash table, in that order, what would it look like at the end?
","14, 21, 13, 10, 6, 9, 1, 18
","6, 9, 10, 1, 18, 21, 14, 13
","14, 1, 10, 9, 18, 21, 6, 13
","10, 6, 9, 1, 18, 21, 14, 13
","9, 1, 10, 18, 6, 21, 14, 13
","B is correct. 14 goes in slot 6, as 14-6=8. Then 21 goes in slot 5, as 21-8-8=5. Next 13 would go in slot 5, so moves along to the right, where the next space is slot 7. 10 goes straight into slot 2 (10-8=2). 6 cannot go in slot 6 or 7, so goes in 0. 9-8=1, so 9 goes in slot 1. 1 then can't go in slot 1, or 2 as these are occupied, so goes in slot 3. Finally, 18 goes into slot 4, as this is the final empty space left.
",
"Which of the following is the correct definition for a function f(n) having asymptotic time complexity given byO(n�)?[For f(n) > 0 for n>0]
","There exists a constant n0> 0 such that for all n >n0: f(n)= n2
","There exist constants c > 0 and n0 > 0 such that for all n > n0 : f(n) = cn3
","There exist constants c > 0 and n0 < 0 such that for all n < n0 : f(n) = n3
","There exist constants c > 0 and n0 > 0 such that for all n > n0 : f(n) = cn2
","There exist constants c > 0 and n0 < 0 such that for all n < n0 : f(n) = cn2
","O(n�) is the lower bound of the function; so f(n) must always be below cn2 after some n0.
",
"The runtime for the following code fragment is . What is f(n)?for (int i=0; i<n; i++) for (int j=0; j<i/10; j++) for (int k=1; k<n; k=2*k) System.out.println(i);
","
","
","
","
","None of the others
","Constant factors such as 1/10 can be ignored. The total number of iterations of the two outer loops together is given by the sum 1+2+...+n which is. The innermost loop doubles k in every iteration until n is reached, so this is. The loops are nested, therefore the overall complexity is.
",
